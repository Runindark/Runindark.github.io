<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    《天净沙·我·并发编程篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？ |
    
    Cat&#39;s blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  

<article id="post-我为阿里" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      《天净沙·我·并发编程篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2020/03/09/我为阿里/" class="article-date">
  <time datetime="2020-03-09T12:19:18.601Z" itemprop="datePublished">2020-03-09</time>
</a>
        
      </div>
    

    
      
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="进程，协程，线程基础概念"><a href="#进程，协程，线程基础概念" class="headerlink" title="进程，协程，线程基础概念"></a>进程，协程，线程基础概念</h2><h3 id="能否解释进程，线程，协程的关系？"><a href="#能否解释进程，线程，协程的关系？" class="headerlink" title="能否解释进程，线程，协程的关系？"></a>能否解释进程，线程，协程的关系？</h3><blockquote>
<p>进程是一个程序代码运行所执行的一个程序，但是一个进程可以包含多个线程，在单核cpu下，Java默认多线程可以以一种抢占式的方式执行一种并发状态，协程是近些年走进视野的，以GO语言为代表可以操作协程，一个线程中可以包含更多的协程，可以简单的说线程包含协程。</p>
</blockquote>
<h3 id="协程对于多线程有什么优缺点吗？"><a href="#协程对于多线程有什么优缺点吗？" class="headerlink" title="协程对于多线程有什么优缺点吗？"></a>协程对于多线程有什么优缺点吗？</h3><ol>
<li>首先是更小的协程可以在不使用内核的前提下进行上下文切换</li>
<li>一个线程就可以完成高并发的任务，对高并发的支持更好</li>
<li>协程在一个线程下，是不用考虑数据的读写不一致问题（读写变量冲突问题）</li>
<li>缺点： 缺点也很明显，本质还是一个单线程，不能利用多核资源，同时也不独立，需要线程，进程配合才可以运行</li>
</ol>
<h3 id="并行和并发的区别是什么？"><a href="#并行和并发的区别是什么？" class="headerlink" title="并行和并发的区别是什么？"></a>并行和并发的区别是什么？</h3><ol>
<li>并行是指多个程序 同时多个一起运行</li>
<li>并发是指多个程序在某一个时间段内交替的快速运行，宏观是有点类似并行，但是实际上是交替运行</li>
<li>恶补英语之==&gt; 并发 （concurrency）  并⾏ parallellism</li>
</ol>
<h2 id="多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）"><a href="#多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）" class="headerlink" title="多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）"></a>多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）</h2><h3 id="Java线程创建的几种方式"><a href="#Java线程创建的几种方式" class="headerlink" title="Java线程创建的几种方式"></a>Java线程创建的几种方式</h3><ol>
<li><p>继承extends</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread by extend Thread"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadByThread threadByThread = <span class="keyword">new</span> ThreadByThread() ;</span><br><span class="line">        threadByThread.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Runnable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread create by implements Runnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadByRunnable ta = <span class="keyword">new</span> ThreadByRunnable() ;</span><br><span class="line">        <span class="keyword">new</span> Thread(ta).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用CF</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByCF</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Thread create by CF"</span> +<span class="string">":"</span> +Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FutureTask&lt;Object&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> ThreadByCF()) ;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.setName(<span class="string">"Cf"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.print.DocFlavor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            service.execute(<span class="keyword">new</span> ThreadByThread());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread());</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="线程基本原理"><a href="#线程基本原理" class="headerlink" title="线程基本原理"></a>线程基本原理</h2><h3 id="线程有哪些状态"><a href="#线程有哪些状态" class="headerlink" title="线程有哪些状态"></a>线程有哪些状态</h3><blockquote>
<p>创建 -&gt; 就绪 -&gt; 执行 -&gt; 消亡<br>阻塞: 分为同步组织，等待阻塞。 等待阻塞就是wait啦，sleep啦。同步阻塞就是sychronize锁被占用，另一个线程也需要占用这个锁，结果凉了，就阻塞了。</p>
</blockquote>
<h3 id="线程的基本一些方法"><a href="#线程的基本一些方法" class="headerlink" title="线程的基本一些方法"></a>线程的基本一些方法</h3><ol>
<li>sleep<blockquote>
<p>就是进入了等待阻塞队列中，根据设定的时间阻塞，而且不会释放锁，他的阻塞状态就是time_waiting</p>
</blockquote>
</li>
<li>yield<blockquote>
<p>就是让线程立马停止一下，但是不会进入阻塞，而是直接进入就绪,且不会释放锁</p>
</blockquote>
</li>
<li>join<blockquote>
<p>有点救护车让道的意思，谁调用join谁先执行，然后再执行被停用的线程</p>
</blockquote>
</li>
<li>wait<blockquote>
<p>就是进入等待状态，而且必须有人去唤醒他，没人唤醒，就被打入阻塞冷宫这辈子也就这样了，但是wait会释放锁，也可以wait（time）来通过时间唤醒</p>
</blockquote>
</li>
<li>notify<blockquote>
<p>唤醒wait打入冷宫的老铁，但是唤醒谁不能指定，唤醒全靠缘分</p>
</blockquote>
</li>
<li>notifyall<blockquote>
<p>大发慈悲，冷宫的全放出来了</p>
</blockquote>
</li>
</ol>
<h3 id="线程不安全的同步容器比如？"><a href="#线程不安全的同步容器比如？" class="headerlink" title="线程不安全的同步容器比如？"></a>线程不安全的同步容器比如？</h3><blockquote>
<p>HashMap、ArrayList、LinkedList</p>
</blockquote>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="说说volatile的与sychronize的区别"><a href="#说说volatile的与sychronize的区别" class="headerlink" title="说说volatile的与sychronize的区别"></a>说说volatile的与sychronize的区别</h3><ol>
<li>volatile 不是原子性的，sychronize是原子性的</li>
<li>volatile和sychronize都保证了可见性</li>
<li>volatile是禁止了指令重排的</li>
<li>不能写入 不能修饰写⼊操作依赖当前值的变量，⽐如num++、num=num+1</li>
</ol>
<h3 id="为啥会出现脏读的问题？"><a href="#为啥会出现脏读的问题？" class="headerlink" title="为啥会出现脏读的问题？"></a>为啥会出现脏读的问题？</h3><blockquote>
<p>这个是JMM（java内存模型） 导致的，java线程中不是所有的变量都是在主存的，而是每个线程都有自己的一丢丢空间，对于修改的变量的操作，先从主存拿到，再修改，再写回去，如果多线程，可能因为速度问题，写入的时间啥的有差别，所以就会导致把数据脏读了。</p>
</blockquote>
<h3 id="为啥volatile可以解决这个问题呢？"><a href="#为啥volatile可以解决这个问题呢？" class="headerlink" title="为啥volatile可以解决这个问题呢？"></a>为啥volatile可以解决这个问题呢？</h3><blockquote>
<p>volatile就像是一个敏感的报警灯一样，一旦有人妄图修改volatile修饰的数据，立马报警通知修改情况，所以说原子性差了点，但是可见性或者说是共享性好的鸭匹</p>
</blockquote>
<h2 id="指令重排-happens-before"><a href="#指令重排-happens-before" class="headerlink" title="指令重排/happens-before"></a>指令重排/happens-before</h2><h3 id="啥是指令重排？"><a href="#啥是指令重排？" class="headerlink" title="啥是指令重排？"></a>啥是指令重排？</h3><blockquote>
<p>为了提高程序的执行效率，再不改变运行结果的前提下，jvm对字节码文件的指令重新排序，以提高效率</p>
</blockquote>
<h3 id="知道-happens-before吗，能否简单解释下？"><a href="#知道-happens-before吗，能否简单解释下？" class="headerlink" title="知道 happens-before吗，能否简单解释下？"></a>知道 happens-before吗，能否简单解释下？</h3><blockquote>
<p>由于多线程的特殊性，对jvm的指令重排有严格的限制，所以有了happens-before的原则（先行发生原则） ==&gt;（这个解释靠谱：前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量a赋值为1，那后面一个操作肯定能知道a已经变成了1。）</p>
</blockquote>
<h3 id="划重点：这些规则一并奉上"><a href="#划重点：这些规则一并奉上" class="headerlink" title="划重点：这些规则一并奉上"></a>划重点：这些规则一并奉上</h3><ol>
<li><p>程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！</p>
</li>
<li><p>管程锁定规则：就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）</p>
</li>
<li><p>volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</p>
</li>
<li><p>线程启动规则：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</p>
</li>
<li><p>线程终止规则：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。</p>
</li>
<li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。</p>
</li>
<li><p>传递规则：这个简单的，就是happens-before原则具有传递性，即A happens-before B ， B happens-before C，那么A happens-before C。</p>
</li>
<li><p>对象终结规则：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</p>
</li>
</ol>
<h2 id="并发编程进阶"><a href="#并发编程进阶" class="headerlink" title="并发编程进阶"></a>并发编程进阶</h2><h3 id="并发编程三要素："><a href="#并发编程三要素：" class="headerlink" title="并发编程三要素："></a>并发编程三要素：</h3><h4 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h4><blockquote>
<p>要么全成功，要么全失败<br>例如num++ 这种操作就是非原子性的  可以用lock或者Sychronized来修饰这个操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h4><h4 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h4><h2 id="进程的执行顺序"><a href="#进程的执行顺序" class="headerlink" title="进程的执行顺序"></a>进程的执行顺序</h2><h3 id="先来先服务调度算法："><a href="#先来先服务调度算法：" class="headerlink" title="先来先服务调度算法："></a>先来先服务调度算法：</h3><blockquote>
<p>按照作业/进程到达的先后顺序进⾏调度 ，即：优先考虑在系统中等待时间最⻓的作业<br>排在⻓进程后的短进程的等待时间⻓，不利于短作业/进程</p>
</blockquote>
<h3 id="短作业优先调度算法："><a href="#短作业优先调度算法：" class="headerlink" title="短作业优先调度算法："></a>短作业优先调度算法：</h3><blockquote>
<p>短进程/作业（要求服务时间最短）在实际情况中占有很⼤⽐例，为了使得它们优先执⾏<br>对⻓作业不友好</p>
</blockquote>
<h3 id="⾼响应⽐优先调度算法"><a href="#⾼响应⽐优先调度算法" class="headerlink" title="⾼响应⽐优先调度算法:"></a>⾼响应⽐优先调度算法:</h3><blockquote>
<p>在每次调度时，先计算各个作业的优先权：优先权=响应⽐=（等待时间+要求服务时间）/<br>要求服务时间,<br>因为等待时间与服务时间之和就是系统对该作业的响应时间，所以 优先权=响应⽐=响应<br>时间/要求服务时间，选 择优先权⾼的进⾏服务需要计算优先权信息，增加了系统的开销</p>
</blockquote>
<h4 id="时间⽚轮转调度算法"><a href="#时间⽚轮转调度算法" class="headerlink" title="时间⽚轮转调度算法:"></a>时间⽚轮转调度算法:</h4><blockquote>
<p>轮流的为各个进程服务，让每个进程在⼀定时间间隔内都可以得到响应<br>由于⾼频率的进程切换，会增加了开销，且不区分任务的紧急程度</p>
</blockquote>
<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法:"></a>优先级调度算法:</h3><blockquote>
<p>根据任务的紧急程度进⾏调度，⾼优先级的先处理，低优先级的慢处理<br>如果⾼优先级任务很多且持续产⽣，那低优先级的就可能很慢才被处理</p>
</blockquote>
<h2 id="线程的调度算法"><a href="#线程的调度算法" class="headerlink" title="线程的调度算法"></a>线程的调度算法</h2><h3 id="协同式线程调度-分时调度模式-："><a href="#协同式线程调度-分时调度模式-：" class="headerlink" title="协同式线程调度(分时调度模式)："></a>协同式线程调度(分时调度模式)：</h3><blockquote>
<p>线程执⾏时间由线程本身来控制，线程把⾃⼰的⼯作执⾏完之后，<br>要主动通知系统切换到另外⼀个线程上。最⼤好处是实现简单，且切换操作对线程⾃⼰是可知的，没<br>啥线程同步问题。坏处是线程执⾏时间不可控制，如果⼀个线程有问题，可能⼀直阻塞在那⾥</p>
</blockquote>
<blockquote>
<p>(佛系顺序执行，自己完事叫下一个继续)</p>
</blockquote>
<h3 id="抢占式线程调度："><a href="#抢占式线程调度：" class="headerlink" title="抢占式线程调度："></a>抢占式线程调度：</h3><blockquote>
<p>每个线程将由系统来分配执⾏时间，线程的切换不由线程本身来决定（Java中，<br>Thread.yield()可以让出执⾏时间，但⽆法获取执⾏时间）。线程执⾏时间系统可控，也不会有⼀<br>个线程导致整个进程阻塞</p>
</blockquote>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><blockquote>
<p>每次读写数据都是悲观的，认为可能会出现数据被其它线程读的问题，所以要上锁比如sychronized</p>
</blockquote>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote>
<p>每次读取数据都觉得是乐观的，觉得不会有其它线程更改要读取的数据</p>
</blockquote>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><blockquote>
<p>就是大家人人平等，都可以拿到锁，阻塞队列中按照顺序慢慢来=》reetrantlock（fair）</p>
</blockquote>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><blockquote>
<p>不公平的，只要你条件符合，就可以直接拿到锁=》reetrantlock（unfair）<br>reetrantlock其实底层就是一个队列，所以也是先来先服务那种，在公平锁体现的很好</p>
</blockquote>
<h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><blockquote>
<p>一个线程里吧，还调用另一个线程，然后这个锁对里面的这个线程也生效</p>
</blockquote>
<h3 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h3><blockquote>
<p>一个线程里吧，还调用另一个线程，然后吧，里面这个线程就不能用这个锁了，就只能乖巧的滚去阻塞队列了</p>
</blockquote>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><blockquote>
<p>就是想不开的锁，只要没条件获取到锁，就一直自旋，也就是一直去判断条件看看自己能不能获得锁子，while（flag）的感觉，除非获得锁才能结束，但是注意，自旋锁消耗cpu，毕竟在那转来转去的。<br>不会发⽣线程状态的切换，⼀直处于⽤户态，减少了线程上下⽂切换的消耗，缺点是循环会消耗CPU</p>
</blockquote>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><blockquote>
<p>也就是读锁，或者是S锁，就是可以让大家读取，查看，就是不能修改</p>
</blockquote>
<h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><blockquote>
<p>也就是霸占一把锁，只要这个线程占着，别人就不能去获取这个锁，但是只要霸占这个锁，能读能写</p>
</blockquote>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote>
<p>资源抢占矛盾循环了，无外力介入，是解不开的</p>
</blockquote>
<h3 id="关于jvm自己内部的几个锁"><a href="#关于jvm自己内部的几个锁" class="headerlink" title="关于jvm自己内部的几个锁"></a>关于jvm自己内部的几个锁</h3><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote>
<p>就是如果哪个线程一直用着这个锁，就一直让他先用，更少的消耗量</p>
</blockquote>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote>
<p>如果其他锁妄图获得人家那个偏向锁，那就自旋吧，等人家用完才给你</p>
</blockquote>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><blockquote>
<p>自选锁也不自旋了，直接阻塞进化成重量级锁，重量级锁会让其他申请的线程进⼊阻塞，性能也会降低</p>
</blockquote>
<h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String locka = <span class="string">"A"</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String lockb = <span class="string">"B"</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"entre the locka"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line">                System.out.println(<span class="string">"a 取 b"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"entre the lockb"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line">                System.out.println(<span class="string">"b 取 a"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">          System.out.println(i+<span class="number">1</span> + <span class="string">"次"</span>);</span><br><span class="line">          <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">              DeadLock.LockA();</span><br><span class="line">          &#125;).start();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">              DeadLock.LockB();</span><br><span class="line">          &#125;).start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解锁代码"><a href="#解锁代码" class="headerlink" title="解锁代码"></a>解锁代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String locka = <span class="string">"A"</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String lockb = <span class="string">"B"</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"entre the locka"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line">                System.out.println(<span class="string">"a 取 b"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line">            System.out.println(<span class="string">"entre the lockb"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line">            System.out.println(<span class="string">"b 取 a"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(i+<span class="number">1</span> + <span class="string">"次"</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                DeadLock.LockA();</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                DeadLock.LockB();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>改变运行策略，其实是线程A中syc获取了锁a，还要获取suob，这样子顺序执行下来是ok 的，就怕线程a获取了锁a后，线程b抢占获取了锁b，此使线程a还要锁b<br>就阻塞了，所以到了线程b又要获取锁a，那么就死锁了<br>解决方法也简单，就是让一个锁提早消失就好了，所以改变一下sychronize的次序，提早释放锁，就万事大吉了</p>
</blockquote>
<h3 id="死锁的四个条件"><a href="#死锁的四个条件" class="headerlink" title="死锁的四个条件"></a>死锁的四个条件</h3><blockquote>
<p>互斥条件：资源不能共享，只能由⼀个线程使⽤<br>请求与保持条件：线程已经获得⼀些资源，但因请求其他资源发⽣阻塞，对已经获得的资源保持不释放<br>不可抢占：有些资源是不可强占的，当某个线程获得这个资源后，系统不能强⾏回收，只能由线程使⽤完⾃⼰释放<br>循环等待条件：多个线程形成环形链，每个都占⽤对⽅申请的下个资源</p>
</blockquote>
<h2 id="重入锁和不可重入锁"><a href="#重入锁和不可重入锁" class="headerlink" title="重入锁和不可重入锁"></a>重入锁和不可重入锁</h2><h3 id="不可重入锁-1"><a href="#不可重入锁-1" class="headerlink" title="不可重入锁"></a>不可重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BcrLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">boolean</span> flag = <span class="keyword">false</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"进入加锁"</span>);</span><br><span class="line">            flag = <span class="keyword">true</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"进入等待状态"</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"进入解锁"</span>);</span><br><span class="line">        notify();</span><br><span class="line">        flag = <span class="keyword">false</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.Messaging.SYNC_WITH_TRANSPORT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BcrLock bcrLock = <span class="keyword">new</span> BcrLock() ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bcrLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法A加锁"</span> + bcrLock.flag);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bcrLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bcrLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法B加锁"</span> + bcrLock.flag);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bcrLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> TestMain().methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重入锁-1"><a href="#重入锁-1" class="headerlink" title="重入锁"></a>重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.ir.Block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> islock = <span class="keyword">false</span> ;</span><br><span class="line">    <span class="keyword">public</span> String currentThread = <span class="keyword">null</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentThread==<span class="keyword">null</span>) &#123;</span><br><span class="line">            currentThread = Thread.currentThread().getName();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentThread.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"成功加锁"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!currentThread.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"加锁失败"</span>);</span><br><span class="line">                    wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        notify();</span><br><span class="line">        currentThread = <span class="keyword">null</span> ;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"成功解锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.awt.windows.ThemeReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMainB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CrLock crLock = <span class="keyword">new</span> CrLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            crLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法A加锁"</span> + crLock.currentThread);</span><br><span class="line">            methodB();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法a解锁"</span> );</span><br><span class="line">            crLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            crLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法B加锁"</span>+ crLock.currentThread );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法b解锁"</span> );</span><br><span class="line">            crLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">new</span> TestMainB().methodA();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">new</span> TestMainB().methodA();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronized说说看"><a href="#synchronized说说看" class="headerlink" title="synchronized说说看"></a>synchronized说说看</h2><blockquote>
<p>非公平锁，原子性，可重入可以修饰代码块和方法<br>每个对象有⼀个锁和⼀个等待队列，锁只能被⼀个线程持有，其他需要锁的线程需要阻塞等待。锁被释放<br>后，对象会从队列中取出⼀个并唤醒，唤醒哪个线程是不确定的，不保证公平性<br>jdk6优化-&gt; 偏向锁-&gt;轻量级锁-&gt;重量级锁</p>
</blockquote>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h3><blockquote>
<p>CAS是一种乐观锁，CompareAndSwap，也就是比较再交换<br>执行过程大概如下： 首先是 内存地址V，预期原值A，新值B ， 如果线程A过来，V = A ,则满足条件把目标值更换成B，如果线程B过来，V ！= A，那么无法<br>将目标值更换成B，而且线程B将进行自旋，直到 A=V ，结束自旋，获取锁<br>缺点也将显而易见： 自旋锁的存在直接导致了cpu的消耗问题</p>
</blockquote>
<h3 id="ABA-问题由于CAS不保证原子性问题"><a href="#ABA-问题由于CAS不保证原子性问题" class="headerlink" title="ABA 问题由于CAS不保证原子性问题"></a>ABA 问题由于CAS不保证原子性问题</h3><blockquote>
<p>简单来说就是线程在操作过程中，有其它线程将该变量更改后，又有另一个线程把他改回来，到最开始线程操作的时候，发现该值没有变化，则该线程操作成<br>功。加一个版本号可以解决问题，每次修改时都要查看版本号</p>
</blockquote>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><blockquote>
<p>就是 java.util.concurrent (juc) 的一个工具包 全称是 AbstractQueuedSynchronizer  （抽象同步队列）<br>其中核心就是 一个int变量（用于表示同步状态），一个state（计数器），一个线程标记（谁加锁），一个阻塞队列（用于存储未拿到锁阻塞中的线程）</p>
</blockquote>
<h3 id="部分核心方法"><a href="#部分核心方法" class="headerlink" title="部分核心方法"></a>部分核心方法</h3><h3 id="acquire-int-arg-源码讲解，好⽐加锁lock操作"><a href="#acquire-int-arg-源码讲解，好⽐加锁lock操作" class="headerlink" title="acquire(int arg) 源码讲解，好⽐加锁lock操作"></a>acquire(int arg) 源码讲解，好⽐加锁lock操作</h3><ol>
<li>tryAcquire()尝试直接去获取资源，如果成功则直接返回,AQS⾥⾯未实现但没有定义成<br>abstract，因为独占模式下只⽤实现tryAcquire-tryRelease，⽽共享模式下只⽤实现<br>tryAcquireShared-tryReleaseShared，类似设计模式⾥⾯的适配器模式</li>
<li>addWaiter() 根据不同模式将线程加⼊等待队列的尾部，有Node.EXCLUSIVE互斥模式、<br>Node.SHARED共享模式；如果队列不为空，则以通过compareAndSetTail⽅法以CAS将当前线程<br>节点加⼊到等待队列的末尾。否则通过enq(node)⽅法初始化⼀个等待队列</li>
<li>acquireQueued()使线程在等待队列中获取资源，⼀直获取到资源后才返回,如果在等待过程<br>中被中断，则返回true，否则返回false<h3 id="release-int-arg-源码讲解-好⽐解锁unlock"><a href="#release-int-arg-源码讲解-好⽐解锁unlock" class="headerlink" title="release(int arg)源码讲解 好⽐解锁unlock"></a>release(int arg)源码讲解 好⽐解锁unlock</h3>独占模式下线程释放指定量的资源，⾥⾯是根据tryRelease()的返回值来判断该线程是<br>否已经完成释放掉资源了；在⾃义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回<br>true，否则返回false<br>unparkSuccessor⽅法⽤于唤醒等待队列中下⼀个线程</li>
</ol>
<h2 id="ReentrantLock实现原理"><a href="#ReentrantLock实现原理" class="headerlink" title="ReentrantLock实现原理"></a>ReentrantLock实现原理</h2><blockquote>
<p>实现大致的思路是和AQS是一致的，ReentrantLock的实现是分为公平锁和非公平锁的，其中上层Lock（Accquire），Unlock（Release）上层一致，唯独在释放的时候有一点区别，公平锁的实现是直接去队列中去找，看看队列中是否有等待，如果有等待的话则排队，无等待的话就直接给锁，对应的方法也就是TryAccquire（） ，而非公平锁则直接判断是不是符合获取锁的条件CompareAndState，如果符合直接给锁，如果不符合，则是按照公平锁的方法处理</p>
</blockquote>
<h2 id="ReentrantLock和synchronized区别是什么？"><a href="#ReentrantLock和synchronized区别是什么？" class="headerlink" title="ReentrantLock和synchronized区别是什么？"></a>ReentrantLock和synchronized区别是什么？</h2><ol>
<li>ReentrantLock和synchronized都是独占锁</li>
<li>synchronized：<blockquote>
<p>· 是悲观锁会引起其他线程阻塞，java内置关键字，<br>· ⽆法判断是否获取锁的状态，锁可重⼊、不可中断、只能是⾮公平<br>· 加锁解锁的过程是隐式的,⽤户不⽤⼿动操作,优点是操作简单但显得不够灵活<br>· ⼀般并发场景使⽤⾜够、可以放在被递归执⾏的⽅法上,且不⽤担⼼线程最后能否正确<br>释放锁<br>· synchronized操作的应该是对象头中mark word，参考原先原理图⽚</p>
</blockquote>
</li>
<li>ReentrantLock：<blockquote>
<p>· 是个Lock接⼝的实现类，是悲观锁，<br>· 可以判断是否获取到锁，可重⼊、可判断、可公平可不公平<br>· 需要⼿动加锁和解锁,且解锁的操作尽量要放在finally代码块中,保证线程正确释放锁<br>· 在复杂的并发场景中使⽤在重⼊时要却确保重复获取锁的次数必须和重复释放锁的次数⼀样，否则可能导致 其他线程⽆法获得该锁。<br>· 创建的时候通过传进参数true创建公平锁,如果传⼊的是false或没传参数则创建的是⾮公平锁<br>· 底层不同是AQS的state和FIFO队列来控制加锁</p>
</blockquote>
</li>
</ol>
<h2 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock 读写锁"></a>ReentrantReadWriteLock 读写锁</h2><blockquote>
<p>读写锁其实就是一个分离的ReentrantLock,由于ReentrantLock无论读或者写都是加锁的，但是读其实是安全的，盲目加锁只能过多的消耗资源，所以应该<br>只有写是独占锁，写则是排他锁，这样子才可以优化资源，流程一般是获取写锁，获取读锁，释放写锁，释放读锁。<br>虽然也是重入锁，但是写可以重入读或者写，但是读就只能重入读</p>
</blockquote>
<h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h2><blockquote>
<p>j.u.c包下的提供了线程安全的队列访问的接⼝，并发包下很多⾼级同步类的实现都是基于阻塞队列实现的<br>1、当阻塞队列进⾏插⼊数据时，如果队列已满，线程将会阻塞等待直到队列⾮满<br>2、从阻塞队列读数据时，如果队列为空，线程将会阻塞等待直到队列⾥⾯是⾮空的时候</p>
</blockquote>
<h3 id="ArrayBlockingQueue："><a href="#ArrayBlockingQueue：" class="headerlink" title="ArrayBlockingQueue："></a>ArrayBlockingQueue：</h3><blockquote>
<p>基于数组实现的⼀个阻塞队列，需要指定容量⼤⼩，FIFO先进先出顺序</p>
</blockquote>
<h3 id="LinkedBlockingQueue："><a href="#LinkedBlockingQueue：" class="headerlink" title="LinkedBlockingQueue："></a>LinkedBlockingQueue：</h3><blockquote>
<p>基于链表实现的⼀个阻塞队列，如果不指定容量⼤⼩，默认Integer.MAX_VALUE, FIFO先进先出顺序</p>
</blockquote>
<h3 id="PriorityBlockingQueue："><a href="#PriorityBlockingQueue：" class="headerlink" title="PriorityBlockingQueue："></a>PriorityBlockingQueue：</h3><blockquote>
<p>⼀个⽀持优先级的⽆界阻塞队列，默认情况下元素采⽤⾃然顺序升序排序，也可以⾃定义排序实现 java.lang.Comparable接⼝</p>
</blockquote>
<h3 id="DelayQueue："><a href="#DelayQueue：" class="headerlink" title="DelayQueue："></a>DelayQueue：</h3><blockquote>
<p>延迟队列，在指定时间才能获取队列元素的功能，队列头元素是最接近过期的元素，⾥⾯的对象必须实现 java.util.concurrent.Delayed 接⼝并实现<br>CompareTo和getDelay⽅法</p>
</blockquote>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><blockquote>
<p>并发队列ConcurrentLinkedQueue是基于链表实现的⽆界线程安全队列，采⽤FIFO进⾏排序<br>保证线程安全的三要素：原⼦、有序、可⻅性<br>1、底层结构是Node，链表头部和尾部节点是head和tail，使⽤节点变量和内部类属性使⽤<br>volatile声明保证了有序和可⻅性<br>2、插⼊、移除、更新操作使⽤CAS⽆锁操作，保证了原⼦性</p>
</blockquote>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote>
<p>提⾼系统资源的使⽤率，同时避免过多资源竞争，避免堵塞，且可以定时定期执⾏、单线程、并发数控制，配置任务过多任务后的拒绝策略等功能</p>
</blockquote>
<h3 id="线程池分类"><a href="#线程池分类" class="headerlink" title="线程池分类"></a>线程池分类</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><blockquote>
<p>⼀个定⻓线程池，可控制线程最⼤并发数</p>
</blockquote>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><blockquote>
<p>⼀个可缓存线程池</p>
</blockquote>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><blockquote>
<p>⼀个单线程化的线程池，⽤唯⼀的⼯作线程来执⾏任务</p>
</blockquote>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><blockquote>
<p>⼀个定⻓线程池，⽀持定时/周期性任务执⾏</p>
</blockquote>
<h3 id="线程池踩坑"><a href="#线程池踩坑" class="headerlink" title="线程池踩坑"></a>线程池踩坑</h3><h4 id="推荐ThreadPoolExecutor的⽅式原因"><a href="#推荐ThreadPoolExecutor的⽅式原因" class="headerlink" title="推荐ThreadPoolExecutor的⽅式原因"></a>推荐ThreadPoolExecutor的⽅式原因</h4><ol>
<li>newFixedThreadPool和newSingleThreadExecutor:<blockquote>
<p>队列使⽤LinkedBlockingQueue，队列⻓度为 Integer.MAX_VALUE，可能造成堆积，导致OOM</p>
</blockquote>
</li>
<li>newScheduledThreadPool和newCachedThreadPool:         <blockquote>
<p>线程池⾥⾯允许最⼤的线程数是Integer.MAX_VALUE，可能会创建过多线程，导致OOM</p>
</blockquote>
<h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><h4 id="corePoolSize："><a href="#corePoolSize：" class="headerlink" title="corePoolSize："></a>corePoolSize：</h4><blockquote>
<p>核⼼线程数，线程池也会维护线程的最少数量，默认情况下核⼼线程会⼀直存活，即使没有任务也不会受存keepAliveTime控制<br>坑：在刚创建线程池时线程不会⽴即启动，到有任务提交时才开始创建线程并逐步线程数⽬达到corePoolSize</p>
</blockquote>
<h4 id="maximumPoolSize："><a href="#maximumPoolSize：" class="headerlink" title="maximumPoolSize："></a>maximumPoolSize：</h4><blockquote>
<p>线程池维护线程的最⼤数量，超过将被阻塞<br>坑：当核⼼线程满，且阻塞队列也满时，才会判断当前线程数是否⼩于最⼤线程数，才决定是否创建新线程</p>
</blockquote>
<h4 id="keepAliveTime："><a href="#keepAliveTime：" class="headerlink" title="keepAliveTime："></a>keepAliveTime：</h4><blockquote>
<p>⾮核⼼线程的闲置超时时间，超过这个时间就会被回收，直到线程数量等于corePoolSize</p>
</blockquote>
<h4 id="unit："><a href="#unit：" class="headerlink" title="unit："></a>unit：</h4><blockquote>
<p>指定keepAliveTime的单位，如TimeUnit.SECONDS、TimeUnit.MILLISECONDS</p>
</blockquote>
<h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue:"></a>workQueue:</h4><blockquote>
<p>线程池中的任务队列,常⽤的是 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue</p>
</blockquote>
<h4 id="threadFactory："><a href="#threadFactory：" class="headerlink" title="threadFactory："></a>threadFactory：</h4><blockquote>
<p>创建新线程时使⽤的⼯⼚</p>
</blockquote>
<h4 id="handler"><a href="#handler" class="headerlink" title="handler:"></a>handler:</h4><blockquote>
<p>RejectedExecutionHandler是⼀个接⼝且只有⼀个⽅法,线程池中的数量⼤于maximumPoolSize，对拒绝任务的处理策略，默认有4种策略AbortPolicy、<br>CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy</p>
</blockquote>
</li>
</ol>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><a href="https://www.cnblogs.com/aspirant/p/8991010.html" target="_blank" rel="noopener">博文地址</a></p>
</the>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://runindark.com/2020/03/09/我为阿里/" data-id="ck90r8z58001ip0v1h8qz54uj" class="article-share-link">Share</a>
      
    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/03/10/我为阿里-mysql/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            《天净沙·我·mysql篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？
          
        </div>
      </a>
    
    
      <a href="/2020/03/05/我为阿里-Java集合/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">《天净沙·我·Java集合》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 Cat&#39;s blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>

<aside class="sidebar sidebar-specter">
  
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Cat&#39;s blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

</body>
</html>