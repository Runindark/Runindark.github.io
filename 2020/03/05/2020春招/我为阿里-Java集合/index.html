<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    《天净沙·我·Java集合》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？ |
    
    Cat&#39;s blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  

<article id="post-2020春招/我为阿里-Java集合" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      《天净沙·我·Java集合》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2020/03/05/2020春招/我为阿里-Java集合/" class="article-date">
  <time datetime="2020-03-05T15:05:46.737Z" itemprop="datePublished">2020-03-05</time>
</a>
        
      </div>
    

    
      
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br>[文章都是搬运艿艿的]<br>[<a href="http://svip.iocoder.cn/Java/Core/Interview/]" target="_blank" rel="noopener">http://svip.iocoder.cn/Java/Core/Interview/]</a></excerpt></p>
<a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">

<h3 id="Java集合概述图"><a href="#Java集合概述图" class="headerlink" title="Java集合概述图"></a>Java集合概述图</h3><p><a href="https://upload-images.jianshu.io/upload_images/1637925-3ef7a86d5856e763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/747/format/jpeg" target="_blank" rel="noopener">概述图</a></p>
<h3 id="说出一些集合框架的优点？"><a href="#说出一些集合框架的优点？" class="headerlink" title="说出一些集合框架的优点？"></a>说出一些集合框架的优点？</h3><ol>
<li>使用核心集合类降低开发成本，而非实现我们自己的集合类。</li>
<li>随着使用经过严格测试的集合框架类，代码质量会得到提高。</li>
<li>通过使用 JDK 附带的集合类，可以降低代码维护成本。</li>
<li>复用性和可操作性。<h3 id="集合框架中的泛型有什么优点？"><a href="#集合框架中的泛型有什么优点？" class="headerlink" title="集合框架中的泛型有什么优点？"></a>集合框架中的泛型有什么优点？</h3><blockquote>
<p>Java5 引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型。因此，如果你添加其它类型的任何元素，它会在<br>编译时报错。这避免了在运行时出现 ClassCastException，因为你将会在编译时得到报错信息。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>泛型也使得代码整洁，我们不需要使用显式转换和 instanceOf 操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令</p>
</blockquote>
<h3 id="Java-集合框架的基础接口有哪些？"><a href="#Java-集合框架的基础接口有哪些？" class="headerlink" title="Java 集合框架的基础接口有哪些？"></a>Java 集合框架的基础接口有哪些？</h3><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><blockquote>
<p>为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java 平台不提供这个接口任何直接的实现。</p>
</blockquote>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><blockquote>
<p>是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List 更像长度动态变换的数组。</p>
</blockquote>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><blockquote>
<p>是一个将 key 映射到 value 的对象。一个 Map 不能包含重复的 key，每个 key 最多只能映射一个 value 。</p>
</blockquote>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>一些其它的接口有 Queue、Dequeue、SortedSet、SortedMap 和 ListIterator 。</p>
<h3 id="为何-Collection-不从-Cloneable-和-Serializable-接口继承？"><a href="#为何-Collection-不从-Cloneable-和-Serializable-接口继承？" class="headerlink" title="为何 Collection 不从 Cloneable 和 Serializable 接口继承？"></a>为何 Collection 不从 Cloneable 和 Serializable 接口继承？</h3><blockquote>
<p>Collection 接口指定一组对象，对象即为它的元素<br>如何维护这些元素由 Collection 的具体实现决定。例如，一些如 List 的 Collection 实现允许重复的元素，而其它的如 Set 就不允许。<br>很多 Collection 实现有一个公有的 clone 方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为 Collection 是一个抽象表现，重要的是实现。</p>
</blockquote>
<h3 id="为何-Map-接口不继承-Collection-接口？"><a href="#为何-Map-接口不继承-Collection-接口？" class="headerlink" title="为何 Map 接口不继承 Collection 接口？"></a>为何 Map 接口不继承 Collection 接口？</h3><blockquote>
<p>尽管 Map 接口和它的实现也是集合框架的一部分，但 Map 不是集合，集合也不是 Map。因此，Map 继承 Collection 毫无意义，反之亦然。<br>如果 Map 继承 Collection 接口，那么元素去哪儿？Map 包含 key-value 对，它提供抽取 key 或 value 列表集合( Collection )的方法，但是它不适合<br>“一组对象”规范。</p>
</blockquote>
<h3 id="Collection-和-Collections-的区别？"><a href="#Collection-和-Collections-的区别？" class="headerlink" title="Collection 和 Collections 的区别？"></a>Collection 和 Collections 的区别？</h3><blockquote>
<p>Collection ，是集合类的上级接口，继承与他的接口主要有 Set 和List 。<br>Collections ，是针对集合类的一个工具类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
</blockquote>
<h3 id="集合框架里实现的通用算法有哪些？"><a href="#集合框架里实现的通用算法有哪些？" class="headerlink" title="集合框架里实现的通用算法有哪些？"></a>集合框架里实现的通用算法有哪些？</h3><blockquote>
<p>Java 集合框架提供常用的算法实现，比如排序和搜索。<br>Collections类包含这些方法实现。大部分算法是操作 List 的，但一部分对所有类型的集合都是可用的。部分算法有排序、搜索、混编、最大最小值。</p>
</blockquote>
<h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><h3 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h3><blockquote>
<ol>
<li>ArrayList ：Object 数组。</li>
<li>Vector ：Object 数组。</li>
<li>LinkedList ：双向链表(JDK6 之前为循环链表，JDK7 取消了循环)。</li>
</ol>
</blockquote>
<h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><blockquote>
<ol>
<li>HashMap ：<br>JDK8 之前，HashMap 由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。<br>JDK8 以后，在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）时，将链表转化为红黑树，以减少搜索时间。</li>
<li>LinkedHashMap ：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上<br>面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查<br>看：《LinkedHashMap 源码详细分析（JDK1.8）》 。</li>
<li>Hashtable ：数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</li>
<li>TreeMap ：红黑树（自平衡的排序二叉树）。</li>
</ol>
</blockquote>
<h3 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h3><p>HashSet ：无序，唯一，基于 HashMap 实现的，底层采用 HashMap 来保存元素。<br>LinkedHashSet ：LinkedHashSet 继承自 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。<br>TreeSet ：有序，唯一，红黑树(自平衡的排序二叉树)。</p>
<h3 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h3><blockquote>
<p>Iterator 接口，提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元<br>素，但是不可以直接调用集合的 #remove(Object Obj) 方法删除，可以通过迭代器的 #remove() 方法删除。</p>
</blockquote>
<h4 id="Iterator-和-ListIterator-的区别是什么？"><a href="#Iterator-和-ListIterator-的区别是什么？" class="headerlink" title="Iterator 和 ListIterator 的区别是什么？"></a>Iterator 和 ListIterator 的区别是什么？</h4><blockquote>
<p>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。<br>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能。比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。</p>
</blockquote>
<h4 id="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"><a href="#快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？" class="headerlink" title="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"></a>快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？</h4><blockquote>
<p>差别在于 ConcurrentModification 异常：<br>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 java.util 包下的都是快速失败。<br>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。在 java.util.concurrent 包下的全是安全失败的。</p>
</blockquote>
<h4 id="如何删除-List-中的某个元素？"><a href="#如何删除-List-中的某个元素？" class="headerlink" title="如何删除 List 中的某个元素？"></a>如何删除 List 中的某个元素？</h4><blockquote>
<p>方式一，使用 Iterator ，顺序向下，如果找到元素，则使用 remove 方法进行移除。<br>方式二，倒序遍历 List ，如果找到元素，则使用 remove 方法进行移除。</p>
</blockquote>
<h4 id="Enumeration-和-Iterator-接口有什么不同？"><a href="#Enumeration-和-Iterator-接口有什么不同？" class="headerlink" title="Enumeration 和 Iterator 接口有什么不同？"></a>Enumeration 和 Iterator 接口有什么不同？</h4><blockquote>
<p>Enumeration 跟 Iterator 相比较快两倍，而且占用更少的内存。<br>但是，Iterator 相对于 Enumeration 更安全，因为其他线程不能修改当前迭代器遍历的集合对象。同时，Iterators 允许调用者从底层集合中移除元素，这些 Enumerations 都没法完成。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationTester</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">      Enumeration&lt;String&gt; days;</span><br><span class="line">      Vector&lt;String&gt; dayNames = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">      dayNames.add(<span class="string">"Sunday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Monday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Tuesday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Wednesday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Thursday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Friday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Saturday"</span>);</span><br><span class="line">      days = dayNames.elements();</span><br><span class="line">      <span class="keyword">while</span> (days.hasMoreElements())&#123;</span><br><span class="line">         System.out.println(days.nextElement()); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为何-Iterator-接口没有具体的实现？"><a href="#为何-Iterator-接口没有具体的实现？" class="headerlink" title="为何 Iterator 接口没有具体的实现？"></a>为何 Iterator 接口没有具体的实现？</h4><blockquote>
<p>Iterator 接口，定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的 Iterator 的集合类都有它自己的 Iterator 实现内部类。<br>这就允许集合类去选择迭代器是 fail-fast 还是 fail-safe 的。比如，ArrayList 迭代器是 fail-fast 的，而 CopyOnWriteArrayList 迭代器是 fail-safe 的。</p>
</blockquote>
<h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别?"></a>Comparable 和 Comparator 的区别?</h3><blockquote>
<p>Comparable 接口，在 java.lang 包下，用于当前对象和其它对象的比较，所以它有一个 #compareTo(Object obj) 方法用来排序，该方法只有一个参数。<br>Comparator 接口，在 java.util 包下，用于传入的两个对象的比较，所以它有一个 #compare(Object obj1, Object obj2) 方法用来排序，该方法有两个参数。</p>
</blockquote>
<h4 id="compareTo-方法的返回值表示的意思？"><a href="#compareTo-方法的返回值表示的意思？" class="headerlink" title="compareTo 方法的返回值表示的意思？"></a>compareTo 方法的返回值表示的意思？</h4><blockquote>
<p>· 大于 0 ，表示对象大于参数对象。<br>· 小于 0 ，表示对象小于参数对象<br>· 等于 0 ，表示两者相等。</p>
</blockquote>
<h4 id="如何对-Object-的-List-排序？"><a href="#如何对-Object-的-List-排序？" class="headerlink" title="如何对 Object 的 List 排序？"></a>如何对 Object 的 List 排序？</h4><blockquote>
<p>对 Object[] 数组进行排序时，我们可以用 Arrays#sort(…) 方法。<br>对 List<object> 数组进行排序时，我们可以用 Collections#sort(…) 方法。</object></p>
</blockquote>
<h3 id="List-VS-Set"><a href="#List-VS-Set" class="headerlink" title="List VS Set"></a>List VS Set</h3><h4 id="List-和-Set-区别？"><a href="#List-和-Set-区别？" class="headerlink" title="List 和 Set 区别？"></a>List 和 Set 区别？</h4><blockquote>
<p>List，Set 都是继承自 Collection 接口。<br>· List 特点：元素有放入顺序，元素可重复。<br>· Set 特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉。</p>
</blockquote>
<blockquote>
<p>注意：元素虽然无放入顺序，但是元素在 Set 中的位置是有该元素的 hashcode 决定的，其位置其实是固定的。<br>另外 List 支持 for 循环，也就是通过下标来遍历，也可以用迭代器，但是 Set 只能用迭代，因为他无序，无法用下标来取得想要的值。</p>
</blockquote>
<h4 id="Set-和-List-对比："><a href="#Set-和-List-对比：" class="headerlink" title="Set 和 List 对比："></a>Set 和 List 对比：</h4><blockquote>
<p>Set：检索指定的元素效率高，删除和插入效率高，插入和删除可能会引起元素位置改变。<br>List：和数组类似，List 可以动态增长，查找指定的元素效率低，插入删除指定的元素效率低，因为可能会引起其他元素位置改变。</p>
</blockquote>
<h3 id="Array系-VS-List系"><a href="#Array系-VS-List系" class="headerlink" title="Array系 VS List系"></a>Array系 VS List系</h3><h4 id="Array-和-ArrayList-有何区别？什么时候更适合用-Array？"><a href="#Array-和-ArrayList-有何区别？什么时候更适合用-Array？" class="headerlink" title="Array 和 ArrayList 有何区别？什么时候更适合用 Array？"></a>Array 和 ArrayList 有何区别？什么时候更适合用 Array？</h4><blockquote>
<p>Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。<br>Array 是指定大小的，而 ArrayList 大小是固定的，可自动扩容。<br>Array 没有提供 ArrayList 那么多功能，比如 addAll、removeAll 和 iterator 等。<br>尽管 ArrayList 明显是更好的选择，但也有些时候 Array 比较好用，比如下面的三种情况。</p>
</blockquote>
<blockquote>
<p>1、如果列表的大小已经指定，大部分情况下是存储和遍历它们<br>2、对于遍历基本数据类型，尽管 Collections 使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。<br>3、如果你要使用多维数组，使用 [][] 比 List 会方便。</p>
</blockquote>
<h4 id="ArrayList-与-LinkedList-区别？"><a href="#ArrayList-与-LinkedList-区别？" class="headerlink" title="ArrayList 与 LinkedList 区别？"></a>ArrayList 与 LinkedList 区别？</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><blockquote>
<p>优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。<br>缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</p>
</blockquote>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><blockquote>
<p>优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作 add 和 remove ，LinedList 比较占优势。LinkedList 适用于要头尾操<br>作或插入指定位置的场景。<br>缺点：因为 LinkedList 要移动指针，所以查询操作性能比较低。</p>
</blockquote>
<h5 id="适用场景分析："><a href="#适用场景分析：" class="headerlink" title="适用场景分析："></a>适用场景分析：</h5><blockquote>
<p>当需要对数据进行对随机访问的情况下，选用 ArrayList 。<br>当需要对数据进行多次增加删除修改时，采用 LinkedList 。</p>
</blockquote>
<h4 id="ArrayList-是如何扩容的？"><a href="#ArrayList-是如何扩容的？" class="headerlink" title="ArrayList 是如何扩容的？"></a>ArrayList 是如何扩容的？</h4><blockquote>
<p>如果通过无参构造的话，初始数组容量为 0 ，当真正对数组进行添加时，才真正分配容量。每次按照 1.5 倍（位运算）的比率通过 copeOf 的方式扩容。<br>在 JKD6 中实现是，如果通过无参构造的话，初始数组容量为10，每次通过 copeOf 的方式扩容后容量为原来的 1.5 倍。</p>
</blockquote>
<h4 id="ArrayList-与-Vector-区别？"><a href="#ArrayList-与-Vector-区别？" class="headerlink" title="ArrayList 与 Vector 区别？"></a>ArrayList 与 Vector 区别？</h4><p>rrayList 和 Vector 都是用数组实现的，主要有这么三个区别：</p>
<blockquote>
<ol>
<li>Vector 是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果，而 ArrayList 不是。这个可以从源码中看出，Vector 类中的方法很多有 synchronized 进行修饰，这样就导致<br>了 Vector 在效率上无法与 ArrayList 相比。</li>
<li>两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。</li>
<li>Vector 可以设置增长因子，而 ArrayList 不可以</li>
</ol>
</blockquote>
<blockquote>
<p>Vector 是线程同步的，所以它也是线程安全的，而 ArrayList 是线程无需同步的，是不安全的。如果不考虑到线程的安全因素，一般用 ArrayList 效率比较高。<br>实际场景下，如果需要多线程访问安全的数组，使用 CopyOnWriteArrayList 。<br>如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用 Vector 有一定的优势。</p>
</blockquote>
<h3 id="HashMap-和-Hashtable-的区别？"><a href="#HashMap-和-Hashtable-的区别？" class="headerlink" title="HashMap 和 Hashtable 的区别？"></a>HashMap 和 Hashtable 的区别？</h3><blockquote>
<ol>
<li>Hashtable 是在 Java 1.0 的时候创建的，而集合的统一规范命名是在后来的 Java2.0 开始约定的，而当时其他一部分集合类的发布构成了新的集合框架。<br>Hashtable 继承 Dictionary ，HashMap 继承的是 Java2 出现的 Map 接口。</li>
<li>HashMap 去掉了 Hashtable 的 contains 方法，但是加上了 containsValue 和 containsKey 方法。</li>
<li>HashMap 允许空键值，而 Hashtable 不允许。<br>【重点】4. HashTable 是同步的，而 HashMap 是非同步的，效率上比 HashTable 要高。也因此，HashMap 更适合于单线程环境，而 HashTable 适合于多线程环境。</li>
<li>HashMap 的迭代器（Iterator）是 fail-fast 迭代器，HashTable的 enumerator 迭代器不是 fail-fast 的。</li>
<li>HashTable 中数组默认大小是 11 ，扩容方法是 old * 2 + 1 ，HashMap 默认大小是 16 ，扩容每次为 2 的指数大小。<br>即使在多线程环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用 Hashtable </li>
</ol>
</blockquote>
<h3 id="HashSet-和-HashMap-的区别？"><a href="#HashSet-和-HashMap-的区别？" class="headerlink" title="HashSet 和 HashMap 的区别？"></a>HashSet 和 HashMap 的区别？</h3><blockquote>
<p>Set 是线性结构，值不能重复。HashSet 是 Set 的 hash 实现，HashSet 中值不能重复是用 HashMap 的 key 来实现的。<br>Map 是键值对映射，可以空键空值。HashMap 是 Map 的 hash 实现，key 的唯一性是通过 key 值 hashcode 的唯一来确定，value 值是则是链表结构</p>
</blockquote>
<h3 id="HashSet-和-TreeSet-的区别？"><a href="#HashSet-和-TreeSet-的区别？" class="headerlink" title="HashSet 和 TreeSet 的区别？"></a>HashSet 和 TreeSet 的区别？</h3><blockquote>
<p>HashSet 是用一个 hash 表来实现的，因此，它的元素是无序的。添加，删除和 HashSet 包括的方法的持续时间复杂度是 O(1) 。<br>TreeSet 是用一个树形结构实现的，因此，它是有序的。添加，删除和 TreeSet 包含的方法的持续时间复杂度是 O(logn) 。</p>
</blockquote>
<h3 id="如何决定选用-HashMap-还是-TreeMap？"><a href="#如何决定选用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定选用 HashMap 还是 TreeMap？"></a>如何决定选用 HashMap 还是 TreeMap？</h3><blockquote>
<p>对于在 Map 中插入、删除和定位元素这类操作，HashMap 是最好的选择。<br>然而，假如你需要对一个有序的 key 集合进行遍历， TreeMap 是更好的选择。</p>
</blockquote>
<h3 id="HashMap-和-ConcurrentHashMap-的区别？"><a href="#HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别？"></a>HashMap 和 ConcurrentHashMap 的区别？</h3><p>ConcurrentHashMap 是线程安全的 HashMap 的实现。主要区别如下：</p>
<blockquote>
<p>1、ConcurrentHashMap 对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用 lock 锁进行保护，相对 于Hashtable 的 syn 关键字锁的粒度更精细了一些，并发性能更好。而 HashMap 没有<br>锁机制，不是线程安全的。<br>JDK8 之后，ConcurrentHashMap 启用了一种全新的方式实现,利用 CAS 算法。<br>2、HashMap 的键值对允许有 null ，但是 ConCurrentHashMap 都不允许。</p>
</blockquote>
<h3 id="HashMap-的工作原理是什么？"><a href="#HashMap-的工作原理是什么？" class="headerlink" title="HashMap 的工作原理是什么？"></a>HashMap 的工作原理是什么？</h3><p><a href="http://dl2.iteye.com/upload/attachment/0017/7479/3f05dd61-955e-3eb2-bf8e-31da8a361148.jpg" target="_blank" rel="noopener">HashMap</a></p>
<blockquote>
<p>我们知道在 Java 中最常用的两种结构是数组和模拟指针（引用），几乎所有的数据结构都可以利用这两种来组合实现，HashMap 也是如此。实际上 HashMap 是一个“链表散列”。<br>HashMap 是基于 hashing 的原理。</p>
</blockquote>
<h4 id="当两个对象的-hashCode-相同会发生什么？"><a href="#当两个对象的-hashCode-相同会发生什么？" class="headerlink" title="当两个对象的 hashCode 相同会发生什么？"></a>当两个对象的 hashCode 相同会发生什么？</h4><blockquote>
<p>因为 hashcode 相同，所以它们的 bucket 位置相同，“碰撞”会发生。<br>因为 HashMap 使用链表存储对象，这个 Entry（包含有键值对的 Map.Entry 对象）会存储在链表中。</p>
</blockquote>
<h4 id="HashMap-默认容量是多少？"><a href="#HashMap-默认容量是多少？" class="headerlink" title="HashMap 默认容量是多少？"></a>HashMap 默认容量是多少？</h4><blockquote>
<p>默认容量都是 16 ，负载因子是 0.75 。就是当 HashMap 填充了 75% 的 busket 是就会扩容，最小的可能性是（16 * 0.75 = 12），一般为原内存的 2 倍。</p>
</blockquote>
</the>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://runindark.com/2020/03/05/2020春招/我为阿里-Java集合/" data-id="ckbyeu161000a5sv1l0tta55n" class="article-share-link">Share</a>
      
    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/03/09/2020春招/我为阿里/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            《天净沙·我·并发编程篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？
          
        </div>
      </a>
    
    
      <a href="/2020/03/04/2020春招/我为阿里-Java基础/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">《天净沙·我·Java基础》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 Cat&#39;s blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>

<aside class="sidebar sidebar-specter">
  
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Cat&#39;s blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

</body>
</html>