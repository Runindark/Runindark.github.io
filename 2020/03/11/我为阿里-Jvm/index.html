<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>《天净沙·我·jvm篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？ | Cat's blog</title><meta name="description" content="《天净沙·我·jvm篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？"><meta name="keywords" content=""><meta name="author" content="夜小猫"><meta name="copyright" content="夜小猫"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://runindark.com/2020/03/11/我为阿里-Jvm/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="《天净沙·我·jvm篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？"><meta name="twitter:description" content="《天净沙·我·jvm篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="《天净沙·我·jvm篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？"><meta property="og:url" content="http://runindark.com/2020/03/11/我为阿里-Jvm/"><meta property="og:site_name" content="Cat's blog"><meta property="og:description" content="《天净沙·我·jvm篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="《天净沙·我·Spring》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？" href="http://runindark.com/2020/03/12/我为阿里-Spring/"><link rel="next" title="《天净沙·我·mysql篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？" href="http://runindark.com/2020/03/10/我为阿里-mysql/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  copyright: undefined,
  copy_copyright_js: false
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Cat's blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">52</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java的内存区域（运行时数据区）"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Java的内存区域（运行时数据区）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程共享区"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">线程共享区</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程私有区"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">线程私有区</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#直接内存"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">直接内存</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java1-8之后的变化"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">Java1.8之后的变化</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么每一个线程需要一个程序计数器"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">为什么每一个线程需要一个程序计数器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#程序计数器的作用"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">程序计数器的作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#为啥线程需要程序计数器？"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">为啥线程需要程序计数器？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java虚拟机栈"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">Java虚拟机栈</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java的两种返回方式"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">Java的两种返回方式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#本地方法栈"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">本地方法栈</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#本地方法栈是做什么的？"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">本地方法栈是做什么的？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#堆-（GC堆）"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">堆 （GC堆）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#堆的分类"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">堆的分类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#方法区"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">方法区</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#运行时常量池"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">运行时常量池</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#运行时常量池包含什么"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text">运行时常量池包含什么</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#字面量"><span class="toc_mobile_items-number">8.2.1.</span> <span class="toc_mobile_items-text">字面量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#符号引用"><span class="toc_mobile_items-number">8.2.2.</span> <span class="toc_mobile_items-text">符号引用</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java对象的创建过程"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">Java对象的创建过程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-类加载检查"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">1. 类加载检查</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-分配内存"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">2. 分配内存</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#指针碰撞"><span class="toc_mobile_items-number">9.2.1.</span> <span class="toc_mobile_items-text">指针碰撞</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#空闲列表"><span class="toc_mobile_items-number">9.2.2.</span> <span class="toc_mobile_items-text">空闲列表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#线程安全问题"><span class="toc_mobile_items-number">9.2.3.</span> <span class="toc_mobile_items-text">线程安全问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#CAS乐观解决"><span class="toc_mobile_items-number">9.2.3.1.</span> <span class="toc_mobile_items-text">CAS乐观解决</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#TLAB解决"><span class="toc_mobile_items-number">9.2.3.2.</span> <span class="toc_mobile_items-text">TLAB解决</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-初始化零值"><span class="toc_mobile_items-number">9.3.</span> <span class="toc_mobile_items-text">3. 初始化零值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-设置对象头"><span class="toc_mobile_items-number">9.4.</span> <span class="toc_mobile_items-text">4. 设置对象头</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-执行init（）方法"><span class="toc_mobile_items-number">9.5.</span> <span class="toc_mobile_items-text">5. 执行init（）方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#对象的访问方式"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">对象的访问方式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#优缺点分析"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text">优缺点分析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#对象的分配策略"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">对象的分配策略</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Minor-GC，-Full-GC的区别"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text">Minor GC， Full GC的区别</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#对象的死亡判断"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text">对象的死亡判断</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#程序计数器法"><span class="toc_mobile_items-number">12.1.</span> <span class="toc_mobile_items-text">程序计数器法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#可达性分析法"><span class="toc_mobile_items-number">12.2.</span> <span class="toc_mobile_items-text">可达性分析法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#补充：一般哪些可以作为GCRoot呢："><span class="toc_mobile_items-number">12.2.1.</span> <span class="toc_mobile_items-text">补充：一般哪些可以作为GCRoot呢：</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#引用"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text">引用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#强引用"><span class="toc_mobile_items-number">13.1.</span> <span class="toc_mobile_items-text">强引用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#软引用"><span class="toc_mobile_items-number">13.2.</span> <span class="toc_mobile_items-text">软引用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#弱引用"><span class="toc_mobile_items-number">13.3.</span> <span class="toc_mobile_items-text">弱引用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#虚引用"><span class="toc_mobile_items-number">13.4.</span> <span class="toc_mobile_items-text">虚引用</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#废弃常量的判定方法"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text">废弃常量的判定方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何判定一个类的废弃"><span class="toc_mobile_items-number">15.</span> <span class="toc_mobile_items-text">如何判定一个类的废弃</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#ClassLoader"><span class="toc_mobile_items-number">15.1.</span> <span class="toc_mobile_items-text">ClassLoader</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#java-lang-Class"><span class="toc_mobile_items-number">15.2.</span> <span class="toc_mobile_items-text">java.lang.Class</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#一个类废弃的判定方法"><span class="toc_mobile_items-number">15.3.</span> <span class="toc_mobile_items-text">一个类废弃的判定方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#垃圾回收机制的算法"><span class="toc_mobile_items-number">16.</span> <span class="toc_mobile_items-text">垃圾回收机制的算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#无脑清空法-–-标记清除算法"><span class="toc_mobile_items-number">16.1.</span> <span class="toc_mobile_items-text">无脑清空法 – 标记清除算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#复制填坑法-–-复制算法"><span class="toc_mobile_items-number">16.2.</span> <span class="toc_mobile_items-text">复制填坑法 – 复制算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#洁癖整理法-–-标记整理算法"><span class="toc_mobile_items-number">16.3.</span> <span class="toc_mobile_items-text">洁癖整理法 – 标记整理算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#分代收集算法"><span class="toc_mobile_items-number">16.4.</span> <span class="toc_mobile_items-text">分代收集算法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#垃圾收集器"><span class="toc_mobile_items-number">17.</span> <span class="toc_mobile_items-text">垃圾收集器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Serial-（年轻代）"><span class="toc_mobile_items-number">17.1.</span> <span class="toc_mobile_items-text">Serial （年轻代）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#ParNew-（年轻代）"><span class="toc_mobile_items-number">17.2.</span> <span class="toc_mobile_items-text">ParNew （年轻代）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Parallel-Scavenge-（年轻代）"><span class="toc_mobile_items-number">17.3.</span> <span class="toc_mobile_items-text">Parallel Scavenge （年轻代）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Serial-Old"><span class="toc_mobile_items-number">17.4.</span> <span class="toc_mobile_items-text">Serial Old</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Parallel-Old"><span class="toc_mobile_items-number">17.5.</span> <span class="toc_mobile_items-text">Parallel Old</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CMS-（老年代）"><span class="toc_mobile_items-number">17.6.</span> <span class="toc_mobile_items-text">CMS （老年代）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#过程"><span class="toc_mobile_items-number">17.6.1.</span> <span class="toc_mobile_items-text">过程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#初始标记"><span class="toc_mobile_items-number">17.6.1.1.</span> <span class="toc_mobile_items-text">初始标记</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#并发标记"><span class="toc_mobile_items-number">17.6.1.2.</span> <span class="toc_mobile_items-text">并发标记</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#重新标记"><span class="toc_mobile_items-number">17.6.1.3.</span> <span class="toc_mobile_items-text">重新标记</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#并发清除"><span class="toc_mobile_items-number">17.6.1.4.</span> <span class="toc_mobile_items-text">并发清除</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#G1"><span class="toc_mobile_items-number">17.7.</span> <span class="toc_mobile_items-text">G1</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#过程-1"><span class="toc_mobile_items-number">17.7.1.</span> <span class="toc_mobile_items-text">过程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#初始标记-1"><span class="toc_mobile_items-number">17.7.1.1.</span> <span class="toc_mobile_items-text">初始标记</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#并发标记-1"><span class="toc_mobile_items-number">17.7.1.2.</span> <span class="toc_mobile_items-text">并发标记</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#最终标记"><span class="toc_mobile_items-number">17.7.1.3.</span> <span class="toc_mobile_items-text">最终标记</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#筛选回收"><span class="toc_mobile_items-number">17.7.1.4.</span> <span class="toc_mobile_items-text">筛选回收</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Jvm类加载模式"><span class="toc_mobile_items-number">18.</span> <span class="toc_mobile_items-text">Jvm类加载模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#类加载器"><span class="toc_mobile_items-number">19.</span> <span class="toc_mobile_items-text">类加载器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#双亲委派模型"><span class="toc_mobile_items-number">19.1.</span> <span class="toc_mobile_items-text">双亲委派模型</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java的内存区域（运行时数据区）"><span class="toc-number">1.</span> <span class="toc-text">Java的内存区域（运行时数据区）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程共享区"><span class="toc-number">1.1.</span> <span class="toc-text">线程共享区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程私有区"><span class="toc-number">1.2.</span> <span class="toc-text">线程私有区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直接内存"><span class="toc-number">1.3.</span> <span class="toc-text">直接内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java1-8之后的变化"><span class="toc-number">1.4.</span> <span class="toc-text">Java1.8之后的变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么每一个线程需要一个程序计数器"><span class="toc-number">2.</span> <span class="toc-text">为什么每一个线程需要一个程序计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#程序计数器的作用"><span class="toc-number">2.1.</span> <span class="toc-text">程序计数器的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为啥线程需要程序计数器？"><span class="toc-number">2.2.</span> <span class="toc-text">为啥线程需要程序计数器？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java虚拟机栈"><span class="toc-number">3.</span> <span class="toc-text">Java虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java的两种返回方式"><span class="toc-number">3.1.</span> <span class="toc-text">Java的两种返回方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法栈"><span class="toc-number">4.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法栈是做什么的？"><span class="toc-number">5.</span> <span class="toc-text">本地方法栈是做什么的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆-（GC堆）"><span class="toc-number">6.</span> <span class="toc-text">堆 （GC堆）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆的分类"><span class="toc-number">7.</span> <span class="toc-text">堆的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区"><span class="toc-number">8.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时常量池"><span class="toc-number">8.1.</span> <span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时常量池包含什么"><span class="toc-number">8.2.</span> <span class="toc-text">运行时常量池包含什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字面量"><span class="toc-number">8.2.1.</span> <span class="toc-text">字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#符号引用"><span class="toc-number">8.2.2.</span> <span class="toc-text">符号引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java对象的创建过程"><span class="toc-number">9.</span> <span class="toc-text">Java对象的创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-类加载检查"><span class="toc-number">9.1.</span> <span class="toc-text">1. 类加载检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-分配内存"><span class="toc-number">9.2.</span> <span class="toc-text">2. 分配内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#指针碰撞"><span class="toc-number">9.2.1.</span> <span class="toc-text">指针碰撞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#空闲列表"><span class="toc-number">9.2.2.</span> <span class="toc-text">空闲列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程安全问题"><span class="toc-number">9.2.3.</span> <span class="toc-text">线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CAS乐观解决"><span class="toc-number">9.2.3.1.</span> <span class="toc-text">CAS乐观解决</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TLAB解决"><span class="toc-number">9.2.3.2.</span> <span class="toc-text">TLAB解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-初始化零值"><span class="toc-number">9.3.</span> <span class="toc-text">3. 初始化零值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-设置对象头"><span class="toc-number">9.4.</span> <span class="toc-text">4. 设置对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-执行init（）方法"><span class="toc-number">9.5.</span> <span class="toc-text">5. 执行init（）方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的访问方式"><span class="toc-number">10.</span> <span class="toc-text">对象的访问方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优缺点分析"><span class="toc-number">10.1.</span> <span class="toc-text">优缺点分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的分配策略"><span class="toc-number">11.</span> <span class="toc-text">对象的分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC，-Full-GC的区别"><span class="toc-number">11.1.</span> <span class="toc-text">Minor GC， Full GC的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的死亡判断"><span class="toc-number">12.</span> <span class="toc-text">对象的死亡判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#程序计数器法"><span class="toc-number">12.1.</span> <span class="toc-text">程序计数器法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可达性分析法"><span class="toc-number">12.2.</span> <span class="toc-text">可达性分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#补充：一般哪些可以作为GCRoot呢："><span class="toc-number">12.2.1.</span> <span class="toc-text">补充：一般哪些可以作为GCRoot呢：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用"><span class="toc-number">13.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#强引用"><span class="toc-number">13.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#软引用"><span class="toc-number">13.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#弱引用"><span class="toc-number">13.3.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚引用"><span class="toc-number">13.4.</span> <span class="toc-text">虚引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#废弃常量的判定方法"><span class="toc-number">14.</span> <span class="toc-text">废弃常量的判定方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何判定一个类的废弃"><span class="toc-number">15.</span> <span class="toc-text">如何判定一个类的废弃</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassLoader"><span class="toc-number">15.1.</span> <span class="toc-text">ClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-Class"><span class="toc-number">15.2.</span> <span class="toc-text">java.lang.Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个类废弃的判定方法"><span class="toc-number">15.3.</span> <span class="toc-text">一个类废弃的判定方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收机制的算法"><span class="toc-number">16.</span> <span class="toc-text">垃圾回收机制的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无脑清空法-–-标记清除算法"><span class="toc-number">16.1.</span> <span class="toc-text">无脑清空法 – 标记清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复制填坑法-–-复制算法"><span class="toc-number">16.2.</span> <span class="toc-text">复制填坑法 – 复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#洁癖整理法-–-标记整理算法"><span class="toc-number">16.3.</span> <span class="toc-text">洁癖整理法 – 标记整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分代收集算法"><span class="toc-number">16.4.</span> <span class="toc-text">分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾收集器"><span class="toc-number">17.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-（年轻代）"><span class="toc-number">17.1.</span> <span class="toc-text">Serial （年轻代）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew-（年轻代）"><span class="toc-number">17.2.</span> <span class="toc-text">ParNew （年轻代）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge-（年轻代）"><span class="toc-number">17.3.</span> <span class="toc-text">Parallel Scavenge （年轻代）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old"><span class="toc-number">17.4.</span> <span class="toc-text">Serial Old</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old"><span class="toc-number">17.5.</span> <span class="toc-text">Parallel Old</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS-（老年代）"><span class="toc-number">17.6.</span> <span class="toc-text">CMS （老年代）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#过程"><span class="toc-number">17.6.1.</span> <span class="toc-text">过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#初始标记"><span class="toc-number">17.6.1.1.</span> <span class="toc-text">初始标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#并发标记"><span class="toc-number">17.6.1.2.</span> <span class="toc-text">并发标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#重新标记"><span class="toc-number">17.6.1.3.</span> <span class="toc-text">重新标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#并发清除"><span class="toc-number">17.6.1.4.</span> <span class="toc-text">并发清除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1"><span class="toc-number">17.7.</span> <span class="toc-text">G1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#过程-1"><span class="toc-number">17.7.1.</span> <span class="toc-text">过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#初始标记-1"><span class="toc-number">17.7.1.1.</span> <span class="toc-text">初始标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#并发标记-1"><span class="toc-number">17.7.1.2.</span> <span class="toc-text">并发标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#最终标记"><span class="toc-number">17.7.1.3.</span> <span class="toc-text">最终标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#筛选回收"><span class="toc-number">17.7.1.4.</span> <span class="toc-text">筛选回收</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jvm类加载模式"><span class="toc-number">18.</span> <span class="toc-text">Jvm类加载模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器"><span class="toc-number">19.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委派模型"><span class="toc-number">19.1.</span> <span class="toc-text">双亲委派模型</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/post.png)"><div id="post-info"><div id="post-title"><div class="posttitle">《天净沙·我·jvm篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-03-11<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-03-13</time><div class="post-meta-wordcount"><span>Post View: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="Java的内存区域（运行时数据区）"><a href="#Java的内存区域（运行时数据区）" class="headerlink" title="Java的内存区域（运行时数据区）"></a>Java的内存区域（运行时数据区）</h2><h3 id="线程共享区"><a href="#线程共享区" class="headerlink" title="线程共享区"></a>线程共享区</h3><ol>
<li>堆</li>
<li>方法区 （方法区中包含运行时常量池）</li>
</ol>
<h3 id="线程私有区"><a href="#线程私有区" class="headerlink" title="线程私有区"></a>线程私有区</h3><ol>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>程序计数器<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h3 id="Java1-8之后的变化"><a href="#Java1-8之后的变化" class="headerlink" title="Java1.8之后的变化"></a>Java1.8之后的变化</h3><blockquote>
<p>线程共享的方法区糅合到了直接内存中的元空间</p>
</blockquote>
</li>
</ol>
<h2 id="为什么每一个线程需要一个程序计数器"><a href="#为什么每一个线程需要一个程序计数器" class="headerlink" title="为什么每一个线程需要一个程序计数器"></a>为什么每一个线程需要一个程序计数器</h2><h3 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h3><blockquote>
<p>是一块比较小的线程空间，可以当作字节码指令的指示器，字节码解释器通过程序计数器<br>来控制字节码指令，比如循环，跳转，分支，异常处理等</p>
</blockquote>
<h3 id="为啥线程需要程序计数器？"><a href="#为啥线程需要程序计数器？" class="headerlink" title="为啥线程需要程序计数器？"></a>为啥线程需要程序计数器？</h3><blockquote>
<p>由于线程是不断切换的，所以线程在切换后，如何进行哪一步的继续操作，是需要程序计的<br>同时程序计数器是唯一一个不会出现OutOfMemoryError的内存区域</p>
</blockquote>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><blockquote>
<p>虚拟栈其实更通俗的讲也就是线程私有化的方法栈，用于执行线程中Java方法调用的内存模型，每次调用都是通过栈来传递的<br>其实Java内存中可以区分成栈空间，和堆空间，栈空间就是现在的虚拟机栈等，同共享<br>区的方法区一样，栈空间的栈帧依然包含局部变量表（各种基本数据类型和引用）<br>同程序计数器不同的是，虚拟机栈会出现超过栈数目的 StackOutOfFlow 以及超过内存<br>内存空间的OutOfMemoryError</p>
</blockquote>
<h3 id="Java的两种返回方式"><a href="#Java的两种返回方式" class="headerlink" title="Java的两种返回方式"></a>Java的两种返回方式</h3><ol>
<li>return</li>
<li>异常抛出</li>
</ol>
<blockquote>
<p>方法每一次的调用都会压栈，同时每一次返回都会出栈，上面两个方法的调用都会导致<br>出栈</p>
</blockquote>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><h2 id="本地方法栈是做什么的？"><a href="#本地方法栈是做什么的？" class="headerlink" title="本地方法栈是做什么的？"></a>本地方法栈是做什么的？</h2><blockquote>
<p>本地方法栈和虚拟机栈不同，本地方法栈是用来执行Native修饰的方法，但是虚拟机栈<br>是用来执行Java的方法，但是对于HotSpot虚拟机来说，虚拟机栈和本地方法栈合并了<br>所以一样的可以推出，本地方法栈也有自己的栈帧等，栈帧里面也相应的有局部变量表<br>操作数栈，动态链接，出口信息等</p>
</blockquote>
<h2 id="堆-（GC堆）"><a href="#堆-（GC堆）" class="headerlink" title="堆 （GC堆）"></a>堆 （GC堆）</h2><blockquote>
<p>堆是线程共享区的，也是Jvm管理的最大的内存空间，没有之一，几乎所有的对象实例和<br>都在这里分配内存，当然了线程中的类的实例等，都通过reference进行引用<br>由于垃圾大多数也都是由堆产生，因此也被称作为 GC堆</p>
</blockquote>
<h2 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h2><blockquote>
<p>堆中可以粗略的说有 新生代和老年代 ，新生代用完以后可能就不会再引用，所以要更多的被释放掉<br>老年代则趋于稳定，长久的存在或被使用</p>
</blockquote>
<p>更加细致的划分</p>
<blockquote>
<p>被分为Eden区和From Survivor，To Survivor<br>大部分情况下，首先会再Eden区进行空间分配，在一次垃圾回收后，对象还存活则年龄加一<br>当年龄增加到默认的15岁，则进入到老年代，当然晋升的年龄阈值是可以调节的-XX:MaxTenuringThreshold</p>
</blockquote>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><blockquote>
<p>属于线程共享的内存区域，用于存放虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码量，主要是用于存放堆中的逻辑操作等。<br>方法区也就是永久代，永久代不用纠结就是HotSpot规定的一种规范方法区的一种实现</p>
</blockquote>
<pre><code class="java">-XX:PermSize=N <span class="comment">//⽅法区(永久代)初始⼤⼩</span>
-XX:MaxPermSize=N <span class="comment">//⽅法区(永久代)最⼤⼤⼩,超过这个值将会抛出OutOfMemoryError异</span>
常:java.lang.OutOfMemoryError: PermGen
</code></pre>
<blockquote>
<p>不过到JDK1.8的时候已经被移除了，直接变成了元空间，也就是直接存入内存空间。</p>
</blockquote>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><blockquote>
<p>是属于方法区的一部分，Class文件中有类型，方法，接口，版本等信息外，还有一些常量（最特征的就是final修饰的）<br>但是1.7之后这部分又去到了堆中开辟了一片空间，因此</p>
</blockquote>
<h3 id="运行时常量池包含什么"><a href="#运行时常量池包含什么" class="headerlink" title="运行时常量池包含什么"></a>运行时常量池包含什么</h3><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><ol>
<li>文本字符串</li>
<li>final修饰的</li>
<li>基本数据类型的值<h4 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h4></li>
<li>类和结构完全限定名</li>
<li>字段名称和描述符</li>
<li>方法名称和描述符</li>
</ol>
<h2 id="Java对象的创建过程"><a href="#Java对象的创建过程" class="headerlink" title="Java对象的创建过程"></a>Java对象的创建过程</h2><h3 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1. 类加载检查"></a>1. 类加载检查</h3><blockquote>
<p>从常量池中定位new的符号引用，看看找个类是不是被加载，解析，初始化过。如果没有再执行相应的类加载过程</p>
</blockquote>
<h3 id="2-分配内存"><a href="#2-分配内存" class="headerlink" title="2. 分配内存"></a>2. 分配内存</h3><blockquote>
<p>在堆中直接分配内存，在类加载后会直到该对象需要分配的大小，分配方法有两种（指针碰撞 和 空闲列表），分配方式的选择是由Java堆是否规整决定的</p>
</blockquote>
<h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><blockquote>
<p>就是内存如果工整，那么直接就移动指针分配空间</p>
</blockquote>
<h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><blockquote>
<p>内存不工整，类加载确定出空间后，进行“见缝插针”</p>
</blockquote>
<h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><h5 id="CAS乐观解决"><a href="#CAS乐观解决" class="headerlink" title="CAS乐观解决"></a>CAS乐观解决</h5><blockquote>
<p>就是继续利用CAS算法尝试去获取内存空间，直到成功，虚拟机就是这么做的</p>
</blockquote>
<h5 id="TLAB解决"><a href="#TLAB解决" class="headerlink" title="TLAB解决"></a>TLAB解决</h5><blockquote>
<p>在堆中给每个线程分配一丢丢空间，让他自己独有，分配的时候就先分配给TLAB空间，<br>但是这么做的后果就是空间浪费问题</p>
</blockquote>
<h3 id="3-初始化零值"><a href="#3-初始化零值" class="headerlink" title="3. 初始化零值"></a>3. 初始化零值</h3><blockquote>
<p>不包括对象头 ，就是给一一些值赋0或者null</p>
</blockquote>
<h3 id="4-设置对象头"><a href="#4-设置对象头" class="headerlink" title="4. 设置对象头"></a>4. 设置对象头</h3><blockquote>
<p>对象的hash码，分代年龄等，同时个synchronized锁也在对象头</p>
</blockquote>
<h3 id="5-执行init（）方法"><a href="#5-执行init（）方法" class="headerlink" title="5. 执行init（）方法"></a>5. 执行init（）方法</h3><blockquote>
<p>可以理解为Jvm已经创建完成，但是这里才是按照程序员的意愿开始创建，有点感觉是构造方法执行</p>
</blockquote>
<h2 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h2><ol>
<li>句柄</li>
<li>直接访问</li>
</ol>
<blockquote>
<p>二者的区别在于对于对象实例数据的处理上，句柄是先访问实例苏话剧的指针，在访问实例数据<br>直接指针是直接去Heap中去访问实例数据，不过相应的二者访问类型数据都是先去堆中访问类型数据指针再去方法区去拿到类型数据</p>
</blockquote>
<h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><blockquote>
<p>如果是读取的话，看上面过程也就直到，直接指针直接读取会更快一些，但是同样的如果<br>进行删除操作等，需要一个一个的更改数据，效率差，如果是句柄的话直接地址赋null值<br>就可以了，这个赋null值其实和c++的回收是一样的，直接赋null，就证明这一块空间又<br>可以被分配利用了</p>
</blockquote>
<h2 id="对象的分配策略"><a href="#对象的分配策略" class="headerlink" title="对象的分配策略"></a>对象的分配策略</h2><blockquote>
<p>大对象，长期存活对象分配到老年代，但是一般的对象有限分配到Eden区</p>
</blockquote>
<h3 id="Minor-GC，-Full-GC的区别"><a href="#Minor-GC，-Full-GC的区别" class="headerlink" title="Minor GC， Full GC的区别"></a>Minor GC， Full GC的区别</h3><blockquote>
<p>MinorGC也就是新生代的垃圾回收，很频繁，而且速度快<br>FullGC是指老年代的垃圾回收，不是很频繁</p>
</blockquote>
<h2 id="对象的死亡判断"><a href="#对象的死亡判断" class="headerlink" title="对象的死亡判断"></a>对象的死亡判断</h2><h3 id="程序计数器法"><a href="#程序计数器法" class="headerlink" title="程序计数器法"></a>程序计数器法</h3><blockquote>
<p>就是一个对象被引用一次那么计数器加一，如果引用失效那么计数器减一,如果为0，则<br>直接回收</p>
</blockquote>
<h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><blockquote>
<p>形象的来说就是以GC Root作为起点，然后查看各个对象到GCRoot是否有一条路劲可以<br>连起来，如果连不起来则直接回收</p>
</blockquote>
<h4 id="补充：一般哪些可以作为GCRoot呢："><a href="#补充：一般哪些可以作为GCRoot呢：" class="headerlink" title="补充：一般哪些可以作为GCRoot呢："></a>补充：一般哪些可以作为GCRoot呢：</h4><blockquote>
<p>通过System Class Loader或者Boot Class Loader加载的class对象，通过自定义类加载器加载的class不一定是GC Root<br>处于激活状态的线程<br>栈中的对象<br>JNI（Java Native Interface）栈中的对象<br>JNI中的全局对象<br>正在被用于同步的各种锁对象<br>JVM自身持有的对象，比如系统类加载器等</p>
</blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p>Java1.2之前定义引用就是reference如果指向的是内存空间的起始地址。</p>
</blockquote>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><blockquote>
<p>大多数使用的基本都是强引用，垃圾回收器则不会去回收他，及时空间不足，直接oom，也不会去回收强引用</p>
</blockquote>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><blockquote>
<p>区别于强引用，当发生内存不足的时候，才可以被垃圾回收掉。 也正是这样，可以用来<br>处理对内存比较敏感的高速缓存</p>
</blockquote>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><blockquote>
<p>区别于软引用，只要垃圾回收器扫描到这部分视作垃圾，那么就直接回收掉<br>可以配合一个引用队列，来查看是是否被GC回收</p>
</blockquote>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><blockquote>
<p>虚引用的实际用途不在乎是引用了什么对象，粗略的说可以说成一种 即将被GC回收的标<br>志，也是一种跟踪GC回收的一种方法，虚引用必须配合 引用队列来使用，即在某对象回<br>收之前，则虚引用入队，告诉Jvm该对象即将要被回收，可以在某对象被回收前做一些操作</p>
</blockquote>
<h2 id="废弃常量的判定方法"><a href="#废弃常量的判定方法" class="headerlink" title="废弃常量的判定方法"></a>废弃常量的判定方法</h2><blockquote>
<p>如果是在常量池，而且没用String对象引用，那么就说他是废弃常量，如果内存回收需要的话，直接清理出去</p>
</blockquote>
<h2 id="如何判定一个类的废弃"><a href="#如何判定一个类的废弃" class="headerlink" title="如何判定一个类的废弃"></a>如何判定一个类的废弃</h2><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><blockquote>
<p>ClassLoader是一个类加载器，它的工作是将一个类的全限名在Jvm外部进行转化成一个<br>二进制流,转成二进制流是为了Jvm读取，但是是在虚拟机外部就转化成，这样的目的是<br>让应用程序自己可以选择这个类，这也是为啥在对象回收时，Jvm Rooter可以是<br>Classroader的原因</p>
</blockquote>
<h3 id="java-lang-Class"><a href="#java-lang-Class" class="headerlink" title="java.lang.Class"></a>java.lang.Class</h3><blockquote>
<p>反射机制的核心，也就就是所有类自身的一个独有的镜子，在一个类被编译成.class文件的时候，在jvm中运行，会同时自动生成一个和自己创建的类想匹配的Class类</p>
</blockquote>
<h3 id="一个类废弃的判定方法"><a href="#一个类废弃的判定方法" class="headerlink" title="一个类废弃的判定方法"></a>一个类废弃的判定方法</h3><ol>
<li>所有的实例已经被回收掉，堆中不再有这个类的实例</li>
<li>该类的Classloader也已经被回收</li>
<li>该类对应的java.lang.class文件没有在任何地方被引用，也无法在任何地方通过反射机制来访问该类</li>
</ol>
<h2 id="垃圾回收机制的算法"><a href="#垃圾回收机制的算法" class="headerlink" title="垃圾回收机制的算法"></a>垃圾回收机制的算法</h2><h3 id="无脑清空法-–-标记清除算法"><a href="#无脑清空法-–-标记清除算法" class="headerlink" title="无脑清空法 – 标记清除算法"></a>无脑清空法 – 标记清除算法</h3><blockquote>
<p>标记需要回收的对象，然后标记完后，通过一轮回收直接把标记的位置回收</p>
<ol>
<li>效率差</li>
<li>清理完空间不连续</li>
</ol>
</blockquote>
<h3 id="复制填坑法-–-复制算法"><a href="#复制填坑法-–-复制算法" class="headerlink" title="复制填坑法 – 复制算法"></a>复制填坑法 – 复制算法</h3><blockquote>
<p>将内存空间分成两份，然后将不需要回收的内存（活着的对象）复制到另一块空间去，保证整洁</p>
<ol>
<li>需要两份一样的空间</li>
<li>复制的时候消耗太大</li>
</ol>
</blockquote>
<h3 id="洁癖整理法-–-标记整理算法"><a href="#洁癖整理法-–-标记整理算法" class="headerlink" title="洁癖整理法 – 标记整理算法"></a>洁癖整理法 – 标记整理算法</h3><blockquote>
<p>也是先标记，但是不同的是，标记以后直接向某一端直接移动，然后GC直接回收边界的无用的空间</p>
</blockquote>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><blockquote>
<p>分配空间的空间按照新生代和老年代区别，新生代可以用复制算法，老年代的内存大，而且多，可以使用 标记整理算法，也可以酌情标记清空算法</p>
</blockquote>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial-（年轻代）"><a href="#Serial-（年轻代）" class="headerlink" title="Serial （年轻代）"></a>Serial （年轻代）</h3><ol>
<li>单线程收集器</li>
<li>当进行单线程回收垃圾的时候，其它线程必须停止</li>
<li>但是对一个客户端的还不错，毕竟切换没那么复杂，而且单线程自然可以调用的资源更多<h3 id="ParNew-（年轻代）"><a href="#ParNew-（年轻代）" class="headerlink" title="ParNew （年轻代）"></a>ParNew （年轻代）</h3><blockquote>
<p>上述Serial的一个升级，其实就是升级成了多线程</p>
</blockquote>
</li>
<li>多线程收集</li>
<li>stop the world ，还是要停止所有的线程工作<h3 id="Parallel-Scavenge-（年轻代）"><a href="#Parallel-Scavenge-（年轻代）" class="headerlink" title="Parallel Scavenge （年轻代）"></a>Parallel Scavenge （年轻代）</h3><blockquote>
<p>为了吞吐量而减少收集时间，提高收集次数的一种收集算法，（吞吐量：程序运行时间/CPU使用时长）<br>适合执行批量处理、订单处理</p>
</blockquote>
<h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3></li>
</ol>
<h3 id="CMS-（老年代）"><a href="#CMS-（老年代）" class="headerlink" title="CMS （老年代）"></a>CMS （老年代）</h3><blockquote>
<p>HotSpot的第一款真正意义上的并发垃圾回收机制，是用的标记清除算法</p>
</blockquote>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><h5 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h5><blockquote>
<p>暂停掉所有的线程，标记一下与GC root相连的对象（可达性分析里面的那个GC Root）</p>
</blockquote>
<h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h5><blockquote>
<p>继续类似可达性分析，标记一系列可达的的队形 GC Root Trancing</p>
</blockquote>
<h5 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h5><blockquote>
<p>并发标记是并发的，重新标记是为了修正重新标记期间的用户变动</p>
</blockquote>
<h5 id="并发清除"><a href="#并发清除" class="headerlink" title="并发清除"></a>并发清除</h5><blockquote>
<p>开始对标记的区域做清理</p>
</blockquote>
<ol>
<li>对CPU资源敏感</li>
<li>无法清理浮动垃圾<br>3 标记清除算法有太多的空间碎片<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><blockquote>
<p>面向服务器的垃圾回收器，针对配备多核处理起的cpu<br>宏观上是复制，微观上有标记整理算法<br>不区分内存块 Eden surviovor old在微观上还是被保留的</p>
</blockquote>
<h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><h5 id="初始标记-1"><a href="#初始标记-1" class="headerlink" title="初始标记"></a>初始标记</h5><h5 id="并发标记-1"><a href="#并发标记-1" class="headerlink" title="并发标记"></a>并发标记</h5><h5 id="最终标记"><a href="#最终标记" class="headerlink" title="最终标记"></a>最终标记</h5><h5 id="筛选回收"><a href="#筛选回收" class="headerlink" title="筛选回收"></a>筛选回收</h5></li>
</ol>
<blockquote>
<p>过程其实大同小异，相比于CMS其实更多的在于标记的时候多了Remember Set，到了最终标记还有Remeber Set Log合并到了Remeber Set因此避免了浮动垃圾问题<br>Region在宏观是其实是复制原则，但是在Region的内部其实是标记整理算法<br>Region内部除了Eden s0 s1 old 还有超大对象，面对超大对象，会选择移动老年代的<br>对象来为超大内存的对象提供内存</p>
</blockquote>
<h2 id="Jvm类加载模式"><a href="#Jvm类加载模式" class="headerlink" title="Jvm类加载模式"></a>Jvm类加载模式</h2><ol>
<li>加载<blockquote>
<p>这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口</p>
</blockquote>
</li>
<li>验证<blockquote>
<p>了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求</p>
</blockquote>
</li>
<li>准备<blockquote>
<p>是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。</p>
</blockquote>
</li>
<li>解析<blockquote>
<p>虚拟机将常量池中的符号引用替换为直接引用的过程</p>
</blockquote>
</li>
<li>初始化<blockquote>
<p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。</p>
</blockquote>
</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ol>
<li>启动类加载器<blockquote>
<p>负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被<br>虚拟机认可（按文件名识别，如 rt.jar）的类</p>
</blockquote>
</li>
<li>扩展类加载器<blockquote>
<p>负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类<br>库</p>
</blockquote>
</li>
<li><p>应用程序类加载器</p>
<blockquote>
<p>负责加载用户路径（classpath）上的类库<br>利用双亲委派模型进行类的加载，通过继承java.lang.classloader实现自定义类加载器</p>
</blockquote>
<pre><code>                启动类加载器（Bootstrap ClassLoader）
                                /\
                                ||
                扩展类加载器 （Extension ClassLoader）
                                /\
                                ||
                应用程序类加载器 （Application ClassLoader）
                        /\                  /\
                        ||                  ||
自定义加载器（User ClassLoader）    自定义加载器（UserClassLoader）
</code></pre></li>
</ol>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><blockquote>
<p>当一个类收到类加载的请求，他首先不会尝试自己去加载这个类，而是把请求委托给父类去完成，每一层的类加载器都是如此（如上图，箭头向上），因此最终所有的加载类都应该送到启动类加载器去完成，只有当父类的加载器返回自己无法加载这个请求的时候，子类加载器才会自己尝试去加载。<br>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载<br>器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载<br>器最终得到的都是同样一个 Object 对象</p>
</blockquote>
</the></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">夜小猫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://runindark.com/2020/03/11/我为阿里-Jvm/">http://runindark.com/2020/03/11/我为阿里-Jvm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/03/12/我为阿里-Spring/"><img class="prev_cover lozad" data-src="undefined" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>《天净沙·我·Spring》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</span></div></a></div><div class="next-post pull-right"><a href="/2020/03/10/我为阿里-mysql/"><img class="next_cover lozad" data-src="undefined" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>《天净沙·我·mysql篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</span></div></a></div></nav></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2020 By 夜小猫</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>