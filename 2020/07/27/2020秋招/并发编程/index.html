<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    并发编程篇复习总结 |
    
    Cat&#39;s blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  

<article id="post-2020秋招/并发编程" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      并发编程篇复习总结
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2020/07/27/2020秋招/并发编程/" class="article-date">
  <time datetime="2020-07-27T01:45:34.184Z" itemprop="datePublished">2020-07-27</time>
</a>
        
      </div>
    

    
      
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="进程，协程，线程基础概念"><a href="#进程，协程，线程基础概念" class="headerlink" title="进程，协程，线程基础概念"></a>进程，协程，线程基础概念</h2><h3 id="能否解释进程，线程，协程的关系？"><a href="#能否解释进程，线程，协程的关系？" class="headerlink" title="能否解释进程，线程，协程的关系？"></a>能否解释进程，线程，协程的关系？</h3><blockquote>
<p>进程是一个程序代码运行所执行的一个程序，但是一个进程可以包含多个线程，在单核cpu下，Java默认多线程可以以一种抢占式的方式执行一种并发状态，协程是近些年走进视野的，以GO语言为代表可以操作协程，一个线程中可以包含更多的协程，可以简单的说线程包含协程。</p>
</blockquote>
<h3 id="协程对于多线程有什么优缺点吗？"><a href="#协程对于多线程有什么优缺点吗？" class="headerlink" title="协程对于多线程有什么优缺点吗？"></a>协程对于多线程有什么优缺点吗？</h3><ol>
<li>首先是更小的协程可以在不使用内核的前提下进行上下文切换</li>
<li>一个线程就可以完成高并发的任务，对高并发的支持更好</li>
<li>协程在一个线程下，是不用考虑数据的读写不一致问题（读写变量冲突问题）</li>
<li>缺点： 缺点也很明显，本质还是一个单线程，不能利用多核资源，同时也不独立，需要线程，进程配合才可以运行</li>
</ol>
<h3 id="并行和并发的区别是什么？"><a href="#并行和并发的区别是什么？" class="headerlink" title="并行和并发的区别是什么？"></a>并行和并发的区别是什么？</h3><ol>
<li>并行是指多个程序 同时多个一起运行</li>
<li>并发是指多个程序在某一个时间段内交替的快速运行，宏观是有点类似并行，但是实际上是交替运行</li>
<li>恶补英语之==&gt; 并发 （concurrency）  并⾏ parallellism</li>
</ol>
<h2 id="多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）"><a href="#多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）" class="headerlink" title="多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）"></a>多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）</h2><h3 id="Java线程创建的几种方式"><a href="#Java线程创建的几种方式" class="headerlink" title="Java线程创建的几种方式"></a>Java线程创建的几种方式</h3><ol>
<li><p>继承extends</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread by extend Thread"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadByThread threadByThread = <span class="keyword">new</span> ThreadByThread() ;</span><br><span class="line">        threadByThread.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Runnable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread create by implements Runnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadByRunnable ta = <span class="keyword">new</span> ThreadByRunnable() ;</span><br><span class="line">        <span class="keyword">new</span> Thread(ta).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用CF</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByCF</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Thread create by CF"</span> +<span class="string">":"</span> +Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FutureTask&lt;Object&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> ThreadByCF()) ;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.setName(<span class="string">"Cf"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.print.DocFlavor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            service.execute(<span class="keyword">new</span> ThreadByThread());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread());</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="线程基本原理"><a href="#线程基本原理" class="headerlink" title="线程基本原理"></a>线程基本原理</h2><h3 id="线程有哪些状态"><a href="#线程有哪些状态" class="headerlink" title="线程有哪些状态"></a>线程有哪些状态</h3><blockquote>
<p>创建 -&gt; 就绪 -&gt; 执行 -&gt; 消亡<br>阻塞: 分为同步组织，等待阻塞。 等待阻塞就是wait啦，sleep啦。同步阻塞就是sychronize锁被占用，另一个线程也需要占用这个锁，结果凉了，就阻塞了。</p>
</blockquote>
<h3 id="线程的基本一些方法"><a href="#线程的基本一些方法" class="headerlink" title="线程的基本一些方法"></a>线程的基本一些方法</h3><ol>
<li>sleep<blockquote>
<p>就是进入了等待阻塞队列中，根据设定的时间阻塞，而且不会释放锁，他的阻塞状态就是time_waiting</p>
</blockquote>
</li>
<li>yield<blockquote>
<p>就是让线程立马停止一下，但是不会进入阻塞，而是直接进入就绪,且不会释放锁</p>
</blockquote>
</li>
<li>join<blockquote>
<p>谁调用join谁先执行，然后再执行被停用的线程</p>
</blockquote>
</li>
<li>wait<blockquote>
<p>就是进入等待状态，而且必须有人去唤醒他，但是wait会释放锁，也可以wait（time）来通过时间唤醒</p>
</blockquote>
</li>
<li>notify<blockquote>
<p><strong>随机的唤醒任意的</strong>一个被wait的线程</p>
</blockquote>
</li>
<li>notifyall<blockquote>
<p>把wait的线程，全部唤醒</p>
</blockquote>
</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="说说volatile的与sychronize的区别"><a href="#说说volatile的与sychronize的区别" class="headerlink" title="说说volatile的与sychronize的区别"></a>说说volatile的与sychronize的区别</h3><ol>
<li>volatile 不是原子性的，sychronize是原子性的</li>
<li>volatile和sychronize都保证了可见性</li>
<li>volatile是禁止了指令重排的</li>
<li>不能写入 不能修饰写⼊操作依赖当前值的变量，⽐如num++、num=num+1</li>
</ol>
<h3 id="为啥会出现脏读的问题？"><a href="#为啥会出现脏读的问题？" class="headerlink" title="为啥会出现脏读的问题？"></a>为啥会出现脏读的问题？</h3><blockquote>
<p>这个是JMM（java内存模型） 导致的，java线程中不是所有的变量都是在主存的，而是每个线程都有自己的一丢丢空间，对于修改的变量的操作，先从主存拿到，再修改，再写回去，如果多线程，可能因为速度问题，写入的时间啥的有差别，所以就会导致把数据脏读了。</p>
</blockquote>
<h3 id="为啥volatile可以解决这个问题呢？"><a href="#为啥volatile可以解决这个问题呢？" class="headerlink" title="为啥volatile可以解决这个问题呢？"></a>为啥volatile可以解决这个问题呢？</h3><blockquote>
<p>volatile就像是一个敏感的报警灯一样，一旦有人妄图修改volatile修饰的数据，立马报警通知修改情况，所以说原子性差了点，但是可见性或者说是共享性好的鸭匹</p>
</blockquote>
<h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul>
<li>程序次序原则：无论怎么重排，都不会影响最终的运行结果</li>
<li>管程（Synchronized）序锁定原则：锁L被线程A释放，之后又被线程B获取，则线程B可见线程A在他之前获取到锁</li>
<li>volatile变量原则： 共享变量可以所有线程中都可见</li>
<li>线程启动原则： 启动线程A后，线程A中还有线程B也会被启动，则线程B可以看到线程A的修改结果</li>
<li>线程终止原则： 启动线程A后，线程A中还有线程B也会被启动，B在结束以前，线程A可以看到线程B的修改结果</li>
<li>线程中断原则： Intercept()中断的线程，Thread.Intercept()可见线程是否被中断</li>
<li>传递原则：A happen-before B，B happen-before C，C happen-before A</li>
<li>对象终结原则： 开始的一定是构造函数，结束的一定是finalize()</li>
</ul>
<h2 id="并发编程三要素"><a href="#并发编程三要素" class="headerlink" title="并发编程三要素"></a>并发编程三要素</h2><ul>
<li>原子性</li>
<li>有序性</li>
<li>可见性<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><blockquote>
<p>每次读写数据都是悲观的，认为可能会出现数据被其它线程读的问题，所以要上锁比如sychronized</p>
</blockquote>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote>
<p>每次读取数据都觉得是乐观的，觉得不会有其它线程更改要读取的数据</p>
</blockquote>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><blockquote>
<p>就是大家人人平等，都可以拿到锁，阻塞队列中按照顺序慢慢来=》reetrantlock（fair）</p>
</blockquote>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><blockquote>
<p>不公平的，只要你条件符合，就可以直接拿到锁=》reetrantlock（unfair）<br>reetrantlock其实底层就是一个队列，所以也是先来先服务那种，在公平锁体现的很好</p>
</blockquote>
<h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><blockquote>
<p>一个线程里吧，还调用另一个线程，然后这个锁对里面的这个线程也生效</p>
</blockquote>
<h3 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h3><blockquote>
<p>一个线程里吧，还调用另一个线程，然后吧，里面这个线程就不能用这个锁了，就只能乖巧的滚去阻塞队列了</p>
</blockquote>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><blockquote>
<p>就是想不开的锁，只要没条件获取到锁，就一直自旋，也就是一直去判断条件看看自己能不能获得锁子，while（flag）的感觉，除非获得锁才能结束，但是注意，自旋锁消耗cpu，毕竟在那转来转去的。<br>不会发⽣线程状态的切换，⼀直处于⽤户态，减少了线程上下⽂切换的消耗，缺点是循环会消耗CPU</p>
</blockquote>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><blockquote>
<p>也就是读锁，或者是S锁，就是可以让大家读取，查看，就是不能修改</p>
</blockquote>
<h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><blockquote>
<p>也就是霸占一把锁，只要这个线程占着，别人就不能去获取这个锁，但是只要霸占这个锁，能读能写</p>
</blockquote>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote>
<p>资源抢占矛盾循环了，无外力介入，是解不开的</p>
</blockquote>
</li>
</ul>
<h3 id="关于jvm自己内部的几个锁"><a href="#关于jvm自己内部的几个锁" class="headerlink" title="关于jvm自己内部的几个锁"></a>关于jvm自己内部的几个锁</h3><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote>
<p>就是如果哪个线程一直用着这个锁，就一直让他先用，更少的消耗量</p>
</blockquote>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote>
<p>如果其他锁妄图获得人家那个偏向锁，那就自旋吧，等人家用完才给你</p>
</blockquote>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><blockquote>
<p>自选锁也不自旋了，直接阻塞进化成重量级锁，重量级锁会让其他申请的线程进⼊阻塞，性能也会降低</p>
</blockquote>
<h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String locka = <span class="string">"A"</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String lockb = <span class="string">"B"</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"entre the locka"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line">                System.out.println(<span class="string">"a 取 b"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"entre the lockb"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line">                System.out.println(<span class="string">"b 取 a"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">          System.out.println(i+<span class="number">1</span> + <span class="string">"次"</span>);</span><br><span class="line">          <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">              DeadLock.LockA();</span><br><span class="line">          &#125;).start();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">              DeadLock.LockB();</span><br><span class="line">          &#125;).start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解锁代码"><a href="#解锁代码" class="headerlink" title="解锁代码"></a>解锁代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String locka = <span class="string">"A"</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String lockb = <span class="string">"B"</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"entre the locka"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line">                System.out.println(<span class="string">"a 取 b"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line">            System.out.println(<span class="string">"entre the lockb"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line">            System.out.println(<span class="string">"b 取 a"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(i+<span class="number">1</span> + <span class="string">"次"</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                DeadLock.LockA();</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                DeadLock.LockB();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>改变运行策略，其实是线程A中syc获取了锁a，还要获取suob，这样子顺序执行下来是ok 的，就怕线程a获取了锁a后，线程b抢占获取了锁b，此使线程a还要锁b<br>就阻塞了，所以到了线程b又要获取锁a，那么就死锁了<br>解决方法也简单，就是让一个锁提早消失就好了，所以改变一下sychronize的次序，提早释放锁，就万事大吉了</p>
</blockquote>
<h3 id="死锁的四个条件"><a href="#死锁的四个条件" class="headerlink" title="死锁的四个条件"></a>死锁的四个条件</h3><blockquote>
<p>互斥条件：资源不能共享，只能由⼀个线程使⽤<br>请求与保持条件：线程已经获得⼀些资源，但因请求其他资源发⽣阻塞，对已经获得的资源保持不释放<br>不可抢占：有些资源是不可强占的，当某个线程获得这个资源后，系统不能强⾏回收，只能由线程使⽤完⾃⼰释放<br>循环等待条件：多个线程形成环形链，每个都占⽤对⽅申请的下个资源</p>
</blockquote>
<h2 id="重入锁和不可重入锁"><a href="#重入锁和不可重入锁" class="headerlink" title="重入锁和不可重入锁"></a>重入锁和不可重入锁</h2><h3 id="不可重入锁-1"><a href="#不可重入锁-1" class="headerlink" title="不可重入锁"></a>不可重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BcrLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">boolean</span> flag = <span class="keyword">false</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"进入加锁"</span>);</span><br><span class="line">            flag = <span class="keyword">true</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"进入等待状态"</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"进入解锁"</span>);</span><br><span class="line">        notify();</span><br><span class="line">        flag = <span class="keyword">false</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.Messaging.SYNC_WITH_TRANSPORT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BcrLock bcrLock = <span class="keyword">new</span> BcrLock() ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bcrLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法A加锁"</span> + bcrLock.flag);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bcrLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bcrLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法B加锁"</span> + bcrLock.flag);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bcrLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> TestMain().methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重入锁-1"><a href="#重入锁-1" class="headerlink" title="重入锁"></a>重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.ir.Block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> islock = <span class="keyword">false</span> ;</span><br><span class="line">    <span class="keyword">public</span> String currentThread = <span class="keyword">null</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentThread==<span class="keyword">null</span>) &#123;</span><br><span class="line">            currentThread = Thread.currentThread().getName();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentThread.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"成功加锁"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!currentThread.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"加锁失败"</span>);</span><br><span class="line">                    wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        notify();</span><br><span class="line">        currentThread = <span class="keyword">null</span> ;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"成功解锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.awt.windows.ThemeReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMainB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CrLock crLock = <span class="keyword">new</span> CrLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            crLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法A加锁"</span> + crLock.currentThread);</span><br><span class="line">            methodB();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法a解锁"</span> );</span><br><span class="line">            crLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            crLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法B加锁"</span>+ crLock.currentThread );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法b解锁"</span> );</span><br><span class="line">            crLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">new</span> TestMainB().methodA();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">new</span> TestMainB().methodA();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronized说说看"><a href="#synchronized说说看" class="headerlink" title="synchronized说说看"></a>synchronized说说看</h2><blockquote>
<p>非公平锁，原子性，可重入可以修饰代码块和方法<br>每个对象有⼀个锁和⼀个等待队列，锁只能被⼀个线程持有，其他需要锁的线程需要阻塞等待。锁被释放<br>后，对象会从队列中取出⼀个并唤醒，唤醒哪个线程是不确定的，不保证公平性<br>jdk6优化-&gt; 偏向锁-&gt;轻量级锁-&gt;重量级锁</p>
</blockquote>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h3><blockquote>
<p>CAS是一种乐观锁，CompareAndSwap，也就是比较再交换<br>执行过程大概如下： 首先是 内存地址V，预期原值A，新值B ， 如果线程A过来，V = A ,则满足条件把目标值更换成B，如果线程B过来，V ！= A，那么无法<br>将目标值更换成B，而且线程B将进行自旋，直到 A=V ，结束自旋，获取锁<br>缺点也将显而易见： 自旋锁的存在直接导致了cpu的消耗问题<br>CAS是原子性的</p>
</blockquote>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><blockquote>
<p>简单来说就是线程在操作过程中，有其它线程将该变量更改后，又有另一个线程把他改回来，到最开始线程操作的时候，发现该值没有变化，则该线程操作成<br>功。加一个版本号可以解决问题，每次修改时都要查看版本号</p>
</blockquote>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><blockquote>
<p>AQS本质上是为了解决线程安全所提出的一种解决方案的抽象<br>AQS的组成</p>
<ul>
<li>程序计数器</li>
<li>阻塞队列</li>
<li>线程标记</li>
</ul>
</blockquote>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><blockquote>
<p>是一个双向的链表，概念上的队列，但不是真正的实现也是队列</p>
</blockquote>
<h3 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h3><blockquote>
<p>是根据condition创建出来的队列，上锁后可以负责对线程的监视，比synchronized的监视器更加灵活，是一个单向的链表，当唤醒界节点的时候会直接添加到阻塞队列中</p>
</blockquote>
<h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><h4 id="1-waitstatus"><a href="#1-waitstatus" class="headerlink" title="1. waitstatus"></a>1. waitstatus</h4><ol>
<li><p>CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</p>
</li>
<li><p>SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。</p>
</li>
<li><p>CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</p>
</li>
<li><p>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态</p>
<h4 id="2-prev"><a href="#2-prev" class="headerlink" title="2. prev"></a>2. prev</h4><blockquote>
<p>前驱节点</p>
</blockquote>
<h4 id="3-next"><a href="#3-next" class="headerlink" title="3. next"></a>3. next</h4><blockquote>
<p>后继节点</p>
</blockquote>
<h4 id="4-thread"><a href="#4-thread" class="headerlink" title="4. thread"></a>4. thread</h4><blockquote>
<p>thread 同步线程队列主要存储的线程信息。</p>
</blockquote>
<h4 id="5-nextwaiter"><a href="#5-nextwaiter" class="headerlink" title="5. nextwaiter"></a>5. nextwaiter</h4><p>AQS中阻塞队列采用的是用双向链表保存，用prve和next相互链接。而AQS中条件队列是使用单向列表保存的，用<br>nextWaiter来连接。阻塞队列和条件队列并不是使用的相同的数据结构</p>
</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000015804888" target="_blank" rel="noopener">精髓原帖</a></p>
<p>在Node节点的源码中有两个常量属性</p>
<pre><code class="java"><span class="comment">// 共享模式</span>
<span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();
<span class="comment">// 独占模式</span>
<span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;
<span class="comment">// 其他模式</span>
<span class="comment">// 其他非空值：条件等待节点（调用Condition的await方法的时候）</span>
</code></pre>
<h3 id="部分核心方法"><a href="#部分核心方法" class="headerlink" title="部分核心方法"></a>部分核心方法</h3><h3 id="acquire-int-arg-源码讲解，好⽐加锁lock操作"><a href="#acquire-int-arg-源码讲解，好⽐加锁lock操作" class="headerlink" title="acquire(int arg) 源码讲解，好⽐加锁lock操作"></a>acquire(int arg) 源码讲解，好⽐加锁lock操作</h3><ol>
<li>tryAcquire()尝试直接去获取资源，如果成功则直接返回,AQS⾥⾯未实现但没有定义成<br>abstract，因为独占模式下只⽤实现tryAcquire-tryRelease，⽽共享模式下只⽤实现<br>tryAcquireShared-tryReleaseShared，类似设计模式⾥⾯的适配器模式</li>
<li>addWaiter() 根据不同模式将线程加⼊等待队列的尾部，有Node.EXCLUSIVE互斥模式、<br>Node.SHARED共享模式；如果队列不为空，则以通过compareAndSetTail⽅法以CAS将当前线程<br>节点加⼊到等待队列的末尾。否则通过enq(node)⽅法初始化⼀个等待队列</li>
<li>acquireQueued()使线程在等待队列中获取资源，⼀直获取到资源后才返回,如果在等待过程<br>中被中断，则返回true，否则返回false<h3 id="release-int-arg-源码讲解-好⽐解锁unlock"><a href="#release-int-arg-源码讲解-好⽐解锁unlock" class="headerlink" title="release(int arg)源码讲解 好⽐解锁unlock"></a>release(int arg)源码讲解 好⽐解锁unlock</h3>独占模式下线程释放指定量的资源，⾥⾯是根据tryRelease()的返回值来判断该线程是<br>否已经完成释放掉资源了；在⾃义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回<br>true，否则返回false<br>unparkSuccessor⽅法⽤于唤醒等待队列中下⼀个线程</li>
</ol>
<h2 id="ReentrantLock实现原理"><a href="#ReentrantLock实现原理" class="headerlink" title="ReentrantLock实现原理"></a>ReentrantLock实现原理</h2><blockquote>
<p>实现大致的思路是和AQS是一致的，ReentrantLock的实现是分为公平锁和非公平锁的，其中上层Lock（Accquire），Unlock（Release）上层一致，唯独在释放的时候有一点区别，公平锁的实现是直接去队列中去找，看看队列中是否有等待，如果有等待的话则排队，无等待的话就直接给锁，对应的方法也就是TryAccquire（） ，而非公平锁则直接判断是不是符合获取锁的条件CompareAndState，如果符合直接给锁，如果不符合，则是按照公平锁的方法处理</p>
</blockquote>
<h2 id="ReentrantLock和synchronized区别是什么？"><a href="#ReentrantLock和synchronized区别是什么？" class="headerlink" title="ReentrantLock和synchronized区别是什么？"></a>ReentrantLock和synchronized区别是什么？</h2><ol>
<li>ReentrantLock和synchronized都是独占锁</li>
<li>synchronized：<blockquote>
<p>· 是悲观锁会引起其他线程阻塞，java内置关键字，<br>· ⽆法判断是否获取锁的状态，锁可重⼊、不可中断、只能是⾮公平<br>· 加锁解锁的过程是隐式的,⽤户不⽤⼿动操作,优点是操作简单但显得不够灵活<br>· ⼀般并发场景使⽤⾜够、可以放在被递归执⾏的⽅法上,且不⽤担⼼线程最后能否正确<br>释放锁<br>· synchronized操作的应该是对象头中mark word，参考原先原理图⽚</p>
</blockquote>
</li>
<li>ReentrantLock：<blockquote>
<p>· 是个Lock接⼝的实现类，是悲观锁，<br>· 可以判断是否获取到锁，可重⼊、可判断、可公平可不公平<br>· 需要⼿动加锁和解锁,且解锁的操作尽量要放在finally代码块中,保证线程正确释放锁<br>· 在复杂的并发场景中使⽤在重⼊时要却确保重复获取锁的次数必须和重复释放锁的次数⼀样，否则可能导致 其他线程⽆法获得该锁。<br>· 创建的时候通过传进参数true创建公平锁,如果传⼊的是false或没传参数则创建的是⾮公平锁<br>· 底层不同是AQS的state和FIFO队列来控制加锁</p>
</blockquote>
</li>
</ol>
<h2 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h2><p>核心其实是将锁分成了<strong>读锁</strong>和<strong>写锁</strong>两种，其中写锁可以转换成读锁(锁降级)，但是读锁不能是写锁</p>
<ul>
<li>读锁是利用了AQS中的共享锁，而写锁则是独占锁</li>
<li>用高16位用来表示读锁<strong>占有的线程数量</strong>，用低16位表示写锁被同一个<strong>线程申请的次数</strong></li>
<li>利用Sync实现<ul>
<li>FairSync<ul>
<li>hasQueuedPredecessors() 查看前面是否有就绪的线程</li>
</ul>
</li>
<li>NonfairSync<ul>
<li>判断读锁是否要阻塞，是通过阻塞队列前面是不是写锁，如果是写锁则阻塞。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h2><blockquote>
<p>j.u.c包下的提供了线程安全的队列访问的接⼝，并发包下很多⾼级同步类的实现都是基于阻塞队列实现的<br>1、当阻塞队列进⾏插⼊数据时，如果队列已满，线程将会阻塞等待直到队列⾮满<br>2、从阻塞队列读数据时，如果队列为空，线程将会阻塞等待直到队列⾥⾯是⾮空的时候</p>
</blockquote>
<h3 id="ArrayBlockingQueue："><a href="#ArrayBlockingQueue：" class="headerlink" title="ArrayBlockingQueue："></a>ArrayBlockingQueue：</h3><blockquote>
<p>基于数组实现的⼀个阻塞队列，需要指定容量⼤⼩，FIFO先进先出顺序</p>
</blockquote>
<h3 id="LinkedBlockingQueue："><a href="#LinkedBlockingQueue：" class="headerlink" title="LinkedBlockingQueue："></a>LinkedBlockingQueue：</h3><blockquote>
<p>基于链表实现的⼀个阻塞队列，如果不指定容量⼤⼩，默认Integer.MAX_VALUE, FIFO先进先出顺序</p>
</blockquote>
<h3 id="PriorityBlockingQueue："><a href="#PriorityBlockingQueue：" class="headerlink" title="PriorityBlockingQueue："></a>PriorityBlockingQueue：</h3><blockquote>
<p>⼀个⽀持优先级的⽆界阻塞队列，默认情况下元素采⽤⾃然顺序升序排序，也可以⾃定义排序实现 java.lang.Comparable接⼝</p>
</blockquote>
<h3 id="DelayQueue："><a href="#DelayQueue：" class="headerlink" title="DelayQueue："></a>DelayQueue：</h3><blockquote>
<p>延迟队列，在指定时间才能获取队列元素的功能，队列头元素是最接近过期的元素，⾥⾯的对象必须实现 java.util.concurrent.Delayed 接⼝并实现<br>CompareTo和getDelay⽅法</p>
</blockquote>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><blockquote>
<p>并发队列ConcurrentLinkedQueue是基于链表实现的⽆界线程安全队列，采⽤FIFO进⾏排序<br>保证线程安全的三要素：原⼦、有序、可⻅性<br>1、底层结构是Node，链表头部和尾部节点是head和tail，使⽤节点变量和内部类属性使⽤<br>volatile声明保证了有序和可⻅性<br>2、插⼊、移除、更新操作使⽤CAS⽆锁操作，保证了原⼦性</p>
</blockquote>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote>
<p>提⾼系统资源的使⽤率，同时避免过多资源竞争，避免堵塞，且可以定时定期执⾏、单线程、并发数控制，配置任务过多任务后的拒绝策略等功能</p>
</blockquote>
<h3 id="线程池分类"><a href="#线程池分类" class="headerlink" title="线程池分类"></a>线程池分类</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><blockquote>
<p>⼀个定⻓线程池，可控制线程最⼤并发数</p>
</blockquote>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><blockquote>
<p>⼀个可缓存线程池</p>
</blockquote>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><blockquote>
<p>⼀个单线程化的线程池，⽤唯⼀的⼯作线程来执⾏任务</p>
</blockquote>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><blockquote>
<p>⼀个定⻓线程池，⽀持定时/周期性任务执⾏</p>
</blockquote>
<h3 id="线程池踩坑"><a href="#线程池踩坑" class="headerlink" title="线程池踩坑"></a>线程池踩坑</h3><h4 id="推荐ThreadPoolExecutor的⽅式原因"><a href="#推荐ThreadPoolExecutor的⽅式原因" class="headerlink" title="推荐ThreadPoolExecutor的⽅式原因"></a>推荐ThreadPoolExecutor的⽅式原因</h4><ol>
<li>newFixedThreadPool和newSingleThreadExecutor:<blockquote>
<p>队列使⽤LinkedBlockingQueue，队列⻓度为 Integer.MAX_VALUE，可能造成堆积，导致OOM</p>
</blockquote>
</li>
<li>newScheduledThreadPool和newCachedThreadPool:         <blockquote>
<p>线程池⾥⾯允许最⼤的线程数是Integer.MAX_VALUE，可能会创建过多线程，导致OOM</p>
</blockquote>
<h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><h4 id="corePoolSize："><a href="#corePoolSize：" class="headerlink" title="corePoolSize："></a>corePoolSize：</h4><blockquote>
<p>核⼼线程数，线程池也会维护线程的最少数量，默认情况下核⼼线程会⼀直存活，即使没有任务也不会受存keepAliveTime控制<br>坑：在刚创建线程池时线程不会⽴即启动，到有任务提交时才开始创建线程并逐步线程数⽬达到corePoolSize</p>
</blockquote>
<h4 id="maximumPoolSize："><a href="#maximumPoolSize：" class="headerlink" title="maximumPoolSize："></a>maximumPoolSize：</h4><blockquote>
<p>线程池维护线程的最⼤数量，超过将被阻塞<br>坑：当核⼼线程满，且阻塞队列也满时，才会判断当前线程数是否⼩于最⼤线程数，才决定是否创建新线程</p>
</blockquote>
<h4 id="keepAliveTime："><a href="#keepAliveTime：" class="headerlink" title="keepAliveTime："></a>keepAliveTime：</h4><blockquote>
<p>⾮核⼼线程的闲置超时时间，超过这个时间就会被回收，直到线程数量等于corePoolSize</p>
</blockquote>
<h4 id="unit："><a href="#unit：" class="headerlink" title="unit："></a>unit：</h4><blockquote>
<p>指定keepAliveTime的单位，如TimeUnit.SECONDS、TimeUnit.MILLISECONDS</p>
</blockquote>
<h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue:"></a>workQueue:</h4><blockquote>
<p>线程池中的任务队列,常⽤的是 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue</p>
</blockquote>
<h4 id="threadFactory："><a href="#threadFactory：" class="headerlink" title="threadFactory："></a>threadFactory：</h4><blockquote>
<p>创建新线程时使⽤的⼯⼚</p>
</blockquote>
<h4 id="handler"><a href="#handler" class="headerlink" title="handler:"></a>handler:</h4><blockquote>
<p>RejectedExecutionHandler是⼀个接⼝且只有⼀个⽅法,线程池中的数量⼤于maximumPoolSize，对拒绝任务的处理策略，默认有4种策略AbortPolicy、<br>CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy</p>
</blockquote>
</li>
</ol>
<h2 id="ThreadLoacl"><a href="#ThreadLoacl" class="headerlink" title="ThreadLoacl"></a>ThreadLoacl</h2><p><img src="https://i.loli.net/2020/07/28/nFbdPvGTR7IjLct.jpg" alt="ThreadLocal数据结构.jpg"></p>
<ul>
<li>每一个线程自己维护了ThreadLocalMap<ul>
<li>ThreadLocalMap的key是ThreadLocal对象本身 （是弱引用，检测到就会gc回收掉）</li>
<li>Value则是ThreadLocal中的值</li>
</ul>
</li>
<li>ThreadLoaclmap的桶的算法<ul>
<li>int i = key.threadLocalHashCode &amp; (len-1);<ul>
<li>key则是threadlocal</li>
<li>threadLocalHashCode是threadlocal自己维护的</li>
<li>threadLocalHashCode 是 每次添加一个对象后内部再加上一个斐波那契数 </li>
<li>之后与容量做与运算，得到桶的位置</li>
</ul>
</li>
</ul>
</li>
<li>ThreadLocalMap.set()其实有四种情况需要考虑<ol>
<li>通过hash计算得到的槽的数据是为空的（key为空，entry为空，也就是没有被占用）<ul>
<li>直接插入槽位</li>
</ul>
</li>
<li>通过hash计算发现得到的槽位的数据不为空，key不为空，entry也不为空，同时hash计算的key和找到的key是一样的<ul>
<li>直接在槽位上更新数据</li>
</ul>
</li>
<li>通过hash计算发现得到的槽位的数据都不为空，且key是不一样的，同时在找到key，entry为空的槽位之前，没有遇到key过期，entry不为空的情况<ul>
<li><strong>由于threadlocalmap的hash冲突是向后找空插入的</strong></li>
<li>因此直接向后查找，找到空的槽位直接插入就好</li>
<li>如果是向后查找的过程中有了key相同的，也可以直接更新数据</li>
</ul>
</li>
<li>通过hash计算发现得到的槽位的数据都不为空，且在找到key，entry为空的槽位之前，遇到了key过期，entry不为空的情况<ul>
<li>由于ThreadlocalMap的key是维护的弱引用，因此会出现key被回收的情况</li>
<li>会启用探测<br>  <img src="https://i.loli.net/2020/08/11/2kxVwjBRP9MFYWu.jpg" alt="探测A.jpg"><br>  往后遍历过程中，散列数组下标为7位置对应的Entry数据key为null，表明此数据key值已经被垃圾回收掉了<ol>
<li>执行replaceStaleEntry()<ul>
<li>初始化探测式清理过期数据扫描的开始位置：slotToExpunge = staleSlot = 7</li>
</ul>
</li>
<li>以stableSlot为起点，向前进行探测<ul>
<li>如果向前探测的过程中，遇到了key为null的，entry不为null的，也就是key过期的值，则更新slotToExpunge的值</li>
<li>直到遇到空槽位，也就是key，entry都为null的位置，则停止向前的探测</li>
</ul>
</li>
<li>之后执行stableSlot向后的探测 （又分成两钟情况）<ul>
<li>找到了key值相同的槽位<ul>
<li>则直接更新数据，且更新stableslot的下标</li>
<li>然后进行过期清理，从slotToExpunge到staleSlot进行清理<br>  <img src="https://i.loli.net/2020/08/11/mcUnC3X57jbKNAq.jpg" alt="探测B.jpg"></li>
</ul>
</li>
<li>没有找到key值相同的槽位<ul>
<li>则向后继续查找，直到直到空槽位（key，entry都为空）则停止<br>  <img src="https://i.loli.net/2020/08/11/iIYeDugKmyVtTkd.jpg" alt="探测C.jpg"></li>
<li>之后再执行过期清理，从slotToExpunge到staleSlot进行清理</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li>ThreadLocalmap清理过程<ul>
<li>cleanSomeSlots（）启发式清理<ul>
<li>启发式清理就是把i后移，直到全部探测清理完毕</li>
</ul>
</li>
<li>expungeStaleEntries（）探测式清理<ul>
<li>从index向后探测，如果是过期key则删除，同时size–，直到遍历到空槽</li>
<li>之后对散列表重hash，把之前因为hash冲突而放到后面的key-value放到更接近槽的位置</li>
</ul>
</li>
<li>实际上是cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</li>
</ul>
</li>
</ul>
<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>AtomicInteger 为例</p>
<ul>
<li>volatile保证了数据的可见性，但是没有保证原子性</li>
<li>因此使用CAS保证了volatile的原子性，也就是compareAndSwapInt()方法实现了CAS</li>
</ul>
</the>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://runindark.com/2020/07/27/2020秋招/并发编程/" data-id="ckdhpippo0001t0v1pqgg185x" class="article-share-link">Share</a>
      
    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/08/07/2020秋招/操作系统/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            操作系统
          
        </div>
      </a>
    
    
      <a href="/2020/07/18/2020秋招/IO/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">IO复习总结</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 Cat&#39;s blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>

<aside class="sidebar sidebar-specter">
  
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Cat&#39;s blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

</body>
</html>