<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Redis复习总结 |
    
    Cat&#39;s blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  

<article id="post-2020秋招/Redis" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Redis复习总结
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2020/07/12/2020秋招/Redis/" class="article-date">
  <time datetime="2020-07-12T02:36:30.624Z" itemprop="datePublished">2020-07-12</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/秋招面试/">秋招面试</a>
  </div>

      </div>
    

    
      
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="Redis内存模型"><a href="#Redis内存模型" class="headerlink" title="Redis内存模型"></a>Redis内存模型</h2><h3 id="Redis内存分配"><a href="#Redis内存分配" class="headerlink" title="Redis内存分配"></a>Redis内存分配</h3><ul>
<li>数据 ：Redis存储的数据对象 字符串、哈希、列表、集合、有序集合 </li>
<li>进程本身所需内存 ： Redis进程自己运行所需要的内存，比如代码，占用内存，常量池等</li>
<li>缓存内存： <ul>
<li>客户端缓冲区 ： 连接客户端输入输出的缓存</li>
<li>复制积压缓冲区： 在主从同步时，非全量复制时，所需要的缓存区</li>
<li>复制积压缓冲区： AOF写入时的缓存</li>
</ul>
</li>
<li>内存碎片：内存碎片是Redis在分配、回收物理内存过程中产生的</li>
</ul>
<h3 id="Redis内存分配器-（jemalloc）"><a href="#Redis内存分配器-（jemalloc）" class="headerlink" title="Redis内存分配器 （jemalloc）"></a>Redis内存分配器 （jemalloc）</h3><ul>
<li>jemalloc 将空间分为 小（Small）、大（Large）、巨大（Huge）三种<br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001126509-2023165562.png" alt="jemalloc"></li>
</ul>
<h3 id="Redis内存统计"><a href="#Redis内存统计" class="headerlink" title="Redis内存统计"></a>Redis内存统计</h3><ul>
<li>used_memory （Redis内存分配器分配的内存）<blockquote>
<p>存储的数据的内存</p>
</blockquote>
</li>
<li>used_memory_rss （Redis占操作系统的内存）<blockquote>
<p>包括存储的数据内存还有内存碎片以及Redis本身占用内存</p>
</blockquote>
</li>
</ul>
<h3 id="Redis数据的存储过程"><a href="#Redis数据的存储过程" class="headerlink" title="Redis数据的存储过程"></a>Redis数据的存储过程</h3><ul>
<li><p>RedisObject<br><img src="https://i.loli.net/2020/07/12/xQOXjFEvNzgoaf8.jpg" alt="RedisObject"></p>
</li>
<li><p>数据类型</p>
<ul>
<li><p>SDS<br>  <img src="https://i.loli.net/2020/07/12/hpUmPNkzaR9e4n1.jpg" alt="SDS.jpg"></p>
<ul>
<li>空间预分配<br>  sdscat =》给字符串后面再拼接一个字符串<br>  当sdscat 之后内存小于 1M，字符串长度*2+1 （’\0’）<br>  当sdscat 之后内存大于 1M, 字符串长度 + 1M + 1（’\0’）</li>
<li>空间懒分配<br>  如果sdstrim（减少字符串），则不急着回收空间，下次如果需要添加长度，直接使用多余的空间。</li>
</ul>
</li>
<li><p>List<br>  <img src="https://i.loli.net/2020/07/12/AcZDGyX5IJnYl6h.jpg" alt="List.jpg"></p>
</li>
<li>Hash<br>  <img src="https://i.loli.net/2020/07/12/Di1vVNXMo83Zfsb.jpg" alt="hash.jpg"><br>  在字典中存在dictht数组，表明是两个hash表<br>  ht[1]的容量是ht[0]的两倍<br>  把ht[0]中的元素rehash复制到ht[1]中</li>
<li>set</li>
<li>zset</li>
</ul>
</li>
<li><p>数据存储过程</p>
<blockquote>
<p>RedisObject -&gt; 具体的数据类型</p>
</blockquote>
</li>
</ul>
<h3 id="Redis内存回收策略"><a href="#Redis内存回收策略" class="headerlink" title="Redis内存回收策略"></a>Redis内存回收策略</h3><ul>
<li>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令(大部分的写入指令，但DEL和几个例外)</li>
<li>allkeys-lru:尝试回收最少使用的键(LRU) ，使得新添加的数据有空间存放。</li>
<li>volatile-lru:尝试回收最少使用的键(LRU) ，但仅限于在过期集合的键,使得新添加的数据有空间存放。</li>
<li>allkeys-random:回收随机的键使得新添加的数据有空间存放。</li>
<li>volatile-random:回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</li>
<li>volatile-ttl:回收在过期集合的键，并且优先回收存活时间(TTL) 较短的键，使得新添加的数据有空间存放。</li>
</ul>
<h2 id="Redis的原子性保证"><a href="#Redis的原子性保证" class="headerlink" title="Redis的原子性保证"></a>Redis的原子性保证</h2><ul>
<li>单指令原子性<blockquote>
<p>Redis是单线程的，一个线程只能执行一个指令，因此具有原子性</p>
</blockquote>
</li>
<li>Lua原子性<blockquote>
<p>官方解释来看，Lua脚本和Redis的事务一样，被exec/mutl包裹，redis保证每次只能执行一个lua脚本，别的lua脚本不会被执行，由此保证了原子性。</p>
</blockquote>
</li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h3><ul>
<li>setnx 不存在key才可以操作</li>
<li>set 与set相反<h3 id="锁续期"><a href="#锁续期" class="headerlink" title="锁续期"></a>锁续期</h3><blockquote>
<p>利用<strong>Redission</strong>，当成功获取一个锁的时候，产生看门狗（watch dog）进行锁续期，一般来说是10s检查一次<br>核心在于Redission使用了Lua脚本</p>
</blockquote>
<h3 id="分布式锁的极端情况"><a href="#分布式锁的极端情况" class="headerlink" title="分布式锁的极端情况"></a>分布式锁的极端情况</h3><blockquote>
<p>当服务A从Master中获取锁，A获取锁成功后，还没来得及同步到从节点，master挂了，从节点<br>重新成为master，服务B过来后，发现该锁还未被获取，于是锁被重复获取</p>
</blockquote>
</li>
</ul>
<h2 id="Redis的冷备和热备"><a href="#Redis的冷备和热备" class="headerlink" title="Redis的冷备和热备"></a>Redis的冷备和热备</h2><ul>
<li>热备 - AOF<ul>
<li>数据文件比RDB更大</li>
<li>每秒都去持久化，数据丢失少</li>
<li>存储的文件是每条的指令</li>
<li>先执行命令，之后才存储到磁盘（由于redis不是完全维护，只有执行以后才知道结果，单纯的语法监测是无用的）</li>
<li>bgrewriteaof 可以对aof的日志文件进行瘦身，也就是fork一个子进程把原来的日志全部转化成redis命令存到一个新的日志中执行</li>
</ul>
</li>
<li>冷备 - RDB<ul>
<li>需要fork子进程，数据量大的话会导致几秒的延迟，对于秒杀场景危险</li>
<li>是段时间保存数据，一旦发生宕机，数据丢失较多</li>
<li>RDB恢复的更快</li>
</ul>
</li>
</ul>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="哨兵监控"><a href="#哨兵监控" class="headerlink" title="哨兵监控"></a>哨兵监控</h3><ul>
<li>主观下线<blockquote>
<p>从节点无法ping通master，则主观认为master挂了</p>
</blockquote>
</li>
<li>客观下线（主节点的下线）<blockquote>
<p>多个从节点都无法ping通master，则从节点们客观认为master挂了，<strong>需要重新选举</strong></p>
</blockquote>
</li>
<li>定时任务</li>
<li>错误转移<ul>
<li>过滤不健康的节点</li>
<li>选举出新的节点</li>
<li>让从节点成为主节点</li>
<li>让原来的master成为从节点</li>
</ul>
</li>
<li>哨兵选举<blockquote>
<p>Raft : 谁先申请成为主节点，谁就是主节点</p>
</blockquote>
</li>
</ul>
<h2 id="主从同步的过程"><a href="#主从同步的过程" class="headerlink" title="主从同步的过程"></a>主从同步的过程</h2><ol>
<li>从节点向master发送slaveof获取主节点的信息<ul>
<li>定时任务获取主节点信息</li>
<li>从节点去ping主节点，主节点则返回pang和runid等信息</li>
</ul>
</li>
<li>从节点根据保存的Master runid判断是不是第一次同步复制</li>
<li>如果是第一次psync?-1，则进行全量复制<ul>
<li>全量复制址启用用RDB生成快照<ul>
<li>启动RDB会fork子进程，则子进程运行期间，新命令进入到缓存区</li>
</ul>
</li>
<li>RDB生成到磁盘，之后在读取到内存，再进行数据同步<ul>
<li>快照内容同步完以后，再将缓存的命令缓存到从节点</li>
</ul>
</li>
</ul>
</li>
<li>如果不是第一次，则进行部分复制，从节点向master发送Psync runid offset</li>
<li>Master收到命令后会查看，runid是否一致，之后查看偏移量offset是否超过复制积压缓存区<ul>
<li>如果偏移量超过复制积压缓存区，则err，进行全量复制</li>
<li>如果未超过，则offset+偏移量+命令长度进行部分复制 </li>
</ul>
</li>
</ol>
<h3 id="复制积压缓存区"><a href="#复制积压缓存区" class="headerlink" title="复制积压缓存区"></a>复制积压缓存区</h3><blockquote>
<p>在主从同步的期间，仍然会有写命令在执行，这时命令在写入主节点的同时还会写入<strong>复制积压缓存区</strong>,同时记录偏移量，如果这期间缓存的命令过多，则没必要再进行部分复制，直接进行全量复制即可</p>
</blockquote>
<h2 id="缓存的常见问题"><a href="#缓存的常见问题" class="headerlink" title="缓存的常见问题"></a>缓存的常见问题</h2><ol>
<li>缓存穿透<ul>
<li>恶意访问不存在的数据，导致打入数据库</li>
<li>增加认证（接口访问功能）</li>
</ul>
</li>
<li>缓存击穿<ul>
<li>某热点数据突然失效，打入数据库</li>
<li>设置null值</li>
</ul>
</li>
<li>缓存雪崩<ul>
<li>大量数据同时失效</li>
<li>设置随机时间种子</li>
</ul>
</li>
</ol>
<h2 id="redis中的-HyperLogLog"><a href="#redis中的-HyperLogLog" class="headerlink" title="redis中的  HyperLogLog"></a>redis中的  HyperLogLog</h2><h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><blockquote>
<p>访问网站的独立访客UV，例如每个访客访问某网站，访问多次，其实只能算作一次。<br>那么带来的直接问题是，如果每个用户都占用一个key，那么就会产生数据量巨大的问题</p>
</blockquote>
<h3 id="解决方案拆分"><a href="#解决方案拆分" class="headerlink" title="解决方案拆分"></a>解决方案拆分</h3><ul>
<li>借鉴数据库的b+树<blockquote>
<p>解决了插入和查找的问题，但是解决不了数据量大，占用内存的问题</p>
</blockquote>
</li>
<li>bitmap<blockquote>
<p>如果是一亿个数据，那么100_000_000(数据量)/ 8（字节）/ 1024（KB）/ 1024（MB） ≈ 12 M</p>
</blockquote>
</li>
</ul>
<h3 id="概率统计"><a href="#概率统计" class="headerlink" title="概率统计"></a>概率统计</h3><blockquote>
<p>可以看到bitmap已经是属于极致的优化了，但是还是不够，不管怎么说，为了一个统计功能，单一个对象就是12M,但是再多一些还是会很多<br>则使用 “估计的方法可能会好一些”，则使用 <strong>概率统计</strong></p>
</blockquote>
<h4 id="redis的实现"><a href="#redis的实现" class="headerlink" title="redis的实现"></a>redis的实现</h4><p>HLL中实际存储的是一个长度为mm的大数组SS，将待统计的数据集合划分成mm组，每组根据算法记录一个统计值存入数组中。数组的大小mm由算法实现方自己确定，redis中这个数组的大小是16834（2的14次方），m越大，基数统计的误差越小，但需要的内存空间也越大<br><img src="https://ae01.alicdn.com/kf/H6a46aeef20244412887a3a31173bebcc1.jpg" alt="hll的redis过程.jpg"></p>
<h4 id="hll的实现原理-伯努利试验"><a href="#hll的实现原理-伯努利试验" class="headerlink" title="hll的实现原理 - 伯努利试验"></a>hll的实现原理 - 伯努利试验</h4><ul>
<li>伯努利实现也就是掷硬币实现，那么我们说假设存在第一次掷出正面所用的最多的次数为kmax，则可以提出假设</li>
<li><p>假设：</p>
<ul>
<li>掷出n次正面所用的次数一定少于n*kmax</li>
<li>掷出n次正面所用的次数一定有那么一次是等于kmax的（其实正好是1减去上面的概率）<br><img src="https://i.loli.net/2020/07/23/1YSsrdghimzlXK8.jpg" alt="伯努利假设.jpg"></li>
</ul>
</li>
<li><p>推断：</p>
<ul>
<li>那么当n远大于kmax的时候，那么第一个不成立</li>
<li>那么当n远小于kmax的时候，那么第二个不成立</li>
</ul>
</li>
<li><p>继续推断</p>
<ul>
<li>那么用kmax推断n的次数貌似是最好的情况<br>则 n = 2^kmax</li>
</ul>
</li>
<li><p>继续思考</p>
<ul>
<li>如果很大的一段二进制，只用一个kmax误差比较大</li>
<li>那么把一段很大的分开估计就好了，因此有<strong>分桶原理</strong>，也就是redis过程中对应的数组S的m</li>
</ul>
</li>
</ul>
<h3 id="稀疏存储和密集存储"><a href="#稀疏存储和密集存储" class="headerlink" title="稀疏存储和密集存储"></a>稀疏存储和密集存储</h3><ol>
<li>密集存储就是按照原来16834来存储</li>
<li>稀疏存储就是连续两个0作为统计接下来的 6bit 整数值加 1 <h3 id="hll对象头"><a href="#hll对象头" class="headerlink" title="hll对象头"></a>hll对象头</h3><pre><code class="c"><span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> {</span>
 <span class="keyword">char</span> magic[<span class="number">4</span>];      <span class="comment">/* 魔术字符串"HYLL" */</span>
 <span class="keyword">uint8_t</span> encoding;   <span class="comment">/* 存储类型 HLL_DENSE or HLL_SPARSE. */</span>
 <span class="keyword">uint8_t</span> notused[<span class="number">3</span>]; <span class="comment">/* 保留三个字节未来可能会使用 */</span>
 <span class="keyword">uint8_t</span> card[<span class="number">8</span>];    <span class="comment">/* 总计数缓存 */</span>
 <span class="keyword">uint8_t</span> registers[]; <span class="comment">/* 所有桶的计数器 */</span>
};
</code></pre>
</li>
</ol>
<h2 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h2><h3 id="PubSub"><a href="#PubSub" class="headerlink" title="PubSub"></a>PubSub</h3><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>没有ack确认信息，不能保证数据连续</li>
<li><p>不持久化消息</p>
<h4 id="PubSub-1"><a href="#PubSub-1" class="headerlink" title="PubSub"></a>PubSub</h4><p><img src="https://i.loli.net/2020/07/24/6jHO7DIZMxAkvGL.jpg" alt="redis_PubSub订阅模式.jpg"></p>
</li>
<li><p>精确匹配</p>
<blockquote>
<p>订阅某个精确频道，则需要精确的知道这个频道的key值，才可以订阅，比如client订阅redis频道<br><img src="https://i.loli.net/2020/07/24/MtX9ZLSxukBohrY.jpg" alt="redis_发布订阅_channel.jpg"></p>
</blockquote>
</li>
<li>前缀多匹配<blockquote>
<p>订阅某种类型的全部频道，也就是说知道某频道类型的前缀，则可以订阅该类型下的全部频道，例如<strong>client订阅redis.*的频道</strong>,<br>则会<strong>订阅redis.log,redis.rdb等一系列符合redis.*的一系列前缀频道</strong><br><img src="https://i.loli.net/2020/07/24/CSMaz6mKxd3svFq.jpg" alt="redis_patten_多匹配原理.jpg"></p>
</blockquote>
</li>
</ul>
<h4 id="steam"><a href="#steam" class="headerlink" title="steam"></a>steam</h4><p><img src="https://i.loli.net/2020/07/24/ZM5drvlSyHApVOF.jpg" alt="redis_steam.jpg"></p>
<ul>
<li>Consumer Group：消费者组<blockquote>
<p>多个consumer需要某消息的一个群组</p>
</blockquote>
</li>
<li>last_delivered_id：消息游标<blockquote>
<p>群组需要哪个消息，则指向这个消息的id,消息 ID 如果是由 XADD 命令返回自动创建的话，那么它的格式会像这样：timestampInMillis-sequence (毫秒时间戳-序列号)，例如 1527846880585-5，它表示当前的消息是在毫秒时间戳 1527846880585 时产生的，并且是该毫秒内产生的第 5 条消息。</p>
</blockquote>
</li>
<li>pending_ids：状态数组<blockquote>
<p>记录未确认ack的消息的数组，如果客户端发送ack则数组中的内容减少，如果不发送则会一直增加</p>
</blockquote>
</li>
</ul>
</the>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://runindark.com/2020/07/12/2020秋招/Redis/" data-id="ckciz9zzu0000rov1vbub3svr" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/07/12/2020秋招/框架/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            框架复习总结
          
        </div>
      </a>
    
    
      <a href="/2020/06/28/2020秋招/jvm/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">Jvm复习总结</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 Cat&#39;s blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>

<aside class="sidebar sidebar-specter">
  
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Cat&#39;s blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

</body>
</html>