<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Redis复习总结 |
    
    Cat&#39;s blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  

<article id="post-2020秋招/Redis" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Redis复习总结
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2020/07/12/2020秋招/Redis/" class="article-date">
  <time datetime="2020-07-12T02:36:30.624Z" itemprop="datePublished">2020-07-12</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/秋招面试/">秋招面试</a>
  </div>

      </div>
    

    
      
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="Redis内存模型"><a href="#Redis内存模型" class="headerlink" title="Redis内存模型"></a>Redis内存模型</h2><h3 id="Redis内存分配"><a href="#Redis内存分配" class="headerlink" title="Redis内存分配"></a>Redis内存分配</h3><ul>
<li>数据 ：Redis存储的数据对象 字符串、哈希、列表、集合、有序集合 </li>
<li>进程本身所需内存 ： Redis进程自己运行所需要的内存，比如代码，占用内存，常量池等</li>
<li>缓存内存： <ul>
<li>客户端缓冲区 ： 连接客户端输入输出的缓存</li>
<li>复制积压缓冲区： 在主从同步时，非全量复制时，所需要的缓存区</li>
<li>复制积压缓冲区： AOF写入时的缓存</li>
</ul>
</li>
<li>内存碎片：内存碎片是Redis在分配、回收物理内存过程中产生的</li>
</ul>
<h3 id="Redis内存分配器-（jemalloc）"><a href="#Redis内存分配器-（jemalloc）" class="headerlink" title="Redis内存分配器 （jemalloc）"></a>Redis内存分配器 （jemalloc）</h3><ul>
<li>jemalloc 将空间分为 小（Small）、大（Large）、巨大（Huge）三种<br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001126509-2023165562.png" alt=""></li>
</ul>
<h3 id="Redis内存统计"><a href="#Redis内存统计" class="headerlink" title="Redis内存统计"></a>Redis内存统计</h3><ul>
<li>used_memory （Redis内存分配器分配的内存）<blockquote>
<p>存储的数据的内存</p>
</blockquote>
</li>
<li>used_memory_rss （Redis占操作系统的内存）<blockquote>
<p>包括存储的数据内存还有内存碎片以及Redis本身占用内存</p>
</blockquote>
</li>
</ul>
<h3 id="Redis数据的存储过程"><a href="#Redis数据的存储过程" class="headerlink" title="Redis数据的存储过程"></a>Redis数据的存储过程</h3><ul>
<li><p>RedisObject<br><img src="https://i.loli.net/2020/07/12/xQOXjFEvNzgoaf8.jpg" alt="RedisObject"></p>
</li>
<li><p>数据类型</p>
<ul>
<li><p>SDS<br>  <img src="https://i.loli.net/2020/07/12/hpUmPNkzaR9e4n1.jpg" alt="SDS.jpg"></p>
<ul>
<li>空间预分配<br>  sdscat =》给字符串后面再拼接一个字符串<br>  当sdscat 之后内存小于 1M，字符串长度*2+1 （’\0’）<br>  当sdscat 之后内存大于 1M, 字符串长度 + 1M + 1（’\0’）</li>
<li>空间懒分配<br>  如果sdstrim（减少字符串），则不急着回收空间，下次如果需要添加长度，直接使用多余的空间。</li>
</ul>
</li>
<li><p>List<br>  <img src="https://i.loli.net/2020/07/12/AcZDGyX5IJnYl6h.jpg" alt="List.jpg"></p>
</li>
<li>Hash<br>  <img src="https://i.loli.net/2020/07/12/Di1vVNXMo83Zfsb.jpg" alt="hash.jpg"><br>  在字典中存在dictht数组，表明是两个hash表<br>  ht[1]的容量是ht[0]的两倍<br>  把ht[0]中的元素rehash复制到ht[1]中</li>
<li>set</li>
<li>zset</li>
</ul>
</li>
<li><p>数据存储过程</p>
<blockquote>
<p>RedisObject -&gt; 具体的数据类型</p>
</blockquote>
</li>
</ul>
<h3 id="Redis内存回收策略"><a href="#Redis内存回收策略" class="headerlink" title="Redis内存回收策略"></a>Redis内存回收策略</h3><ul>
<li>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令(大部分的写入指令，但DEL和几个例外)</li>
<li>allkeys-lru:尝试回收最少使用的键(LRU) ，使得新添加的数据有空间存放。</li>
<li>volatile-lru:尝试回收最少使用的键(LRU) ，但仅限于在过期集合的键,使得新添加的数据有空间存放。</li>
<li>allkeys-random:回收随机的键使得新添加的数据有空间存放。</li>
<li>volatile-random:回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</li>
<li>volatile-ttl:回收在过期集合的键，并且优先回收存活时间(TTL) 较短的键，使得新添加的数据有空间存放。</li>
</ul>
<h2 id="Redis的原子性保证"><a href="#Redis的原子性保证" class="headerlink" title="Redis的原子性保证"></a>Redis的原子性保证</h2><ul>
<li>单指令原子性<blockquote>
<p>Redis是单线程的，一个线程只能执行一个指令，因此具有原子性</p>
</blockquote>
</li>
<li>Lua原子性<blockquote>
<p>官方解释来看，Lua脚本和Redis的事务一样，被exec/mutl包裹，redis保证每次只能执行一个lua脚本，别的lua脚本不会被执行，由此保证了原子性。</p>
</blockquote>
</li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h3><ul>
<li>setnx 不存在key才可以操作</li>
<li>set 与set相反<h3 id="锁续期"><a href="#锁续期" class="headerlink" title="锁续期"></a>锁续期</h3><blockquote>
<p>利用<strong>Redission</strong>，当成功获取一个锁的时候，产生看门狗（watch dog）进行锁续期，一般来说是10s检查一次<br>核心在于Redission使用了Lua脚本</p>
</blockquote>
<h3 id="分布式锁的极端情况"><a href="#分布式锁的极端情况" class="headerlink" title="分布式锁的极端情况"></a>分布式锁的极端情况</h3><blockquote>
<p>当服务A从Master中获取锁，A获取锁成功后，还没来得及同步到从节点，master挂了，从节点<br>重新成为master，服务B过来后，发现该锁还未被获取，于是锁被重复获取</p>
</blockquote>
<h2 id="Redis的冷备和热备"><a href="#Redis的冷备和热备" class="headerlink" title="Redis的冷备和热备"></a>Redis的冷备和热备</h2></li>
<li>热备 - AOF<ul>
<li>数据文件比RDB更大</li>
<li>每秒都去持久化，数据丢失少</li>
<li>存储的文件是每条的指令</li>
</ul>
</li>
<li>冷备 - RDB<ul>
<li>需要fork子进程，数据量大的话会导致几秒的延迟，对于秒杀场景危险</li>
<li>是段时间保存数据，一旦发生宕机，数据丢失较多</li>
<li>RDB恢复的更快</li>
</ul>
</li>
</ul>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="哨兵监控"><a href="#哨兵监控" class="headerlink" title="哨兵监控"></a>哨兵监控</h3><ul>
<li>主观下线<blockquote>
<p>从节点无法ping通master，则主观认为master挂了</p>
</blockquote>
</li>
<li>客观下线（主节点的下线）<blockquote>
<p>多个从节点都无法ping通master，则从节点们客观认为master挂了，<strong>需要重新选举</strong></p>
</blockquote>
</li>
<li>定时任务</li>
<li>错误转移<ul>
<li>过滤不健康的节点</li>
<li>选举出新的节点</li>
<li>让从节点成为主节点</li>
<li>让原来的master成为从节点</li>
</ul>
</li>
<li>哨兵选举<blockquote>
<p>Raft : 谁先申请成为主节点，谁就是主节点</p>
</blockquote>
</li>
</ul>
<h2 id="主从同步的过程"><a href="#主从同步的过程" class="headerlink" title="主从同步的过程"></a>主从同步的过程</h2><ol>
<li>从节点向master发送slaveof获取主节点的信息<ul>
<li>定时任务获取主节点信息</li>
<li>从节点去ping主节点，主节点则返回pang和runid等信息</li>
</ul>
</li>
<li>从节点根据保存的Master runid判断是不是第一次同步复制</li>
<li>如果是第一次psync?-1，则进行全量复制<ul>
<li>全量复制址启用用RDB生成快照<ul>
<li>启动RDB会fork子进程，则子进程运行期间，新命令进入到缓存区</li>
</ul>
</li>
<li>RDB生成到磁盘，之后在读取到内存，再进行数据同步<ul>
<li>快照内容同步完以后，再将缓存的命令缓存到从节点</li>
</ul>
</li>
</ul>
</li>
<li>如果不是第一次，则进行部分复制，从节点向master发送Psync runid offset</li>
<li>Master收到命令后会查看，runid是否一致，之后查看偏移量offset是否超过复制积压缓存区<ul>
<li>如果偏移量超过复制积压缓存区，则err，进行全量复制</li>
<li>如果未超过，则offset+偏移量+命令长度进行部分复制 </li>
</ul>
</li>
</ol>
<h3 id="复制积压缓存区"><a href="#复制积压缓存区" class="headerlink" title="复制积压缓存区"></a>复制积压缓存区</h3><blockquote>
<p>在主从同步的期间，仍然会有写命令在执行，这时命令在写入主节点的同时还会写入<strong>复制积压缓存区</strong>,同时记录偏移量，如果这期间缓存的命令过多，则没必要再进行部分复制，直接进行全量复制即可</p>
</blockquote>
<h2 id="缓存的常见问题"><a href="#缓存的常见问题" class="headerlink" title="缓存的常见问题"></a>缓存的常见问题</h2><ol>
<li>缓存穿透<ul>
<li>恶意访问不存在的数据，导致打入数据库</li>
<li>增加认证（接口访问功能）</li>
</ul>
</li>
<li>缓存击穿<ul>
<li>某热点数据突然失效，打入数据库</li>
<li>设置null值</li>
</ul>
</li>
<li>缓存雪崩<ul>
<li>大量数据同时失效</li>
<li>设置随机时间种子</li>
</ul>
</li>
</ol>
</the>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://runindark.com/2020/07/12/2020秋招/Redis/" data-id="ckciz9zzu0000rov1vbub3svr" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/07/12/2020秋招/Spring/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            框架复习总结
          
        </div>
      </a>
    
    
      <a href="/2020/06/28/2020秋招/jvm/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">Jvm复习总结</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 Cat&#39;s blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>

<aside class="sidebar sidebar-specter">
  
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Cat&#39;s blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

</body>
</html>