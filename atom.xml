<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cat&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://runindark.com/"/>
  <updated>2019-01-01T10:03:50.793Z</updated>
  <id>http://runindark.com/</id>
  
  <author>
    <name>夜小猫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springboor2.0x中关于数据连接池Druid的连接</title>
    <link href="http://runindark.com/2019/01/01/SpringBoot-07-Mybatis%E6%95%B4%E5%90%88%EF%BC%88%E6%B3%A8%E8%A7%A3)/"/>
    <id>http://runindark.com/2019/01/01/SpringBoot-07-Mybatis整合（注解)/</id>
    <published>2019-01-01T09:25:14.276Z</published>
    <updated>2019-01-01T10:03:50.793Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><h3 id="Mybatis框架介绍"><a href="#Mybatis框架介绍" class="headerlink" title="Mybatis框架介绍"></a>Mybatis框架介绍</h3><blockquote><p>Mybatis是目前主流的轻量级框架，与之前的Hibernate相比，mybatis更加的灵活方便，并且Mybatis自身优化了starter来与springboot相适应<br>Mybatis支持两种书写风格，xml配置和注解两种，很多大公司依然使用的是xml，但是按照springboot的推荐，注解版更简单，更受青睐<br>（本节仍然使用druid连接池，配置文件依然使用yaml）<br><a id="more"></a></p></blockquote><the rest="" of="" contents="" |="" 余下全文=""><h3 id="maven依赖介绍"><a href="#maven依赖介绍" class="headerlink" title="maven依赖介绍"></a>maven依赖介绍</h3><blockquote><!--JDBC的配置--><pre><code>&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--数据库连接池 Druid--&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;</code></pre></blockquote><p>以上的三个依赖是之前我们配置druid的时候就已经搞定的依赖，下面这个mybatis依赖，注意看</p><blockquote> <dependency><br>           <groupid>org.mybatis.spring.boot</groupid><br>           <artifactid>mybatis-spring-boot-starter</artifactid><br>           <version>1.3.2</version><br> </dependency></blockquote><p>mybatis的依赖并不是由springboot官方写好的starter而是自身去适应springboot而开发的starter</p><h3 id="配置文件-yml"><a href="#配置文件-yml" class="headerlink" title="配置文件 .yml"></a>配置文件 .yml</h3><p>同样的，这里接着druid的配置就欧克了</p><p>— yaml<br>spring:<br>  datasource:<br>    username: root<br>    password: 123456<br>    url: jdbc:mysql://47.106.103.49/Etree<br>    driver-class-name: com.mysql.jdbc.Driver<br>    type: com.alibaba.druid.pool.DruidDataSource</p><pre><code>#   数据源其他配置initialSize: 5minIdle: 5maxActive: 20maxWait: 60000timeBetweenEvictionRunsMillis: 60000minEvictableIdleTimeMillis: 300000validationQuery: SELECT 1 FROM DUALtestWhileIdle: truetestOnBorrow: falsetestOnReturn: falsepoolPreparedStatements: true#   配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙filters: stat,wallmaxPoolPreparedStatementPerConnectionSize: 20useGlobalDataSourceStat: trueconnectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</code></pre><hr><h3 id="书写Mapper映射"><a href="#书写Mapper映射" class="headerlink" title="书写Mapper映射"></a>书写Mapper映射</h3><h4 id="1-首先我们需要创建一个model"><a href="#1-首先我们需要创建一个model" class="headerlink" title="1.首先我们需要创建一个model"></a>1.首先我们需要创建一个model</h4><p>这里我们是单词，所以创建eword 类<br>— java<br>public class eword {</p><pre><code>private String English ;private String Quality ;private String Meaning ;private String Level ;private String U_phon ;public String getEnglish() {    return English;}public void setEnglish(String english) {    English = english;}public String getQuality() {    return Quality;}public void setQuality(String quality) {    Quality = quality;}public String getMeaning() {    return Meaning;}public void setMeaning(String meaning) {    Meaning = meaning;}public String getLevel() {    return Level;}public void setLevel(String level) {    Level = level;}public String getU_phon() {    return U_phon;}public void setU_phon(String u_phon) {    U_phon = u_phon;}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><h4 id="2-创建mapper"><a href="#2-创建mapper" class="headerlink" title="2.创建mapper"></a>2.创建mapper</h4><p>注意mapper 的实现是需要interface接口的</p><p>— java<br>import org.apache.ibatis.annotations.Mapper;<br>import org.apache.ibatis.annotations.Result;<br>import org.apache.ibatis.annotations.Results;<br>import org.apache.ibatis.annotations.Select;</p><p>@Mapper</p><p>public interface level4Word {</p><pre><code>@Results({        @Result(column=&quot;aw_english&quot;,property=&quot;English&quot;),        @Result(column=&quot;aw_meaning1&quot;,property=&quot;Meaning&quot;),        @Result(column = &quot;aw_vocQuality&quot;,property = &quot;Quality&quot;),        @Result(column = &quot;aw_level1&quot;,property = &quot;Level&quot;),        @Result(column = &quot;aw_UKphonogram&quot;,property = &quot;U_phon&quot;)        })@Select(&quot;select * from allword&quot;)public eword[] getWordByID() ;</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><h4 id="3-常用的注解"><a href="#3-常用的注解" class="headerlink" title="3.常用的注解"></a>3.常用的注解</h4><blockquote><p>@Insert  —  插入<br>@Delete  —  删除<br>@Update  —  更新<br>@Select  —  查找<br>@Param   —  入参<br>@Results —  字段统一 ： 这个部分其实和<resultmap>一样，就是为了解决字段名和实体类参数名不一样选用的<br>                         使用方法如上就是@Results（@Result（），····）</resultmap></p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt; &lt;/excerpt&gt;&lt;/p&gt;
&lt;h3 id=&quot;Mybatis框架介绍&quot;&gt;&lt;a href=&quot;#Mybatis框架介绍&quot; class=&quot;headerlink&quot; title=&quot;Mybatis框架介绍&quot;&gt;&lt;/a&gt;Mybatis框架介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Mybatis是目前主流的轻量级框架，与之前的Hibernate相比，mybatis更加的灵活方便，并且Mybatis自身优化了starter来与springboot相适应&lt;br&gt;Mybatis支持两种书写风格，xml配置和注解两种，很多大公司依然使用的是xml，但是按照springboot的推荐，注解版更简单，更受青睐&lt;br&gt;（本节仍然使用druid连接池，配置文件依然使用yaml）&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>springboor2.0x中关于数据连接池Druid的连接</title>
    <link href="http://runindark.com/2018/12/27/springBoot-06-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E6%B1%A0Druid/"/>
    <id>http://runindark.com/2018/12/27/springBoot-06-连接数据池Druid/</id>
    <published>2018-12-27T14:17:41.926Z</published>
    <updated>2019-01-01T09:23:21.135Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><h3 id="数据连接池"><a href="#数据连接池" class="headerlink" title="数据连接池"></a>数据连接池</h3><blockquote><p>什么是数据库连接池？<br>当系统使用JDBC技术访问数据库时会创建一个connection对象，而该对象的创建过程是非常消耗资源的，并且创建对象的时间也比较长，假设系统一天有1<br>万次的访问量，那么一天就会创建1万connection对象，这极大的浪费数据库的资源，而且可能造成数据库服务器内存溢出、宕机。<br>为了解决上面的问题，就引入了数据库连接池（Connection pooling），它主要用来分配、管理、释放数据库的连接。数据库连接池首先会创建若干（该数<br>量可以配置）个connection对象并将这些对象放入到池中，当系统需要使用connection对象时，数据库连接池会从池中分配一个事先创建好的connection<br>对象给系统，当系统使用完毕或超时后，数据库连接池会将该connection对象重新放入到池中。这样就减少了创建connection对象所耗费的资源和时间，<br>可以提高对数据库操作的性能。</p></blockquote><h3 id="主流数据库连接池"><a href="#主流数据库连接池" class="headerlink" title="主流数据库连接池"></a>主流数据库连接池</h3><h2 id="1-C3p0"><a href="#1-C3p0" class="headerlink" title="1.C3p0"></a>1.C3p0</h2><h2 id="2-dbcp"><a href="#2-dbcp" class="headerlink" title="2.dbcp"></a>2.dbcp</h2><h2 id="3-tomcat-jdbc-pool"><a href="#3-tomcat-jdbc-pool" class="headerlink" title="3.tomcat jdbc pool"></a>3.tomcat jdbc pool</h2><h2 id="4-Druid-（我用的）"><a href="#4-Druid-（我用的）" class="headerlink" title="4.Druid  （我用的）"></a>4.Druid  （我用的）</h2><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="application-yml的配置参数"><a href="#application-yml的配置参数" class="headerlink" title="application.yml的配置参数"></a>application.yml的配置参数</h3><p>spring:<br>  datasource:</p><hr><blockquote><h1 id="数据源基本配置"><a href="#数据源基本配置" class="headerlink" title="数据源基本配置"></a>数据源基本配置</h1><p>   username: root<br>   password: 123456<br>   driver-class-name: com.mysql.jdbc.Driver<br>   url: jdbc:mysql://localhost:3306/ssm_crud<br>   type: com.alibaba.druid.pool.DruidDataSource</p><hr><h1 id="数据源其他配置-初始化参数"><a href="#数据源其他配置-初始化参数" class="headerlink" title="数据源其他配置  初始化参数"></a>数据源其他配置  初始化参数</h1><p>   initialSize: 5<br>   minIdle: 5<br>   maxActive: 20<br>   maxWait: 60000<br>  timeBetweenEvictionRunsMillis: 60000<br>   minEvictableIdleTimeMillis: 300000<br>  validationQuery: SELECT 1 FROM DUAL<br>   testWhileIdle: true<br>   testOnBorrow: false<br>   testOnReturn: false<br>   poolPreparedStatements: true</p><h1 id="配置监控统计拦截的filters，去掉后监控界面sql无法统计，’wall’用于防火墙"><a href="#配置监控统计拦截的filters，去掉后监控界面sql无法统计，’wall’用于防火墙" class="headerlink" title="配置监控统计拦截的filters，去掉后监控界面sql无法统计，’wall’用于防火墙"></a>配置监控统计拦截的filters，去掉后监控界面sql无法统计，’wall’用于防火墙</h1><p>   filters: stat,wall,log4j<br>   maxPoolPreparedStatementPerConnectionSize: 20<br>   useGlobalDataSourceStat: true<br>   connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</p></blockquote><h3 id="配置config类"><a href="#配置config类" class="headerlink" title="配置config类"></a>配置config类</h3><p>由于数据连接池中的属性默认是tomcat的数据连接池，但是使用Druid需要配置其servlet以及filter</p><h2 id="配置-01-DataSource"><a href="#配置-01-DataSource" class="headerlink" title="配置-01-DataSource"></a>配置-01-DataSource</h2><p>— java</p><blockquote><p>@ConfigurationProperties(prefix = “spring.datasource”)  //前缀：自定义数据源<br>   @Bean<br>   //自定义一个数据源<br>   public DataSource druid(){</p><pre><code>return new DruidDataSource() ;</code></pre><p>   }</p></blockquote><hr><h2 id="配置-02-Servlet"><a href="#配置-02-Servlet" class="headerlink" title="配置-02-Servlet"></a>配置-02-Servlet</h2><p>— java</p><blockquote><p>@Bean<br>   public ServletRegistrationBean statViewServlet(){<br>       ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),”/druid/*”);</p><pre><code>Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;) ;initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;) ;initParams.put(&quot;allow&quot;, &quot;&quot;); //默认允许所有的访问bean.setInitParameters(initParams);return  bean ;</code></pre><p>   }</p></blockquote><hr><h2 id="配置-03-filter"><a href="#配置-03-filter" class="headerlink" title="配置-03-filter"></a>配置-03-filter</h2><blockquote><p> @Bean<br>   public FilterRegistrationBean webStatFilter(){</p><pre><code>FilterRegistrationBean bean = new FilterRegistrationBean() ;Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;() ;bean.setFilter(new WebStatFilter());//不去拦截的文件initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*&quot;) ;bean.setInitParameters(initParams);bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));return bean ;</code></pre><p>   }</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>务必注意@Bean的配置，必须填入到AOP容器中，才会生效配置</p><p>在写配置类时候务必需要 @Configeration</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt; &lt;/excerpt&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据连接池&quot;&gt;&lt;a href=&quot;#数据连接池&quot; class=&quot;headerlink&quot; title=&quot;数据连接池&quot;&gt;&lt;/a&gt;数据连接池&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;什么是数据库连接池？&lt;br&gt;当系统使用JDBC技术访问数据库时会创建一个connection对象，而该对象的创建过程是非常消耗资源的，并且创建对象的时间也比较长，假设系统一天有1&lt;br&gt;万次的访问量，那么一天就会创建1万connection对象，这极大的浪费数据库的资源，而且可能造成数据库服务器内存溢出、宕机。&lt;br&gt;为了解决上面的问题，就引入了数据库连接池（Connection pooling），它主要用来分配、管理、释放数据库的连接。数据库连接池首先会创建若干（该数&lt;br&gt;量可以配置）个connection对象并将这些对象放入到池中，当系统需要使用connection对象时，数据库连接池会从池中分配一个事先创建好的connection&lt;br&gt;对象给系统，当系统使用完毕或超时后，数据库连接池会将该connection对象重新放入到池中。这样就减少了创建connection对象所耗费的资源和时间，&lt;br&gt;可以提高对数据库操作的性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;主流数据库连接池&quot;&gt;&lt;a href=&quot;#主流数据库连接池&quot; class=&quot;headerlink&quot; title=&quot;主流数据库连接池&quot;&gt;&lt;/a&gt;主流数据库连接池&lt;/h3&gt;&lt;h2 id=&quot;1-C3p0&quot;&gt;&lt;a href=&quot;#1-C3p0&quot; class=&quot;headerlink&quot; title=&quot;1.C3p0&quot;&gt;&lt;/a&gt;1.C3p0&lt;/h2&gt;&lt;h2 id=&quot;2-dbcp&quot;&gt;&lt;a href=&quot;#2-dbcp&quot; class=&quot;headerlink&quot; title=&quot;2.dbcp&quot;&gt;&lt;/a&gt;2.dbcp&lt;/h2&gt;&lt;h2 id=&quot;3-tomcat-jdbc-pool&quot;&gt;&lt;a href=&quot;#3-tomcat-jdbc-pool&quot; class=&quot;headerlink&quot; title=&quot;3.tomcat jdbc pool&quot;&gt;&lt;/a&gt;3.tomcat jdbc pool&lt;/h2&gt;&lt;h2 id=&quot;4-Druid-（我用的）&quot;&gt;&lt;a href=&quot;#4-Druid-（我用的）&quot; class=&quot;headerlink&quot; title=&quot;4.Druid  （我用的）&quot;&gt;&lt;/a&gt;4.Druid  （我用的）&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>springboor2.0新特性记录</title>
    <link href="http://runindark.com/2018/12/18/springboot%E6%96%B0%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E8%AE%B0%E5%BD%95/"/>
    <id>http://runindark.com/2018/12/18/springboot新版本特性记录/</id>
    <published>2018-12-18T12:07:52.141Z</published>
    <updated>2018-12-18T12:09:40.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EmbeddedServletContainerCustomizer"><a href="#EmbeddedServletContainerCustomizer" class="headerlink" title="EmbeddedServletContainerCustomizer"></a>EmbeddedServletContainerCustomizer</h2><blockquote><p>EmbeddedServletContainerCustomizer =&gt; WebServerFactoryCustomizer ;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;EmbeddedServletContainerCustomizer&quot;&gt;&lt;a href=&quot;#EmbeddedServletContainerCustomizer&quot; class=&quot;headerlink&quot; title=&quot;EmbeddedServletContainer
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot-05-配置文件</title>
    <link href="http://runindark.com/2018/11/29/SpringBoot-05-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://runindark.com/2018/11/29/SpringBoot-05-配置文件/</id>
    <published>2018-11-29T14:52:42.919Z</published>
    <updated>2018-11-29T15:04:59.179Z</updated>
    
    <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>springboot中含有大量的配置文件，但是究竟有哪些属性被配置，或者需要配置，作为开发者都应该有个大致的了解</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="配置文件的几种类型"><a href="#配置文件的几种类型" class="headerlink" title="配置文件的几种类型"></a>配置文件的几种类型</h2><h3 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h3><blockquote><p>学习spring的第一个配置文件就是xml文件了，在我们的maven工程中pom.xml大家应该都不陌生了<br>语法直接看看百度就好，也没什么要说的，有点类似html，写起来个人觉得繁琐了一些</p></blockquote><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><blockquote><p>在我们的springboot中的/config/application.properties就是这个类型的文件，语法特别的简单易懂</p></blockquote><h3 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h3><blockquote><p>如果利用markdown的小伙伴使用这个的话一定不陌生了，利用space来进行区域的划分，速度快，唯独语法上要求key：必须带有空格<br>个人更新博客的时候有被类似的要求坑害过，但是不能直接给yaml差评</p></blockquote><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><blockquote><p>springboot中默认的文件传输，速度快，短小精悍。</p></blockquote><h3 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h3><p>这些语言其实只是一个工具，每种语言的诞生都是有自己的含义的，只要用的习惯就好，博主比较懒，一般就是application.properties中直接更改了，<br>或者也用用yaml，这个不重要，大家自我定夺 。</p><h2 id="springboot中默认的属性"><a href="#springboot中默认的属性" class="headerlink" title="springboot中默认的属性"></a>springboot中默认的属性</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">官方默认属性查看</a></p><p><strong>如果需要修改，直接复制对应的配置文件，加到application.properties里面</strong></p></the></excerpt>]]></content>
    
    <summary type="html">
    
      &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt; 

&lt;p&gt;springboot中含有大量的配置文件，但是究竟有哪些属性被配置，或者需要配置，作为开发者都应该有个大致的了解&lt;/p&gt;&lt;/excerpt&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot-04-热部署</title>
    <link href="http://runindark.com/2018/11/29/SpringBoot-04-%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    <id>http://runindark.com/2018/11/29/SpringBoot-04-热部署/</id>
    <published>2018-11-29T12:54:42.058Z</published>
    <updated>2018-11-29T14:41:17.059Z</updated>
    
    <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>对于我们的开发来说，如果每一次更新文件或者源码，都需要去重启服务的话，对我们的开发和执行效率来说实在是太慢了。<br>springboot由于自身整合了tomcat所以速度更快一些，如果是学习过springmvc的话，每次都去重启tomcat服务器是特别<br>慢的，热部署也就应运而生了。</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-devtools" target="_blank" rel="noopener">热部署官网</a></p><p>依赖代码</p><blockquote><dependencies><br>   <dependency><br>       <groupid>org.springframework.boot</groupid><br>       <artifactid>spring-boot-devtools</artifactid><br>       <optional>true</optional><br>   </dependency><br></dependencies></blockquote><h3 id="热部署基本操作"><a href="#热部署基本操作" class="headerlink" title="热部署基本操作"></a>热部署基本操作</h3><ol><li>更改源码后直接 ctrl+s 执行保存操作更新</li><li>在application.properties中更改一些路径不被热部署<blockquote><p>spring.devtools.restart.exclude= (文件路径)</p></blockquote></li><li>如果你不想每次执行保存操作后就进行热部署，那么可以用 “trigger.txt” 文件修改<blockquote><p>在application.properties中添加如下代码<br>spring.devtools.restart.trigger-file=trigger.txt<br>创建 “trigger.txt” 文件<br>这样你只有在保存trigger.txt文件的时候进行热部署 </p></blockquote></li></ol><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><blockquote><ol><li>在springboot中热部署你修改的java源码中的内容，但是静态目录的内容是不会被加载的</li><li>热部署的实质是监听，他会捕捉 你 <strong>ctrl + s</strong>的操作，也就是文件保存的操作，将触发热部署</li><li>热部署是主动进行的，如果你的保存操作被执行，那么你将会看到日志信息的更新 </li></ol></blockquote><h4 id="为什么提早讲述热部署"><a href="#为什么提早讲述热部署" class="headerlink" title="为什么提早讲述热部署"></a>为什么提早讲述热部署</h4><p>我觉得热部署其实是很简单的一种骚操作，没有什么太高大上的东西，但是具有足够的基础和底层理论的积累，<br>可以看看jvm的classloader的部分（惭愧：目前自己没看过）<br>而且提早进行热部署可以提早的进行熟悉，对后面的整合会更加自如</p></the></excerpt>]]></content>
    
    <summary type="html">
    
      &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt; 

&lt;p&gt;对于我们的开发来说，如果每一次更新文件或者源码，都需要去重启服务的话，对我们的开发和执行效率来说实在是太慢了。&lt;br&gt;springboot由于自身整合了tomcat所以速度更快一些，如果是学习过springmvc的话，每次都去重启tomcat服务器是特别&lt;br&gt;慢的，热部署也就应运而生了。&lt;/p&gt;&lt;/excerpt&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot-03-目录结构再谈</title>
    <link href="http://runindark.com/2018/11/29/SpringBoot-03-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%86%8D%E8%B0%88/"/>
    <id>http://runindark.com/2018/11/29/SpringBoot-03-目录结构再谈/</id>
    <published>2018-11-29T12:21:03.531Z</published>
    <updated>2018-11-29T12:50:36.496Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><h2 id="重读目录结构"><a href="#重读目录结构" class="headerlink" title="重读目录结构"></a>重读目录结构</h2><p>使用一个框架，也同时意味着去遵守一个框架的标准，包括目录的结构，目录名，虽然之前我简单的有提过我们的目录结构，但是只是很粗浅的说，<br>其实目录结构大多数的博主是不会提及的，自己也踩过雷，也当是在这个方面有过很多的纠结，所以觉得有必要重新拿起目录结构深究一下。</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><blockquote><p>src/main/java：存放代码<br>src/main/resources<br>static: 存放静态文件，比如 css、js、image,<br>templates:存放静态页面jsp,html,tpl<br>config:存放配置文件,application.properties<br>resources:</p></blockquote><p>可以看到这就是我们的完整的目录信息，至于至于源码区域我们不用多说，以后会常常用到，所以不是这次说的重点。<br>对于config，我有说过springboot其实封装好了大多数的东西，但是有些默认的参数是我们不需要的，那么调节或者<br>说更改参数就是在config下的文件进行修改，距离写出的application.properties只是系统自动生成的文件之一，今后<br>我们还会使用到yaml和xml，当然yaml会更加的方便我们的书写，也更加的快速</p><h2 id="静态资源目录"><a href="#静态资源目录" class="headerlink" title="静态资源目录"></a>静态资源目录</h2><p>我们可以看到可以存放资源的目录有很多，这些目录的名字都是系统中默认写好的名字，我们不要去做任何的修改，springboot在启动的时候会自动的<br>从我们的文件目录下去寻找自己锁需要的文件，如果随意的更改我们的文件名字，就会导致无法获取我们所需要的静态资源从而导致404这类错误，当然<br>springboot查询目录也是有自己的优先级的，下面就是优先级的排布</p><blockquote><p>META/resources &gt; resources &gt; static &gt; public</p></blockquote><p>有些东西需要注意一下，在springboot中，其实高优先级与低优先级之间不是覆盖的关系，而是互补的，举个例子来说<br>如果你在高优先级更改端口号，那么低优先级再更改端口号是没有意义的<br>但是如果你在低优先级中书写了其他的内容，那么依然生效</p><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content" target="_blank" rel="noopener">官网地址</a></p><blockquote><p>spring.resources.static-locations =<br>classpath:/META-INF/resources/,<br>classpath:/resources/,<br>classpath:/static/,<br>classpath:/public/ </p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt; &lt;/excerpt&gt;&lt;/p&gt;
&lt;h2 id=&quot;重读目录结构&quot;&gt;&lt;a href=&quot;#重读目录结构&quot; class=&quot;headerlink&quot; title=&quot;重读目录结构&quot;&gt;&lt;/a&gt;重读目录结构&lt;/h2&gt;&lt;p&gt;使用一个框架，也同时意味着去遵守一个框架的标准，包括目录的结构，目录名，虽然之前我简单的有提过我们的目录结构，但是只是很粗浅的说，&lt;br&gt;其实目录结构大多数的博主是不会提及的，自己也踩过雷，也当是在这个方面有过很多的纠结，所以觉得有必要重新拿起目录结构深究一下。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot-02-控制器和注解</title>
    <link href="http://runindark.com/2018/11/29/SpringBoot-02-%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
    <id>http://runindark.com/2018/11/29/SpringBoot-02-控制器和注解/</id>
    <published>2018-11-29T10:48:54.098Z</published>
    <updated>2018-11-29T14:35:42.996Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><h2 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h2><p>对于一个后端来说，其实很简单的，说的明白一些就是接受和处理前端的数据，同时也要发送整理好的数据给前端网页，但是，在springboot，如何进行<br>前后端数据的交互，就是要涉及到springboot了 。<br><a id="more"></a></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="中央核心控制器-DispatcherServlet"><a href="#中央核心控制器-DispatcherServlet" class="headerlink" title="中央核心控制器 DispatcherServlet"></a>中央核心控制器 DispatcherServlet</h2><p>上面提到的，前后端数据的交互的核心就是我们controller了，在springmvc中，这个东西可是最为关键和核心的内容,如下是dispatcherServlet<br>在springmvc中的注册信息，（这里带大家看一下，毕竟这是springmvc中的东西，在我们的springboot中是看不到的）</p><blockquote><servlet><br>   <servlet-name>springMVC</servlet-name><br>   <!-- spring MVC中的核心控制器 --><br>   <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class><br>   <init-param><br>       <param-name>contextConfigLocation</param-name><br>       <param-value>classpath:springmvc.xml</param-value><br>   </init-param><br>   <load-on-startup>1</load-on-startup><br></servlet></blockquote><p>说到底，我们的controller的实质还是一个servlet，在javaEE中，我们的使用常用的HTTPServlet，因此<strong>HTTPServletRequest</strong>，<strong>HTTPServletResponse</strong>放在controller中是完全适用的。</p><p>我们后端的绝大多数操作也将会放在controller中进行，所以务必注意，包括之后的皆接口的名字，导包信息，都要谨慎 。</p><h2 id="第一个controller"><a href="#第一个controller" class="headerlink" title="第一个controller"></a>第一个controller</h2><p><img src="/image/Springboot/springboot-02-控制器和注解/01.png" alt=""></p><p>大家可以先观察一下我们的controller的类是放在什么位置的，然后我加上源码分析一下 。</p><blockquote><p>package com.yuliao.wordsmemory;</p><p>import org.springframework.web.bind.annotation.RequestMapping;<br>import org.springframework.web.bind.annotation.RestController;</p><p>//controller注解<br>@RestController<br>public class Words {</p><p>   //映射注解<br>   @RequestMapping(“/printWords”)</p><p>   public String printWords (){</p><pre><code>//输出到前台的数据return &quot;HelloWorld&quot; ;</code></pre><p>   }</p><p>}</p></blockquote><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><blockquote><p>其实RestController是两个注解的合体，我们之所以可以在controller使用return语句返回 “HelloWorld” 到前台其实是一个叫<br>@ResponseBody的注解在起作用分析底层底层源码是可以看到的，所以在这里我们可以写一个等式  </p><p>@RestController = @Controller + @ResponseBody </p></blockquote><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><blockquote><p>RequestMapping就是我们所说的映射，这个就是在网页静态地址规范controller作用范围，就如刚刚我们的代码所写的，我们启动服务器以后<br>我们需要在浏览器中查找  </p></blockquote><p><img src="/image/Springboot/springboot-02-控制器和注解/02.png" alt=""></p><h3 id="数据的传输"><a href="#数据的传输" class="headerlink" title="数据的传输"></a>数据的传输</h3><p>在我们的springboot中默认的数据传输类型是json格式的，当我们创建一个类的时候，利用 return 返回到前台的时候，会自动变成json的数据类型，<br>javabean自动序列化成json数据类型是有 jackson&gt;fastjson&gt;gson&gt;json-lib ，我们使用的是jackso，所以一些我们的常用的注解有以下集中<br>指定字段不返回： @JsonIgnore<br>指定日期格式： @JsonFormat()<br>指定别名： @JsonProperty</p><h2 id="一些要说的东西"><a href="#一些要说的东西" class="headerlink" title="一些要说的东西"></a>一些要说的东西</h2><p>这里的注解只是很简单的给大家介绍一下如何向前台传递数据，至于如何从前台获取数据稍后也会更新，对于注解这是我们最常用的几个，但是这些数量<br>对于我们来说是远远不够的，包括去掉@ResponseBody传递数据将会有什么用，这些都暂时没有提及。</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt; &lt;/excerpt&gt;&lt;/p&gt;
&lt;h2 id=&quot;说在前面的话&quot;&gt;&lt;a href=&quot;#说在前面的话&quot; class=&quot;headerlink&quot; title=&quot;说在前面的话&quot;&gt;&lt;/a&gt;说在前面的话&lt;/h2&gt;&lt;p&gt;对于一个后端来说，其实很简单的，说的明白一些就是接受和处理前端的数据，同时也要发送整理好的数据给前端网页，但是，在springboot，如何进行&lt;br&gt;前后端数据的交互，就是要涉及到springboot了 。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot-01-项目建立</title>
    <link href="http://runindark.com/2018/11/28/SpringBoot-01-%E9%A1%B9%E7%9B%AE%E5%BB%BA%E7%AB%8B/"/>
    <id>http://runindark.com/2018/11/28/SpringBoot-01-项目建立/</id>
    <published>2018-11-28T13:43:34.581Z</published>
    <updated>2018-11-28T14:54:51.175Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><h2 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h2><p>一头扎入框架的我也慢慢的开始接触springboot的旷阔领域中，之前学习了太多的理论知识，实践能力着实不堪，立下flag以求自己能坚持下去，同时开始稳定更新博客，从头到尾的去把springboot的教程出一份，作为自己的笔记也作为经验之谈，写的不好的地方大家多多指出，谢谢。<br><a id="more"></a></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="学习springboot你需要什么知识储备"><a href="#学习springboot你需要什么知识储备" class="headerlink" title="学习springboot你需要什么知识储备"></a>学习springboot你需要什么知识储备</h2><blockquote><p>不要轻举妄动，框架的学习要一步一步的走，直接跨越，直接上手springboot，你也许觉得照猫画虎，框架的使用很简单，但是只有表面功夫<br>是远远不够的，沉住气，你需要学习  <strong>javaEE , springmvc</strong><br>至于持久层mybatis可以暂时跳过，spring一些属性注入方式也可以暂时不看，但是前两者的一定要看。<br>至于要看的课程的话 推荐一个老师，淘宝买课认识的，大家可以去看下 <a href="http://www.monkey1024.com/" target="_blank" rel="noopener">monkey1024</a><br>要资源的话不要找我，尊重一个老师的劳动成果，几十的东西，大家买一下，支持一个</p></blockquote><p>##开发工具(IDE)</p><blockquote><p>我推荐哈，idea很舒服，简单明了，之前有用过pycharm和clion的都可以直接上手的，毕竟一个公司设计的东西，eclipse怎么说呢，很好的ide，但是<br>容易抽风，如果身边有常用eclipse的人，他们口头都会挂上一句“重启大法好”，所以入门直接使用idea就很好了，我的教程也全是基于idea的，下载过<br>程省略，<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IDEA</a></p></blockquote><h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2><p>项目的教程全部如图咯~<br><img src="/image/Springboot/springboot-01-项目建立/01.png" alt=""><br><img src="/image/Springboot/springboot-01-项目建立/02.png" alt=""><br><img src="/image/Springboot/springboot-01-项目建立/03.png" alt=""><br><img src="/image/Springboot/springboot-01-项目建立/04.png" alt=""></p><h2 id="目录分析"><a href="#目录分析" class="headerlink" title="目录分析"></a>目录分析</h2><p><img src="/image/Springboot/springboot-01-项目建立/05.png" alt=""><br>如图我们来看一下我们的初始化目录，该写什么，能写在哪里，之间的调用方式和执行流程都和目录关系密切<br>（只列举我们要用到的，或者说常用的，其他的有些我也其实不清楚，有的直接删除也不影响）</p><h3 id="src"><a href="#src" class="headerlink" title="src:"></a>src:</h3><p>这个就是我们的源码区域</p><h4 id="java"><a href="#java" class="headerlink" title="java:"></a>java:</h4><blockquote><p>要写的controller，DAO ， impl等</p></blockquote><h4 id="resource"><a href="#resource" class="headerlink" title="resource:"></a>resource:</h4><blockquote><p>顾名思义就是我们的一些资源文件，其下的static就是我们所说的静态资源，包括css,html,js,image等等</p></blockquote><h3 id="templates："><a href="#templates：" class="headerlink" title="templates："></a>templates：</h3><blockquote><p>也是顾名思义就是模板，也是我们的一些模板引擎，例如 JSP、Velocity、Freemarker、Thymeleaf<br>我后期会更新的也是thymeleaf，当然也是springboot官方推荐的</p></blockquote><h3 id="test"><a href="#test" class="headerlink" title="test:"></a>test:</h3><blockquote><p>有点类似junit服务，就是一个测试的地方，springboot直接将这个整合进来，很方便</p></blockquote><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><blockquote><p>这个其实没什么好说的，就是maven资源管理的文件，所有的依赖就是写在这里的</p></blockquote><h2 id="讲完了，一些后话"><a href="#讲完了，一些后话" class="headerlink" title="讲完了，一些后话"></a>讲完了，一些后话</h2><p>这个教程不是完全针对0基础的初学者的，正如我说的，你需要足够的知识储备才建议去学习springboot，当然了也有一些名词是大家没有听说过的<br>但是，稍安勿躁，大家目前需要大致的了解，对于一些特定的内容比如模板引擎，日志驱动sel4j等一系列内容都会出教程。</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt; &lt;/excerpt&gt;&lt;/p&gt;
&lt;h2 id=&quot;说在前面的话&quot;&gt;&lt;a href=&quot;#说在前面的话&quot; class=&quot;headerlink&quot; title=&quot;说在前面的话&quot;&gt;&lt;/a&gt;说在前面的话&lt;/h2&gt;&lt;p&gt;一头扎入框架的我也慢慢的开始接触springboot的旷阔领域中，之前学习了太多的理论知识，实践能力着实不堪，立下flag以求自己能坚持下去，同时开始稳定更新博客，从头到尾的去把springboot的教程出一份，作为自己的笔记也作为经验之谈，写的不好的地方大家多多指出，谢谢。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>生活在继续，你要等</title>
    <link href="http://runindark.com/2018/11/24/NeedToWait/"/>
    <id>http://runindark.com/2018/11/24/NeedToWait/</id>
    <published>2018-11-24T14:30:01.473Z</published>
    <updated>2018-11-25T07:10:38.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=" "></a><excerpt in="" index="" |="" 首页摘要=""> </excerpt></h2><h2 id="狗粮加鸡汤，情愿者自看，喷子请自溜，诤者可自闻"><a href="#狗粮加鸡汤，情愿者自看，喷子请自溜，诤者可自闻" class="headerlink" title="狗粮加鸡汤，情愿者自看，喷子请自溜，诤者可自闻"></a>狗粮加鸡汤，情愿者自看，喷子请自溜，诤者可自闻</h2><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="写在最前面的"><a href="#写在最前面的" class="headerlink" title="写在最前面的"></a>写在最前面的</h2><blockquote><p>当初搭建博客的时候，说过自己的要更新自己的生活日常的，本来以为自己的第一篇文章一定事会写一些励志或者正能量的鸡汤文，但是<br>现在看来这样的文章配不上我的第一篇生活博客。</p></blockquote><h2 id="生活在继续，你要等"><a href="#生活在继续，你要等" class="headerlink" title="生活在继续，你要等"></a>生活在继续，你要等</h2><blockquote><p>自己本身是一个情感方面特别冷淡的人，对于生活似乎也更加习惯独来独往的方式，也许从初中开始就慢慢的喜欢上了一个人的生活，虽然<br>也曾期待过扎堆扎群的生活，然而性格的原因，我觉得自己更适合独来独往。<br>经历过很多心理上的折磨，也受过委屈，也接受了失落，相拥了无奈，陪伴了彷徨和无助。从一个简单的人，慢慢变的复杂，对世界也从简单<br>的期待，也逐渐的变成了冷眼相待，对人对事，也接受了 “走马观花” 的的理念。<br>我觉得这会是我的生命节奏了，一个人跑一个人笑，一个人哭一个人闹，一个人努力，一个人疯狂，他人的冷眼，他人的不解，对我来说，索然<br>无用也无味，有本书叫《像狗一样奔跑》，用来形容自己的生活或许更合适不过了。<br>其实我觉得自己会孤独的过完大学的四年，以后找一份好的工作，不会拖累家人，还可以孝顺父母，追随追随梦想，到了适当的年纪也许也会<br>被介绍女友，谈婚论嫁，一生安逸。我着实想不出我这样子的人如何去学着对一个好，如何去追一个人，如何去无微不至的关怀一个人，真的，<br>我学不会，甚至也不想学，因为我甚至觉得我这人可能遇不到那种“一见钟情”的爱情。</p></blockquote><h2 id="生活在继续，我等到了"><a href="#生活在继续，我等到了" class="headerlink" title="生活在继续，我等到了"></a>生活在继续，我等到了</h2><blockquote><p>但是，一个人悄然出现在我身边，轻轻的，不知不觉，就这样，我等到了TA。<br>很早的时候我便认识了TA，当时只是觉得自己可能只是觉得TA很好，或许能成为很好的朋友，所以缘分的齿轮就这样子转动了，从遇到TA的那<br>一天起，或许已经是结果了。一次又一次的巧合和偶然，我们真的成为了很好的朋友，很单纯的朋友，在我心里也许这就是传说中的挚友吧。<br>可是，缘分这个诡而又诡的东西，不会挑时候，也不会挑场合，更不会给我准备，1122，我表白了，或许算不上表白，拙劣的言语讲真难谈的上<br>是表白，现在的我想想还很搞笑，一个口渴想喝水的人和一个打算午休的人，毫无征兆的说出了自己心里话，就这样，脱单了。或许这就是传说中<br>的“幸福来的太突然”吧。<br>1122这一天，我被一个“臭傻逼”宰了我一顿饭，也是他和我谈了很多，后来觉得缘分这个东西很突然，或许从见面的那一刻开始，就彼此种下了种子。</p></blockquote><h2 id="生活在继续，请忍耐"><a href="#生活在继续，请忍耐" class="headerlink" title="生活在继续，请忍耐"></a>生活在继续，请忍耐</h2><blockquote><p>是的，生活这个东西是玄学，不要迷信，也不要摒弃，Everything is possible从来都不是开玩笑的一句话，从确定的关系的那一刻起，我突然觉得<br>自己似乎翻开了生活的另一页，翻过了苦涩和孤独的风雨的篇章，站在了阳光明媚，虹彩相拥的更加巍峨的山脚下，生活在继续，再苦再涩请忍耐，你会等&gt;到TA，TA会等到你，世界刚刚开始对你微笑，请让自己相信，世界逐渐咧开的嘴是微笑，而不是吞噬，忍耐恐惧，终见彩虹。<br>致敬每一个努力的人，致敬每一个拼搏的人。</p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt; &lt;/excerpt&gt;&lt;/h2&gt;&lt;h2 id=&quot;狗粮加鸡汤，情愿者自看，喷子请自溜，诤者可自闻&quot;&gt;&lt;a href=&quot;#狗粮加鸡汤，情愿者自看，喷子请自溜，诤者可自闻&quot; class=&quot;headerlink&quot; title=&quot;狗粮加鸡汤，情愿者自看，喷子请自溜，诤者可自闻&quot;&gt;&lt;/a&gt;狗粮加鸡汤，情愿者自看，喷子请自溜，诤者可自闻&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://runindark.com/2018/11/21/FiveLayerNetworkProtoco/"/>
    <id>http://runindark.com/2018/11/21/FiveLayerNetworkProtoco/</id>
    <published>2018-11-21T05:01:46.999Z</published>
    <updated>2018-11-21T05:41:17.974Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Five layer network protoco</p><h2 id="五层网络协议"><a href="#五层网络协议" class="headerlink" title="五层网络协议"></a>五层网络协议</h2><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><h2 id="三种模型-（包含五层网络协议）"><a href="#三种模型-（包含五层网络协议）" class="headerlink" title="三种模型 （包含五层网络协议）"></a>三种模型 （包含五层网络协议）</h2><h3 id="OSI七层体系结构"><a href="#OSI七层体系结构" class="headerlink" title="OSI七层体系结构"></a>OSI七层体系结构</h3><blockquote><p>应用层 ： 报文<br>表示层 ： 确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取<br>会话层 ： 从网络到具体的本地设备之间联系<br>运输层 ： 数据协议等基本信息<br>网络层 ： 网络系统中主机之间的数据的传输和路径的选择<br>数据链路层 ： 规范数据的传输到物理设备<br>物理层 ： 最底层，就是我们所见到的网络接口光纤等<br><a id="more"></a></p></blockquote><the rest="" of="" contents="" |="" 余下全文=""><h3 id="TCP-IP四层体系结构"><a href="#TCP-IP四层体系结构" class="headerlink" title="TCP/IP四层体系结构"></a>TCP/IP四层体系结构</h3><blockquote><p>应用层<br>运输层<br>网际层<br>网络接口层</p></blockquote><h3 id="五层网络结构"><a href="#五层网络结构" class="headerlink" title="五层网络结构"></a>五层网络结构</h3><blockquote><p>应用层 ： 顾名思义，向用户提供最直接的网络服务，如HTTP，SMTP， FTP等<br>运输层 ： TCP，UDP两种协议传输数据<br>网络层 ： 1.）把运输层中的报文段封装成包进行传输  2.）选测路由，通过路由找到合适的主机<br>数据链路层 ： 规范数据传输到物理设备<br>物理层 ： 最底层，网络接口光纤等</p></blockquote><h3 id="三种模型的联系和关系"><a href="#三种模型的联系和关系" class="headerlink" title="三种模型的联系和关系"></a>三种模型的联系和关系</h3><p>这里提及一点所谓的五层网络协议其实并不是特别准确的描述，只是OSI和TCP/IP体系结构的综合表述</p><p>具体关系如下 ：<br><img src="/image/五层网络协议/01.png" alt=""></p><h4 id="TCP-和-UDP-补充"><a href="#TCP-和-UDP-补充" class="headerlink" title="TCP 和 UDP 补充"></a>TCP 和 UDP 补充</h4><p>如上介绍，TCP和UDP是存在于运输层的两种传输协议，而报文段的传送也主要是以来于这两种协议，那么二者的区别呢</p><blockquote><p>(1) 传输控制协议TCP(Transmission Control Protocol)：面向连接的，数据传输的单位是报文段，能够提供可靠的交付。<br>(2) 用户数据包协议UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</p></blockquote><h4 id="二者的比较"><a href="#二者的比较" class="headerlink" title="二者的比较"></a>二者的比较</h4><blockquote><p>由于TCP一定需要连接，所以TCP与UDP相比也更加的安全<br>TCP的连接保证安全的代价也是更大的，也导致了TCP的传输效率低的问题，相比起来的话，UDP则具备速度快，连接简单，消耗资源低的优点<br>UDP的丢包率更低<br>总而言之TCP与UDP的根本却别在于是否需要连接</p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;Five layer network protoco&lt;/p&gt;
&lt;h2 id=&quot;五层网络协议&quot;&gt;&lt;a href=&quot;#五层网络协议&quot; class=&quot;headerlink&quot; title=&quot;五层网络协议&quot;&gt;&lt;/a&gt;五层网络协议&lt;/h2&gt;&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt; &lt;/excerpt&gt;&lt;/p&gt;
&lt;h2 id=&quot;三种模型-（包含五层网络协议）&quot;&gt;&lt;a href=&quot;#三种模型-（包含五层网络协议）&quot; class=&quot;headerlink&quot; title=&quot;三种模型 （包含五层网络协议）&quot;&gt;&lt;/a&gt;三种模型 （包含五层网络协议）&lt;/h2&gt;&lt;h3 id=&quot;OSI七层体系结构&quot;&gt;&lt;a href=&quot;#OSI七层体系结构&quot; class=&quot;headerlink&quot; title=&quot;OSI七层体系结构&quot;&gt;&lt;/a&gt;OSI七层体系结构&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;应用层 ： 报文&lt;br&gt;表示层 ： 确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取&lt;br&gt;会话层 ： 从网络到具体的本地设备之间联系&lt;br&gt;运输层 ： 数据协议等基本信息&lt;br&gt;网络层 ： 网络系统中主机之间的数据的传输和路径的选择&lt;br&gt;数据链路层 ： 规范数据的传输到物理设备&lt;br&gt;物理层 ： 最底层，就是我们所见到的网络接口光纤等&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MVC续谈</title>
    <link href="http://runindark.com/2018/11/16/MVC/"/>
    <id>http://runindark.com/2018/11/16/MVC/</id>
    <published>2018-11-16T11:05:59.938Z</published>
    <updated>2018-11-16T11:28:59.841Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><h2 id="mvc，mvp，mvvm理解"><a href="#mvc，mvp，mvvm理解" class="headerlink" title="mvc，mvp，mvvm理解"></a>mvc，mvp，mvvm理解</h2><blockquote><p>mvc作为经典的开发模式，能经久不衰当然是有独到的过人之处的，简单容易理解model，controller，view三大部分，相互独立，但是也相互关联<br>使得开发变得条理性极强，同时由于独立性使得可维护性很高<br>简单的说一下网页的布局，view就是前端的那些东西，html，css顺一个js，model和数据库以及所需要的对象模型<br><a id="more"></a></p></blockquote><the rest="" of="" contents="" |="" 余下全文=""><h2 id="mvc，mvp，mvvm理解-1"><a href="#mvc，mvp，mvvm理解-1" class="headerlink" title="mvc，mvp，mvvm理解"></a>mvc，mvp，mvvm理解</h2><blockquote><p>mvc作为经典的开发模式，能经久不衰当然是有独到的过人之处的，简单容易理解model，controller，view三大部分，相互独立，但是也相互关联，使<br>得开发变得条理性极强，同时由于独立性使得可维护性很高，<br>简单的说一下网页的布局，view就是前端的那些东西，html，css顺一个js，model和数据库以及所需要的对象模型，<br>在然后就是servlet作为controller了，交互有两种方式，v-&gt;c-&gt;m，v-&gt;m-&gt;c，这样子完成对数据的处理，也就是所谓的后端流程，<br>在javaee中的建包方法就很好的体现了这点，分别是，dao包，service包，和servlet包（实际上还有一个dbutil是用来折腾jdbc的，不赘述了）<br>dao就是model，service和servlet就是controller了，service是服务层，就是一个调用接口的过程，servlet就是真正的controller了，其实这些<br>包下面还有impl子包，这样子的话实现与声明分离，可维护行也提高。再继续举例子，就是Python的flask框架了，他的分离更加简单，<br>static静态资源库，home//admin，前台和后台的分离，init初始化，run开始。也是完全走着mvc的风格。总而言之mvc就是让模块分离的一种设计思想</p></blockquote><p>##mvvm和mvp,这两个直接看图吧。没啥好讲的了。。<br><img src="/image/mvc详解/01.png" alt=""><br><img src="/image/mvc详解/02.png" alt=""></p><blockquote><p>说一下缺点，看了一下那篇英文的和那个中文的mvc已死的博客，其实双方都是担忧一个controller臃肿的问题，没错，如果太多的处理量都传递给<br>controller那么势必变得繁杂，更可怕是提高耦合度，所以他们想利用一个content模块来分担controllet的压力，更多的数据处理放在content，<br>更多的逻辑处理放在controller，尽管没有成型，但是博主们都给出了类似这样子的思路。<br>不过话讲回来，mvc始终是经典，现在仍然是主流，学习的时候用mvc的思路去分析，还是十分必要的。</p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt; &lt;/excerpt&gt;&lt;/p&gt;
&lt;h2 id=&quot;mvc，mvp，mvvm理解&quot;&gt;&lt;a href=&quot;#mvc，mvp，mvvm理解&quot; class=&quot;headerlink&quot; title=&quot;mvc，mvp，mvvm理解&quot;&gt;&lt;/a&gt;mvc，mvp，mvvm理解&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;mvc作为经典的开发模式，能经久不衰当然是有独到的过人之处的，简单容易理解model，controller，view三大部分，相互独立，但是也相互关联&lt;br&gt;使得开发变得条理性极强，同时由于独立性使得可维护性很高&lt;br&gt;简单的说一下网页的布局，view就是前端的那些东西，html，css顺一个js，model和数据库以及所需要的对象模型&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单例设计模式，MVC，监听者模式</title>
    <link href="http://runindark.com/2018/11/16/designpattern/"/>
    <id>http://runindark.com/2018/11/16/designpattern/</id>
    <published>2018-11-16T10:52:36.160Z</published>
    <updated>2018-11-16T11:30:47.297Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><h2 id="目前的了解三种设计模式"><a href="#目前的了解三种设计模式" class="headerlink" title="目前的了解三种设计模式"></a>目前的了解三种设计模式</h2><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>单例模式其实显而易见，就是突出一个单字，一切运行过程核心集中于一个类，采用该模式开发，也是要求一个类只有一个对象，或者说只有一个实例。</p><h3 id="监听者模式，"><a href="#监听者模式，" class="headerlink" title="监听者模式，"></a>监听者模式，</h3><p>怎么讲呢？监听者模式其实更像是按照树的思路创建出的一种设计模式，简单的说起来就是子类被父类监听，逐级向上传递，期中需要三个对象，事件，事件源，事件监听器。相对应的还有一个观察者模式，emm，个人理解哈，讲真，观察者模式就是监听者模式简化。<br><a id="more"></a></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="大名鼎鼎的MVC"><a href="#大名鼎鼎的MVC" class="headerlink" title="大名鼎鼎的MVC"></a>大名鼎鼎的MVC</h3><blockquote><p>大名鼎鼎的开发模式了，spring为了web还专门引出分支springmvc，可见一斑了，<br>m是model，v是view，c是controller。<br>用springmvc作为典例说一下哈，m就是模型对象，是一种概念吧，传参，用的mode，modeandview应该都不陌生，<br>还有就是bean的配置都是model的东西，在这里可以理解成封装好的project的应用模型，view，<br>就是给用户看到的东西呗，js，html，css这些前端的东西嘛。<br>controller，这个是核心了，也就是真正的后端完善逻辑部分的核心控制器了，springmvc中直接明确给controller极高的地位置，<br>dispatchercontroller，这个可不虚名，model传来的的参数，view的视图，在中央核心控制器中都可以实现，所以听名字就可以看出来重要性了，<br>最后总结一下，其实mvc就是把图和逻辑分开，逻辑把参数和真实逻辑又分开的一种开发模式，这样导致程序的可维护性增加，逻辑出错找逻辑，参数出<br>错找model，视图修改找view</p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt; &lt;/excerpt&gt;&lt;/p&gt;
&lt;h2 id=&quot;目前的了解三种设计模式&quot;&gt;&lt;a href=&quot;#目前的了解三种设计模式&quot; class=&quot;headerlink&quot; title=&quot;目前的了解三种设计模式&quot;&gt;&lt;/a&gt;目前的了解三种设计模式&lt;/h2&gt;&lt;h3 id=&quot;单例设计模式&quot;&gt;&lt;a href=&quot;#单例设计模式&quot; class=&quot;headerlink&quot; title=&quot;单例设计模式&quot;&gt;&lt;/a&gt;单例设计模式&lt;/h3&gt;&lt;p&gt;单例模式其实显而易见，就是突出一个单字，一切运行过程核心集中于一个类，采用该模式开发，也是要求一个类只有一个对象，或者说只有一个实例。&lt;/p&gt;
&lt;h3 id=&quot;监听者模式，&quot;&gt;&lt;a href=&quot;#监听者模式，&quot; class=&quot;headerlink&quot; title=&quot;监听者模式，&quot;&gt;&lt;/a&gt;监听者模式，&lt;/h3&gt;&lt;p&gt;怎么讲呢？监听者模式其实更像是按照树的思路创建出的一种设计模式，简单的说起来就是子类被父类监听，逐级向上传递，期中需要三个对象，事件，事件源，事件监听器。相对应的还有一个观察者模式，emm，个人理解哈，讲真，观察者模式就是监听者模式简化。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从url到网页到底发生了什么</title>
    <link href="http://runindark.com/2018/11/16/FromUrlToPage/"/>
    <id>http://runindark.com/2018/11/16/FromUrlToPage/</id>
    <published>2018-11-16T10:19:34.160Z</published>
    <updated>2018-11-16T11:04:02.831Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><h2 id="url是什么"><a href="#url是什么" class="headerlink" title="url是什么"></a>url是什么</h2><blockquote><p>URL其实就是我们常说的网址，作用也是顾名思义就是定位效果，而术语则是资源定位符，<br>也是互联网上标准资源的地址，这个点到为止不再赘述。<br><a id="more"></a></p></blockquote><the rest="" of="" contents="" |="" 余下全文=""><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><h3 id="什么是DNS解析"><a href="#什么是DNS解析" class="headerlink" title="什么是DNS解析"></a>什么是DNS解析</h3><blockquote><p>然后下一步我们需要dns解析，什么dns解析呢，就是把url翻译成机器可识别的数字格式，<br>类似我们所熟悉的192.168.1这样子，这样子才是可以被解析的。</p></blockquote><h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><blockquote><p>这个过程也是在专门的解析服务器上自动解析的，dns解析会有四个步骤，</p></blockquote><h4 id="第一个则是查找浏览器缓存（不同浏览器不同一般是两到三十分钟左右）"><a href="#第一个则是查找浏览器缓存（不同浏览器不同一般是两到三十分钟左右）" class="headerlink" title="第一个则是查找浏览器缓存（不同浏览器不同一般是两到三十分钟左右）"></a>第一个则是查找浏览器缓存（不同浏览器不同一般是两到三十分钟左右）</h4><h4 id="第二个则是在本地系统查找缓存（本地也会有缓存，比如tomcat的localhost：8080）"><a href="#第二个则是在本地系统查找缓存（本地也会有缓存，比如tomcat的localhost：8080）" class="headerlink" title="第二个则是在本地系统查找缓存（本地也会有缓存，比如tomcat的localhost：8080）"></a>第二个则是在本地系统查找缓存（本地也会有缓存，比如tomcat的localhost：8080）</h4><h4 id="第三个是在路由器查找缓存（没错，部分路由器是具有缓存功能的）第四个则是ISP查找（这个比较厉害，直接查向运营商最高服务器）。"><a href="#第三个是在路由器查找缓存（没错，部分路由器是具有缓存功能的）第四个则是ISP查找（这个比较厉害，直接查向运营商最高服务器）。" class="headerlink" title="第三个是在路由器查找缓存（没错，部分路由器是具有缓存功能的）第四个则是ISP查找（这个比较厉害，直接查向运营商最高服务器）。"></a>第三个是在路由器查找缓存（没错，部分路由器是具有缓存功能的）第四个则是ISP查找（这个比较厉害，直接查向运营商最高服务器）。</h4><h4 id="之后就是通过tcp链接服务器了，服务器这时才会开始处理请求，向我们的浏览器传递数据，"><a href="#之后就是通过tcp链接服务器了，服务器这时才会开始处理请求，向我们的浏览器传递数据，" class="headerlink" title="之后就是通过tcp链接服务器了，服务器这时才会开始处理请求，向我们的浏览器传递数据，"></a>之后就是通过tcp链接服务器了，服务器这时才会开始处理请求，向我们的浏览器传递数据，</h4><h4 id="一些需要注意的地方"><a href="#一些需要注意的地方" class="headerlink" title="一些需要注意的地方"></a>一些需要注意的地方</h4><blockquote><p>值得注意的是浏览器是边传输边渲染的，当然没有遇到js之前，js是单线程，而且js可以对html网页进行更改，大家所看到的很好的特效，都是js在进行<br>这时我们的页面就加载完成啦。<br>至于通信协议也是很简单，就是传递给服务器的协议，当然服务器向浏览器传输也要遵循http你要通过才能传递，这是一种规范也是一种手段。<br>还有就是渲染过程也是可以了解一下的，渲染以树的方法渲染着呢，dom树，解析css和js交互。<br>再细化就是前台和后端了，后端可以直接用servlet来传递协议（虽然springmvc里面是dispatcherservlet，或者说是controller，<br>但是实质还是servlet，接口几乎全适用）但是这样子传输还是存在问题，这样前后端交互总这样，数据更新不同步，所以ajax就出现了，<br>实现机理也简单,就是在传递给servlet之前，需要多传递一个ajax。如此就可以不必要必须走服务器，走异步交互啦，技术方面就是jquery。</p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt; &lt;/excerpt&gt;&lt;/p&gt;
&lt;h2 id=&quot;url是什么&quot;&gt;&lt;a href=&quot;#url是什么&quot; class=&quot;headerlink&quot; title=&quot;url是什么&quot;&gt;&lt;/a&gt;url是什么&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;URL其实就是我们常说的网址，作用也是顾名思义就是定位效果，而术语则是资源定位符，&lt;br&gt;也是互联网上标准资源的地址，这个点到为止不再赘述。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo + github 博客搭建教程</title>
    <link href="http://runindark.com/2018/11/15/My%20first%20blog/"/>
    <id>http://runindark.com/2018/11/15/My first blog/</id>
    <published>2018-11-15T10:39:21.035Z</published>
    <updated>2018-11-18T06:30:18.704Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><h3 id="搭建博客的一些基本常识"><a href="#搭建博客的一些基本常识" class="headerlink" title="搭建博客的一些基本常识"></a>搭建博客的一些基本常识</h3><pre><code>我们搭建博客还是需要一点基本的知识的，不会让大家盲目的只是照着教程去看这些东西，更多的希望大家可以从中明白一些网站什么的基本原理</code></pre><h4 id="1-）-github"><a href="#1-）-github" class="headerlink" title="1.） github"></a>1.） github</h4><pre><code>一个网站能否被外网所访问，最关键的是需要一个平台或者说是一个服务器去使用，所以一部分会直接自己写博客放在自己的服务器上（小声：本文不是这样的），但是服务器是需要买的，成本太大我们不使用这种方法，但是github也可以当作一个服务器来看待，我们就可以托管到github上使得我们的博客可以访问。</code></pre><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h4 id="2-）-git"><a href="#2-）-git" class="headerlink" title="2.） git"></a>2.） git</h4><pre><code>博客的搭建，不仅仅是一个被访问的过程，你还需要用自己的电脑去不断的操作你线上的博客，那么git这个工具就是一个必不可少的东西了，这个可以直接与你的github操作，完成你博客的更新。但是本地和线上博客交互，你起码要让github知道，你的本地是安全的，可以被访问才行，所以ssh密匙就是做这个工作的，只有ssh密匙认证，这个样子我们的才能放心我们博客的安全</code></pre><h4 id="3-）-关于主题"><a href="#3-）-关于主题" class="headerlink" title="3.） 关于主题"></a>3.） 关于主题</h4><pre><code>博客嘛，毕竟是自己的，我们所需要的当然不仅仅是被访问，关键是得自己喜欢，所以有了主题选择的这个部分</code></pre><h3 id="1-github部分"><a href="#1-github部分" class="headerlink" title="1. github部分"></a>1. github部分</h3><h4 id="github注册-（如果已经有账号的可以忽略一下）"><a href="#github注册-（如果已经有账号的可以忽略一下）" class="headerlink" title="github注册 （如果已经有账号的可以忽略一下）"></a>github注册 （如果已经有账号的可以忽略一下）</h4><p><a href="https://github.com/" target="_blank" rel="noopener">github</a><br>    首先进入官网，记得去注册一个github账号，没有注册过的第一个页面就是github的注册页面</p><h3 id="2-创建一个仓库"><a href="#2-创建一个仓库" class="headerlink" title="2. 创建一个仓库"></a>2. 创建一个仓库</h3><p><img src="/image/hexo博客搭建/01.png" alt=""><br>    注册完毕以后就是去new 一个repository<br>    一定要按照我的要求去写，尤其是那个用户名，比如我的用户名是Runindark，所以是Runindark.github.in<br>    你们需要的就是用你们自己的用户名替换我的Runindark就好了<br><img src="/image/hexo博客搭建/02.png" alt=""><br>    这个也选好把，没什么坏处<br><img src="/image/hexo博客搭建/03.png" alt=""><br>    之后就可以看到大致这样的界面了，我的是已经搭建好的所以和大家刚刚弄好的不太一样，但是大致界面没问题</p><h3 id="3-下载git"><a href="#3-下载git" class="headerlink" title="3. 下载git"></a>3. 下载git</h3><p><a href="https://git-scm.com/downloads/" target="_blank" rel="noopener">github</a><br>    下载好以后，安装，全程默认设置一直点就OK了这个超级简单。</p><h3 id="4-下载node-js"><a href="#4-下载node-js" class="headerlink" title="4. 下载node.js"></a>4. 下载node.js</h3><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a><br>    大家需要下载这个，毕竟有很多东西都是这里的，老老实实安装吧</p><h3 id="5-下载hexo"><a href="#5-下载hexo" class="headerlink" title="5. 下载hexo"></a>5. 下载hexo</h3><pre><code>然后大家需要在自己的电脑上找一个地方去创建一个文件夹，用来存放你自己博客的内容的地方，而且博客的初始化文件也很重要创建好以后右击文件夹 git bash 就会进入了，名字不重要，大家自己随便起就欧克了</code></pre><p><img src="/image/hexo博客搭建/05.png" alt="成功以后效果图"></p><pre><code>开始执行命令了，后面的环节大家划重点，不要关闭你的gitbash的终端窗口，一定不要</code></pre><hr><pre><code>/********安装hexo指令********/npm install -g hexo-cli/*******hexo初始化指令*******/hexo init/*******hexo安装组件*********/npm install/******静态网页更新指令*******/hexo g /******静态网页启动服务*******/hexo s</code></pre><hr><pre><code>这样子一套下来，应该会出现</code></pre><p><img src="/image/hexo博客搭建/06.png" alt=""><br>    浏览器输入网址：  <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a><br><img src="/image/hexo博客搭建/07.png" alt=""><br>    大家应该会出现 hexo 的那个基本的页面，如果没有出现网页，那么就需要自己考虑一下是不是哪一步有问题了<br>    如果正常的话，这个样子你的博客就完成一大半了，先恭喜一下。<br><img src="/image/hexo博客搭建/08.png" alt=""></p><h3 id="6-ssh密匙"><a href="#6-ssh密匙" class="headerlink" title="6. ssh密匙"></a>6. ssh密匙</h3><h4 id="这部分的作用我在开头已经给大家讲过了，大家严格按照我的步骤，做下去就没问题"><a href="#这部分的作用我在开头已经给大家讲过了，大家严格按照我的步骤，做下去就没问题" class="headerlink" title="这部分的作用我在开头已经给大家讲过了，大家严格按照我的步骤，做下去就没问题"></a>这部分的作用我在开头已经给大家讲过了，大家严格按照我的步骤，做下去就没问题</h4><h4 id="使得github和你的hexo联系起来"><a href="#使得github和你的hexo联系起来" class="headerlink" title="使得github和你的hexo联系起来"></a>使得github和你的hexo联系起来</h4><hr><pre><code>git config --global user.name &quot;Runindark&quot;git config --global user.email &quot;1414776384@qq.com&quot;//提示一下，Runindark是要替换成你的github名字的//提示两下，1414776384@qq.com 是需要替换成你注册github时的邮箱的ssh-keygen -t rsa -C “1414776384@qq.com”//这边也是，邮箱要换成你注册github的邮箱eval &quot;$(ssh-agent -s)&quot;ssh-add ~/.ssh/id_rsa</code></pre><hr><pre><code>输入完这两条指令就欧克了，然后需要找ssh文件了目录就是你的c盘用户名下面，我的如下</code></pre><p><img src="/image/hexo博客搭建/09.png" alt=""><br>    再之后就是用记事本打开我标注的哪个文件，所谓的ssh密匙就是这个了<br><img src="/image/hexo博客搭建/10.png" alt=""><br>    复制，粘贴全部（ps一下哈，这个东西打开末尾是你的邮箱，如果不是，那就是出错了）<br><img src="/image/hexo博客搭建/11.png" alt=""> </p><h4 id="重新打开你的github"><a href="#重新打开你的github" class="headerlink" title="重新打开你的github"></a>重新打开你的github</h4><p><img src="/image/hexo博客搭建/12.png" alt=""><br><img src="/image/hexo博客搭建/13.png" alt=""> </p><pre><code>打开之后，创建新的ssh</code></pre><p><img src="/image/hexo博客搭建/14.png" alt=""><br>    如图，简单操作一下<br><img src="/image/hexo博客搭建/15.png" alt=""><br>    别急·冷静·还有最后一步马上完事了</p><h4 id="下载sublime-超级好的工具"><a href="#下载sublime-超级好的工具" class="headerlink" title="下载sublime 超级好的工具"></a>下载sublime 超级好的工具</h4><p><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">sublime</a><br>    下载好以后，打开，把之前创建的初始化hexo的文件夹都拖进来，如图<br><img src="/image/hexo博客搭建/16.png" alt=""><br>    找到config配置文件<br><img src="/image/hexo博客搭建/17.png" alt=""><br>    然后更改如图的内容<br><img src="/image/hexo博客搭建/18.png" alt=""><br>    说一下哪个repository，这个地方是在github上的，如图，大家要复制那里的东西<br><img src="/image/hexo博客搭建/19.png" alt=""> </p><h4 id="最后屏住呼吸-输入如下指令"><a href="#最后屏住呼吸-输入如下指令" class="headerlink" title="最后屏住呼吸 输入如下指令"></a>最后屏住呼吸 输入如下指令</h4><hr><pre><code>hexo d -g</code></pre><hr><pre><code>然后大功告成输入 Runindark.github.io.git  （Runindark换成你的用户名） 就可以访问外网了。博客搭建到这里就结束了，后面两部分，下次给大家更新</code></pre><h3 id="7-选择主题"><a href="#7-选择主题" class="headerlink" title="7. 选择主题"></a>7. 选择主题</h3><h3 id="8-域名绑定"><a href="#8-域名绑定" class="headerlink" title="8. 域名绑定"></a>8. 域名绑定</h3></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt; &lt;/excerpt&gt;&lt;/p&gt;
&lt;h3 id=&quot;搭建博客的一些基本常识&quot;&gt;&lt;a href=&quot;#搭建博客的一些基本常识&quot; class=&quot;headerlink&quot; title=&quot;搭建博客的一些基本常识&quot;&gt;&lt;/a&gt;搭建博客的一些基本常识&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;我们搭建博客还是需要一点基本的知识的，不会让大家盲目的只是照着教程去看这些东西，更多的希望
大家可以从中明白一些网站什么的基本原理
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;1-）-github&quot;&gt;&lt;a href=&quot;#1-）-github&quot; class=&quot;headerlink&quot; title=&quot;1.） github&quot;&gt;&lt;/a&gt;1.） github&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;一个网站能否被外网所访问，最关键的是需要一个平台或者说是一个服务器去使用，所以一部分
会直接自己写博客放在自己的服务器上（小声：本文不是这样的），但是服务器是需要买的，成本太大
我们不使用这种方法，但是github也可以当作一个服务器来看待，我们就可以托管到github上使得我们
的博客可以访问。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://runindark.com/2018/11/15/hello-world/"/>
    <id>http://runindark.com/2018/11/15/hello-world/</id>
    <published>2018-11-15T07:25:23.946Z</published>
    <updated>2018-11-16T06:20:42.287Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
