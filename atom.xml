<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cat&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://runindark.com/"/>
  <updated>2020-08-30T11:30:34.260Z</updated>
  <id>http://runindark.com/</id>
  
  <author>
    <name>夜小猫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>场景分析</title>
    <link href="http://runindark.com/2020/08/29/2020%E7%A7%8B%E6%8B%9B/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    <id>http://runindark.com/2020/08/29/2020秋招/场景分析/</id>
    <published>2020-08-29T13:48:41.363Z</published>
    <updated>2020-08-30T11:30:34.260Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h2><h3 id="下单减库存"><a href="#下单减库存" class="headerlink" title="下单减库存"></a>下单减库存</h3><ol><li>订单减库存<ul><li>当用户下了订单之后，则会减库存</li><li>保证了秒杀活动是<strong>不会超卖</strong>的</li><li>但是如果有订单未支付的话，则会产生<strong>少卖</strong></li></ul></li><li>支付减库存<ul><li>顾名思义就是说下单的时候是不会对数据库进行操作，只有支付成功后才会进行减库存</li><li>如果多个请求发现剩余库存都是<strong>1</strong>，那么都发起支付会产生<strong>超卖的现象</strong></li><li>但是保证了不会<strong>少卖</strong></li></ul></li><li>预扣库存<ul><li>本质上是订单减库存，但是会有有效时间</li><li>在有效时间内库存一直被减去，但是一旦失效则立刻回复库存</li><li>但是还是难以防止恶意下单导致的库存被占用</li></ul></li></ol><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><ol><li><p>限流算法</p><ul><li><strong>令牌桶算法</strong><br><img src="https://i.loli.net/2020/08/30/MoJAgvclb2unDRd.jpg" alt="令牌桶.jpg"><ul><li>令牌可以源源不断的恒定速度流入桶内，但是如果超过桶的容量则溢出</li><li>请求需要时可以直接从令牌桶中拿到令牌，则桶内的令牌减去</li><li>允许突发性能</li></ul></li><li><strong>漏桶算法</strong><br><img src="https://i.loli.net/2020/08/30/iGsVOgYQj2EhxpD.jpg" alt="漏桶.jpg"><ul><li>漏桶不装水，一旦流入速度大于流出的速度则就会溢出</li><li>最大程度上限制了传输的速度</li><li>没有突发性能可言</li></ul></li></ul></li><li><p>秒杀大闸</p><ul><li>由于令牌桶算法的无限生成，因此需要限制量的大小</li><li>则对秒杀量进行初始化，设置秒杀的负载因子</li><li>假如秒杀量为10w，负载因子为5，则秒杀大闸是50w</li><li>则TPS还是50w，并发程度还是很高，削峰还是不够彻底</li></ul></li><li><p>队列泄洪<br> <img src="https://img-blog.csdnimg.cn/20200516154833938.png" alt="队列泄洪"></p><ul><li>由于限流算法和秒杀大闸无法更好的解决大量的数据流</li><li>因此想到异步的操作，先把订单请求存储，之后再慢慢的处理</li><li>利用消息队列，将请求先存入队列中，之后异步的处理消息队列中的请求</li></ul></li></ol><h3 id="缓存数据库双写一致性"><a href="#缓存数据库双写一致性" class="headerlink" title="缓存数据库双写一致性"></a>缓存数据库双写一致性</h3><ol><li>先删缓存，再修改数据库<br> <img src="https://i.loli.net/2020/08/30/7hwZx5ekvnKdsGy.jpg" alt="先删除缓存再更新数据库.jpg"><ul><li>当数据库没有做读写分离时<ul><li>请求A先删除数据库</li><li>请求B同时来查询该数据，则不能命重缓存，但是由于请求A修改的数据还没提交，则回到数据库查询旧值</li><li>之后请求A再更新数据库</li><li>可以使用延时双删解决<br>  <img src="https://user-gold-cdn.xitu.io/2020/7/17/1735bb58819f24ab?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="延时双删"><ul><li>也就是说在A更新完数据库之后，等待一段时间，再删除缓存</li></ul></li></ul></li><li>当数据库做了读写分离<ul><li>同上过程，因为数据提交以后，不一定主从同步结束</li><li>所以B可能还会拿到旧的数据库</li><li>因此当没有在redis中命重数据时，则应该强制到主库去查询，查询后再填充到数据库</li></ul></li></ul></li><li>先修改数据库，再删缓存<br> <img src="https://i.loli.net/2020/08/30/8Inb9epaJtZ5fOy.jpg" alt="先更新数据库再删除缓存.jpg"><ul><li>请求A先更新数据库，则缓存依然存在</li><li>请求B查询数据时在缓存中命重</li><li>则请求B查询到的数据都是旧的</li><li>之后A请求才会删除数据</li></ul></li></ol></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="集合" scheme="http://runindark.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Leecode</title>
    <link href="http://runindark.com/2020/08/12/2020%E7%A7%8B%E6%8B%9B/leecode/"/>
    <id>http://runindark.com/2020/08/12/2020秋招/leecode/</id>
    <published>2020-08-12T14:58:42.585Z</published>
    <updated>2020-08-12T15:00:24.504Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><ul><li>暴力<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leecode01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i ;</span><br><span class="line">                    res[<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="keyword">return</span> res ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Leecode" scheme="http://runindark.com/tags/Leecode/"/>
    
  </entry>
  
  <entry>
    <title>设计模式复习总结</title>
    <link href="http://runindark.com/2020/08/11/2020%E7%A7%8B%E6%8B%9B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://runindark.com/2020/08/11/2020秋招/设计模式/</id>
    <published>2020-08-11T15:37:56.801Z</published>
    <updated>2020-08-12T14:44:06.097Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><ol><li>依赖倒置原则<ul><li>针对接口编程，具体依赖抽象编程，但是抽象不依赖具体编程</li><li>也就是说接口中来抽象出有什么方法，用接口来架构，用类来实现</li></ul></li><li>开闭原则<ul><li>对拓展开放，对修改关闭</li><li>用抽象构建架构，用实现扩展原则</li><li>可见依赖倒置才能有开闭原则的实现</li></ul></li><li>里氏替换原则<ul><li>出现基类的位置可以出现子类，但是出现子类的位置不能出现基类</li></ul></li><li>迪米特法则<ul><li>也叫做最少知道原则</li><li>一个实体应该尽可能的不与其它的实习发生相互作用</li><li>也就是说一个类和另一个类尽量不要有继承这类关系</li></ul></li><li>合成复用原则<ul><li>尽可能的使用合成，聚合，而不去使用继承</li></ul></li><li>接口隔离原则<ul><li>使用多个隔离的接口，比使用单个接口好</li><li>也就是说一个实体的实现应该用尽量小的接口，不应该再去依赖那些不需要的接口</li></ul></li></ol><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><pre><code>- 如果说生产A披萨，B披萨- 那么我们需要创建披萨接口，A，B披萨都要实现这个接口- 之后在披萨的生产工厂中，通过传递字符串&quot;A&quot;,&quot;B&quot;来创建相应的披萨并返回</code></pre><h3 id="工厂方法-1"><a href="#工厂方法-1" class="headerlink" title="工厂方法"></a>工厂方法</h3><pre><code>- 从简单工厂上已经解决了生成某类披萨的模式，但是由于字符串的传递导致如果有新款披萨，那么就需要修改工厂中的创建方法。违反开闭原则（这里暂时不变）- 假如披萨的产地需要增加，那么一个是N地，一个是M地- 那么就需要进一步的抽象，N地，M地都去实现工厂的接口- 之后再在实现的工厂的接口中的方法里去制造披萨- 这样，产地将可以在不破坏工厂的情况下动态添加- 但是在创建产地的时候，必须要知道产地的方法名等信息</code></pre><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><pre><code>- 接着工厂方法继续说， 如果不同的产地生产不同的披萨呢- 那么继续把工厂抽象，不同的产地都继承抽象的工厂接口- 然后这些产地工厂再去实现类似简单工厂的不同的披萨生产</code></pre><blockquote><p>简单工厂就是一个地方生产不同的任何产品<br>工厂方法则是生产固定的产品<br>抽象工厂则是可以生产不同产品族的任何方法</p></blockquote><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ol><li>懒汉式<ul><li>也就是说，只有用的时候才回去看看是不是存在单例，存在的话直接反回，不存在的话再创建</li><li>存在线程安全问题，区别在于是否加了 <strong>synchronized</strong> 关键字</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LanHanSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LanHanSingleton lanHanSingleton ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LanHanSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LanHanSingleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lanHanSingleton!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            lanHanSingleton = <span class="keyword">new</span> LanHanSingleton() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lanHanSingleton ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"><span class="number">2</span>. 饿汉式</span><br><span class="line">    - 和懒汉式相反，饿汉式是直接就创建单例对象</span><br><span class="line">    - 不存在是不是线程安全问题</span><br><span class="line">    - - 由于<span class="keyword">static</span>是在类加载期间就会被处理，因此启动jvm时，只存在一个静态类，而且是线程安全的</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EhanSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EhanSingleton ehanSingleton = <span class="keyword">new</span> EhanSingleton() ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EhanSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EhanSingleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ehanSingleton ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>静态内部类</li></ol><ul><li>其实与饿汉式是一样的，都是建立在static，在类加载的时候处理，来保证线程安全</li><li>但是静态类如果没有被使用的话，是不会创建的，这样子做到了延迟加载的效果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerStaticSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerStaticSingleton Instance = <span class="keyword">new</span> InnerStaticSingleton() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerStaticSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerStaticSingleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.Instance ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>枚举</p><ul><li>枚举的本身就是private修饰的构造方法</li><li>枚举实例都是static final类型的</li><li>枚举可以直接序列化</li></ul></li><li><p>双重校验锁</p></li></ol><ul><li>问题分析：<ul><li>如果使用的是懒汉式加载，每次都调用synchronized去同步消耗资源较大</li></ul></li><li>问题处理：<ul><li>第一次校验不上锁，保证了不会每次都用synchronized同步去消耗资源</li><li>第二次校验上锁，存在特殊情况，A线程进行第一次校验的过程，校验结果是对象为null，这时候A线程被阻塞，B线程也进行校验，发现对象为null，这样会存在创建两次对象的情况，因此选择第二次继续校验，保证了对象只创建一次</li><li>jvm的指令重排效果下，初始化双重校验锁的类，和给doublecheckSingleton赋值的顺序是不一定的<ul><li>可能会出现，双重校验锁的类刚刚创建完，就给doublecheckSingleton被赋值了，是非null的，因此会发生错误</li><li>使用volatile禁止指令重排，才得以保证安全性</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheckSingleton doubleCheckSingleton ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleton <span class="title">getDoubleCheckSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (doubleCheckSingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (doubleCheckSingleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    doubleCheckSingleton = <span class="keyword">new</span> DoubleCheckSingleton() ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> doubleCheckSingleton ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="http://runindark.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://runindark.com/2020/08/07/2020%E7%A7%8B%E6%8B%9B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://runindark.com/2020/08/07/2020秋招/操作系统/</id>
    <published>2020-08-07T15:49:25.085Z</published>
    <updated>2020-08-10T02:48:20.484Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><ul><li>操作系统本质上也是一个软件</li><li>操作系统屏蔽了底层硬件的复杂性，提供简单的操作去操作硬件<br><img src="https://i.loli.net/2020/08/08/FtOLUkaTDCewHS6.jpg" alt="操作系统内核.jpg"><h3 id="用户态和系统态"><a href="#用户态和系统态" class="headerlink" title="用户态和系统态"></a>用户态和系统态</h3></li><li>用户态：就是用户调用的进程可以调用用户的各类数据</li><li>系统态；几乎可以访问计算机上的任何资源 <h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><blockquote><p>一般来说，进程的运行都是在用户态运行的，但很多时候会发生一些<strong>系统态级别的操作</strong>，因此需要发生系统调用来和操作系统发生请求关系。</p></blockquote></li></ul><p>系统调用类型</p><ul><li>设备管理:启动或者关闭一些设备</li><li>文件读取:文件的增删改查的操作</li><li>进程控制:进程的创建，阻塞，销毁</li><li>进程通信:完成进程之间的消息传递</li><li>内存管理:内存的分配、回收以及获取作业占用内存区大小及地址等</li></ul><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ul><li><strong>进程</strong>：就是用户所运行的一个完整的程序</li><li><strong>线程</strong>：一个进程下可以运行多个进程</li></ul><p>单核cpu</p><blockquote><p>关于<strong>一个单核的CPU</strong>的问题，<strong>一个单核cpu可以运行多个进程</strong>，只要内存空间足够，cpu也可以处理的过来；<br><strong>一个单核cpu下的进程中的线程，每次只能运行一个线程</strong></p></blockquote><p>用jvm的角度去思考进程和线程</p><blockquote><p>启动一个jvm则是一个进程，jvm中运行的线程则是对应操作系统中的线程</p></blockquote><h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><h4 id="进程通信的概念"><a href="#进程通信的概念" class="headerlink" title="进程通信的概念"></a>进程通信的概念</h4><blockquote><p>进程之间的<strong>用户地址空间</strong>是相互独立的，但是不同进程之间免不了需要数据交换等操作，因此进程间的通信需要依靠于<strong>内核</strong>，准确的说是<strong>内核缓存区</strong><br>进程A需要把变量读取到内核缓冲区，进程B再把数据从缓冲区中读取到进程中，这就是所谓的进程间通信（IPC，InterProcess Communication）</p></blockquote><h4 id="进程通信的方式"><a href="#进程通信的方式" class="headerlink" title="进程通信的方式"></a>进程通信的方式</h4><ul><li>无名管道<ul><li>半双工，数据只能单向的流动，也就是说可以是 进程A -&gt; 管道 -&gt; 进程B ，但是 进程B -&gt; 管道 -&gt; 进程A 是不允许的。<br><img src="https://i.loli.net/2020/08/09/PhLGwIbxaSi8AgZ.jpg" alt="无名管道.jpg"></li><li>管道的实质是 <strong>内核上中的一个缓冲区</strong>(在内存中) ，是一个<strong>队列</strong>，读取过后的数据则在队列中不存在</li><li>当管道满的时候，则相应的<strong>读进程或者写进程进入等待队列</strong></li><li>无名管道的局限性<ul><li>进程之间必须有亲缘关系才可以</li><li>数据是单向的</li><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li><li>管道的数据是无格式字节流，传输的时候需要双方确定好数据格式</li></ul></li><li>无名管道阻塞问题:无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。</li></ul></li><li>有名管道<ul><li>有名管道通过建立 <strong>路径名</strong> 来关联不同的进程 ，这样解决了无名管道只能有亲缘关系的进程通信的问题 </li><li>有名管道的<strong>管道名在文件系统（磁盘）</strong>，但是<strong>传输的内容在内存</strong>中</li><li>有名管道数据是双向的</li><li>有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</li></ul></li><li>信号 <ul><li>信号可以在任何时候发给某一进程，而<strong>无需知道该进程的状态</strong><br>  <img src="https://i.loli.net/2020/08/09/dLw1IjQW9JvVKM8.jpg" alt="常见信号.jpg"></li><li>信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件</li><li>信号来源<ul><li>硬件来源：比如ctrl+c是复制</li><li>软件来源：进程调用kill函数</li></ul></li><li>信号的生命周期<br>  <img src="https://i.loli.net/2020/08/09/gTHn2CXDc9xIW7p.jpg" alt="信号的生命周期.jpg"></li></ul></li><li>信号量<ul><li>信号量是一个计数器，信号量本质是为了多个进程之间的数据同步。</li><li>为获取共享资源，信号量的操作可分为3步<ol><li>创建信号量: 这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0</li><li>等待信号量: 测试信号量的值，如果是小于0则阻塞，<strong>P操作</strong></li><li>挂出信号量：信号量的值加一，<strong>V操作</strong></li></ol></li><li>信号量的类型<ul><li>Posix（可移植性操作系统接口）有名信号量（使用Posix IPC名字标识）</li><li>Posix基于内存的信号量（存放在共享内存区中）</li><li>System V信号量（在内核中维护）    </li></ul></li><li>信号量和整形数据的区别<ul><li>信号量是一个非负的整型，除了初始化外，只能用wait(semap) , signal(semap)这两个原子命令 =》 P（测试）V（增加）操作 ；</li></ul></li></ul></li><li>消息队列<ul><li>存放在<strong>内核中</strong>的<strong>消息链表</strong></li><li>由于只存放在内存中，因此只有内核被重启，信息才会被删除</li><li>消息队列在某个进程往一个队列写入消息之前，并<strong>不需要另外某个进程在该队列上等待消息的到达</strong></li><li>目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列</li></ul></li><li>共享内存<ul><li>存在于<strong>内核中</strong>的特定的一块内存区域供进程同步使用</li><li>是最快的进程通信的手段</li><li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率</li><li></li></ul></li><li>套接字（socket）<ul><li>由域、端口号、协议类型三个属性决定<ol><li>域<ul><li>AF_INET 指的是Internet网络</li><li>AF_UNIX 指的是UNIX文件系统</li></ul></li><li>端口号<ul><li>每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序</li></ul></li><li>协议<ul><li>流套接字 <ul><li>一个有序、可靠、双向字节流的连接</li><li>TCP/IP连接，UNIX文件系统使用</li></ul></li><li>原始套接字<ul><li>原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现</li></ul></li><li>数据报套接字<ul><li>它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。</li></ul></li></ul></li></ol></li></ul></li></ul><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol><li>互斥量 ： 互斥量值只能为0/1 =&gt; 互斥锁 =&gt; 加锁和解锁必须由同一线程分别对应使用</li><li>信号量 ： 信号量值可以为非负整数 =&gt; 共享锁 =&gt; 可以由一个线程释放，另一个线程得到</li><li>事件: (Wait/Notify) 就是通过一些操作，对线程进行操作</li></ol><h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><ol><li>先来先服务(FCFS) </li><li>短作业优先(SJF)： 从就绪队列中选出一个估计运行时间最短的进程为之分配资源</li><li>时间片轮转法(RR): 为每个进程分配一个时间段，则进程在允许的时间中运行</li><li>优先级调度：为进程分配优先级，优先级高的先执行，优先级相同的按照先来先服务</li><li>多级反馈队列：设置多个不同优先级的队列，先执行高优先级队列内的进程</li></ol><h2 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h2><p><a href="https://blog.csdn.net/hit_shaoqi/article/details/78516508" target="_blank" rel="noopener">原帖地址</a></p><ul><li><p>分区存储管理</p><ul><li>分区管理的分类<ul><li>固定分区：把内存固定的分成几部分，可以大小一样，也可以不一样，分区总数固定<ul><li>缺陷：固定了分区总数，那么并发数目会被限制；分区的大小不一定和进程完全匹配，则内碎片较多</li></ul></li><li>动态分区：根据装入程序动态的分配大小<ul><li>动态分区就是在程序装入时，在内存中找到比所需内存大于或等于的空间，如果是大于则会把空间切割成两份，其中<strong>一个被占用，另一个空闲</strong></li><li>分区算法：<ol><li>最先适配法：按照分区在内存中的先后，找到第一个可以装入程序的分区</li><li>下次适配法：从上次找到装入程序的分区继续向下找可以装下当下这个程序的分区</li><li>最佳适配法：从头到尾查分区，找到与程序要求空间相差最少的</li><li>最坏适配法：按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。</li></ol></li></ul></li><li>伙伴分区：由于固定分区限制多，动态分区算法复杂，占用内存多则使用伙伴分区<ol><li>伙伴系统规定，无论已分配分区或空闲分区，其大小均为 2 的 k 次幂，k 为整数， l≤k≤m，不同<strong>分区大小存在不同的分区链表中</strong></li><li>则2^1 表示分配的最小分区的大小，2^m 表示分配的最大分区的大小（ 通常 2^m是整个可分配内存的大小）</li><li>当查找一个长度为n的空间时，一般会找一个 <strong>2^(i－1)&lt;n&lt;= 2^i</strong>的值，最好的情况是2^i = n</li><li>如果2^i的分区已经没有了，则找2^(i+1)的分区，如果存在，则把2^(i+1)的分区拆成两份，一份占用，一份存到2^i的分区链表中，则拆开的这两个分区就称作时伙伴分区，当然了如果2^(i+1)也没了，则找2^(i+2)，以此类推</li></ol></li><li>内存紧缩：就是把空闲空间向一个方向移动，是的外碎片合并成一个大的空间，以供使用</li><li>覆盖技术：把某程序中的重要部分先载入到内存，不需要的则可以先放入外存<br>  <img src="https://i.loli.net/2020/08/10/9fLhdjVOrzXwQcA.jpg" alt="覆盖技术.jpg"></li><li>交换技术：多个程序并发执行时，可以将暂时不能执行的程序（进程）送到外存中，从而获得空闲内存空间来装入新程序（进程）</li></ul></li></ul></li><li><p>页式存储管理</p><ul><li>把主存分配成固定大小一页一页的，划分的力度更大，也就是说页比块更小</li><li>页式管理通过页表对应逻辑地址和物理地址</li><li>缺陷：但是和块式管理一样，存在类似的问题</li></ul></li><li>段式存储管理<ul><li>段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多</li><li>段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址</li></ul></li><li>段页式存储管理（linux中）<ul><li>逻辑地址空间分成若干个段，之后每个段又被分成若干个页</li></ul></li></ul><h3 id="快表（TLB）"><a href="#快表（TLB）" class="headerlink" title="快表（TLB）"></a>快表（TLB）</h3><p>页式存储管理的读取流程</p><blockquote><p>一般来说，在页式存储管理中，页存储在主存中，当要读取某数据的时候，内核需要两次访问主存。第一次是，查找页表，逻辑地址转化成物理地址。第二次才是真正的读写操作。</p></blockquote><p><img src="https://i.loli.net/2020/08/10/IlrgJ4Zhtv6fW3i.jpg" alt="快表.jpg"></p><p>快表</p><blockquote><p>将主存中的部分页表，放到cpu内部的关联存储器中（高速缓存区），当cpu给出有效可用的逻辑地址（有效地址）后，经过MMU（内存管理单元）找到页号，自动送到快表去查找，若找到匹配的页号，则直接返回物理地址，则直接只需要访问访问一次主存，就可以完成操作。</p></blockquote><p>有了快表以后的读取流程</p><ol><li>根据虚拟地址中的页号查快表；</li><li>如果该页在快表中，直接从快表中读取相应的物理地址；</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><p>小结：快表其实就是一个缓存区域，有的话直接快速拿走，没有的话则访问主存中的页表，再存入快表</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><blockquote><p>多级页表可以想想b+树，如果式一级的话可能只是n，但是如果是多级页表的话，可能相乘的结果会比相加更大。举个例子有空间5，如果不是多级页表，则最终可用的也就是5，多级页表可能是2*3=6，这样子就节约了内存。</p></blockquote><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><blockquote><p>一般来说，一个程序的大小总会比真实的主存要大，如果全部填入主存是不够的，则虚拟内存就是把磁盘上的空间和内存作为一个整体，以供程序运行使用。<br>虚拟内存其实是定义了虚拟地址来维护磁盘上的虚拟空间和主存，虚拟空间会被主存按需调用，甚至有时候会把程序直接从主存全部移动到磁盘中</p></blockquote><p><img src="https://i.loli.net/2020/08/10/QiF2KM8oO7adguB.jpg" alt="虚拟内存A.jpg"><br>（图是PTE仅含有一个有效位标记的页表结构）</p><ul><li>在页表上规定了一个偏移量PTE（Page Table Entry, PTE），则在页表上每一个固定的偏移量下都会有一个PTE。</li><li>在页表上，每一个PTE的ADDRESS对应一个虚拟内存和物理内存</li><li>在页表上，有效位代表了虚拟空间和物理地址是否可以对应</li><li>虚拟页VP 0、VP 4、VP 6、VP 7被缓存在物理内存中，虚拟页VP 2和VP 5被分配在页表中，但并没有缓存在物理内存，虚拟页VP 1和VP 3还没有被分配</li><li>如果页未命重，则移交到内核，内核会找到一个牺牲页，如果牺牲页发生修改，则内核会把牺牲页复制到磁盘，之后更新PTE指定到牺牲页的位置</li></ul><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><ol><li>时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行</li><li>空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问</li></ol><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ul><li>OPT 页面置换算法（最佳页面置换算法）： 淘汰在最长时间内不再被访问的页面</li><li>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）：淘汰最先进入内存的页</li><li>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）： LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的</li><li>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）：使用最少的页面作为淘汰页</li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="操作系统" scheme="http://runindark.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程篇复习总结</title>
    <link href="http://runindark.com/2020/07/27/2020%E7%A7%8B%E6%8B%9B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://runindark.com/2020/07/27/2020秋招/并发编程/</id>
    <published>2020-07-27T01:45:34.184Z</published>
    <updated>2020-09-10T16:56:11.528Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="进程，协程，线程基础概念"><a href="#进程，协程，线程基础概念" class="headerlink" title="进程，协程，线程基础概念"></a>进程，协程，线程基础概念</h2><h3 id="能否解释进程，线程，协程的关系？"><a href="#能否解释进程，线程，协程的关系？" class="headerlink" title="能否解释进程，线程，协程的关系？"></a>能否解释进程，线程，协程的关系？</h3><blockquote><p>进程是一个程序代码运行所执行的一个程序，但是一个进程可以包含多个线程，在单核cpu下，Java默认多线程可以以一种抢占式的方式执行一种并发状态，协程是近些年走进视野的，以GO语言为代表可以操作协程，一个线程中可以包含更多的协程，可以简单的说线程包含协程。</p></blockquote><h3 id="协程对于多线程有什么优缺点吗？"><a href="#协程对于多线程有什么优缺点吗？" class="headerlink" title="协程对于多线程有什么优缺点吗？"></a>协程对于多线程有什么优缺点吗？</h3><ol><li>首先是更小的协程可以在不使用内核的前提下进行上下文切换</li><li>一个线程就可以完成高并发的任务，对高并发的支持更好</li><li>协程在一个线程下，是不用考虑数据的读写不一致问题（读写变量冲突问题）</li><li>缺点： 缺点也很明显，本质还是一个单线程，不能利用多核资源，同时也不独立，需要线程，进程配合才可以运行</li></ol><h3 id="并行和并发的区别是什么？"><a href="#并行和并发的区别是什么？" class="headerlink" title="并行和并发的区别是什么？"></a>并行和并发的区别是什么？</h3><ol><li>并行是指多个程序 同时多个一起运行</li><li>并发是指多个程序在某一个时间段内交替的快速运行，宏观是有点类似并行，但是实际上是交替运行</li><li>恶补英语之==&gt; 并发 （concurrency）  并⾏ parallellism</li></ol><h2 id="多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）"><a href="#多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）" class="headerlink" title="多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）"></a>多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）</h2><h3 id="Java线程创建的几种方式"><a href="#Java线程创建的几种方式" class="headerlink" title="Java线程创建的几种方式"></a>Java线程创建的几种方式</h3><ol><li><p>继承extends</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread by extend Thread"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadByThread threadByThread = <span class="keyword">new</span> ThreadByThread() ;</span><br><span class="line">        threadByThread.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Runnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread create by implements Runnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadByRunnable ta = <span class="keyword">new</span> ThreadByRunnable() ;</span><br><span class="line">        <span class="keyword">new</span> Thread(ta).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用CF</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByCF</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Thread create by CF"</span> +<span class="string">":"</span> +Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FutureTask&lt;Object&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> ThreadByCF()) ;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.setName(<span class="string">"Cf"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.print.DocFlavor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            service.execute(<span class="keyword">new</span> ThreadByThread());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread());</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="线程基本原理"><a href="#线程基本原理" class="headerlink" title="线程基本原理"></a>线程基本原理</h2><h3 id="线程有哪些状态"><a href="#线程有哪些状态" class="headerlink" title="线程有哪些状态"></a>线程有哪些状态</h3><blockquote><p>创建 -&gt; 就绪 -&gt; 执行 -&gt; 消亡<br>阻塞: 分为同步组织，等待阻塞。 等待阻塞就是wait啦，sleep啦。同步阻塞就是sychronize锁被占用，另一个线程也需要占用这个锁，结果凉了，就阻塞了。</p></blockquote><h3 id="线程的基本一些方法"><a href="#线程的基本一些方法" class="headerlink" title="线程的基本一些方法"></a>线程的基本一些方法</h3><ol><li>sleep<blockquote><p>就是进入了等待阻塞队列中，根据设定的时间阻塞，而且不会释放锁，他的阻塞状态就是time_waiting</p></blockquote></li><li>yield<blockquote><p>就是让线程立马停止一下，但是不会进入阻塞，而是直接进入就绪,且不会释放锁</p></blockquote></li><li>join<blockquote><p>谁调用join谁先执行，然后再执行被停用的线程</p></blockquote></li><li>wait<blockquote><p>就是进入等待状态，而且必须有人去唤醒他，但是wait会释放锁，也可以wait（time）来通过时间唤醒</p></blockquote></li><li>notify<blockquote><p><strong>随机的唤醒任意的</strong>一个被wait的线程</p></blockquote></li><li>notifyall<blockquote><p>把wait的线程，全部唤醒</p></blockquote></li></ol><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="说说volatile的与sychronize的区别"><a href="#说说volatile的与sychronize的区别" class="headerlink" title="说说volatile的与sychronize的区别"></a>说说volatile的与sychronize的区别</h3><ol><li>volatile 不是原子性的，sychronize是原子性的</li><li>volatile和sychronize都保证了可见性</li><li>volatile是禁止了指令重排的</li><li>不能写入 不能修饰写⼊操作依赖当前值的变量，⽐如num++、num=num+1</li></ol><h3 id="为啥会出现脏读的问题？"><a href="#为啥会出现脏读的问题？" class="headerlink" title="为啥会出现脏读的问题？"></a>为啥会出现脏读的问题？</h3><blockquote><p>这个是JMM（java内存模型） 导致的，java线程中不是所有的变量都是在主存的，而是每个线程都有自己的一丢丢空间，对于修改的变量的操作，先从主存拿到，再修改，再写回去，如果多线程，可能因为速度问题，写入的时间啥的有差别，所以就会导致把数据脏读了。</p></blockquote><h3 id="为啥volatile可以解决这个问题呢？"><a href="#为啥volatile可以解决这个问题呢？" class="headerlink" title="为啥volatile可以解决这个问题呢？"></a>为啥volatile可以解决这个问题呢？</h3><blockquote><p>volatile就像是一个敏感的报警灯一样，一旦有人妄图修改volatile修饰的数据，立马报警通知修改情况，所以说原子性差了点，但是可见性或者说是共享性好的鸭匹</p></blockquote><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul><li>程序次序原则：无论怎么重排，都不会影响最终的运行结果</li><li>管程（Synchronized）序锁定原则：锁L被线程A释放，之后又被线程B获取，则线程B可见线程A在他之前获取到锁</li><li>volatile变量原则： 共享变量可以所有线程中都可见</li><li>线程启动原则： 启动线程A后，线程A中还有线程B也会被启动，则线程B可以看到线程A的修改结果</li><li>线程终止原则： 启动线程A后，线程A中还有线程B也会被启动，B在结束以前，线程A可以看到线程B的修改结果</li><li>线程中断原则： Intercept()中断的线程，Thread.Intercept()可见线程是否被中断</li><li>传递原则：A happen-before B，B happen-before C，C happen-before A</li><li>对象终结原则： 开始的一定是构造函数，结束的一定是finalize()</li></ul><h2 id="并发编程三要素"><a href="#并发编程三要素" class="headerlink" title="并发编程三要素"></a>并发编程三要素</h2><ul><li>原子性</li><li>有序性</li><li>可见性<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><blockquote><p>每次读写数据都是悲观的，认为可能会出现数据被其它线程读的问题，所以要上锁比如sychronized</p></blockquote><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote><p>每次读取数据都觉得是乐观的，觉得不会有其它线程更改要读取的数据</p></blockquote><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><blockquote><p>就是大家人人平等，都可以拿到锁，阻塞队列中按照顺序慢慢来=》reetrantlock（fair）</p></blockquote><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><blockquote><p>不公平的，只要你条件符合，就可以直接拿到锁=》reetrantlock（unfair）<br>reetrantlock其实底层就是一个队列，所以也是先来先服务那种，在公平锁体现的很好</p></blockquote><h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><blockquote><p>一个线程里吧，还调用另一个线程，然后这个锁对里面的这个线程也生效</p></blockquote><h3 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h3><blockquote><p>一个线程里吧，还调用另一个线程，然后吧，里面这个线程就不能用这个锁了，就只能乖巧的滚去阻塞队列了</p></blockquote><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><blockquote><p>就是想不开的锁，只要没条件获取到锁，就一直自旋，也就是一直去判断条件看看自己能不能获得锁子，while（flag）的感觉，除非获得锁才能结束，但是注意，自旋锁消耗cpu，毕竟在那转来转去的。<br>不会发⽣线程状态的切换，⼀直处于⽤户态，减少了线程上下⽂切换的消耗，缺点是循环会消耗CPU</p></blockquote><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><blockquote><p>也就是读锁，或者是S锁，就是可以让大家读取，查看，就是不能修改</p></blockquote><h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><blockquote><p>也就是霸占一把锁，只要这个线程占着，别人就不能去获取这个锁，但是只要霸占这个锁，能读能写</p></blockquote><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote><p>资源抢占矛盾循环了，无外力介入，是解不开的</p></blockquote></li></ul><h3 id="关于jvm自己内部的几个锁"><a href="#关于jvm自己内部的几个锁" class="headerlink" title="关于jvm自己内部的几个锁"></a>关于jvm自己内部的几个锁</h3><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote><p>就是如果哪个线程一直用着这个锁，就一直让他先用，更少的消耗量</p></blockquote><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote><p>如果其他锁妄图获得人家那个偏向锁，那就自旋吧，等人家用完才给你</p></blockquote><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><blockquote><p>自选锁也不自旋了，直接阻塞进化成重量级锁，重量级锁会让其他申请的线程进⼊阻塞，性能也会降低</p></blockquote><h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String locka = <span class="string">"A"</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String lockb = <span class="string">"B"</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"entre the locka"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line">                System.out.println(<span class="string">"a 取 b"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"entre the lockb"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line">                System.out.println(<span class="string">"b 取 a"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">          System.out.println(i+<span class="number">1</span> + <span class="string">"次"</span>);</span><br><span class="line">          <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">              DeadLock.LockA();</span><br><span class="line">          &#125;).start();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">              DeadLock.LockB();</span><br><span class="line">          &#125;).start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解锁代码"><a href="#解锁代码" class="headerlink" title="解锁代码"></a>解锁代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String locka = <span class="string">"A"</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String lockb = <span class="string">"B"</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"entre the locka"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line">                System.out.println(<span class="string">"a 取 b"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line">            System.out.println(<span class="string">"entre the lockb"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line">            System.out.println(<span class="string">"b 取 a"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(i+<span class="number">1</span> + <span class="string">"次"</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                DeadLock.LockA();</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                DeadLock.LockB();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>改变运行策略，其实是线程A中syc获取了锁a，还要获取suob，这样子顺序执行下来是ok 的，就怕线程a获取了锁a后，线程b抢占获取了锁b，此使线程a还要锁b<br>就阻塞了，所以到了线程b又要获取锁a，那么就死锁了<br>解决方法也简单，就是让一个锁提早消失就好了，所以改变一下sychronize的次序，提早释放锁，就万事大吉了</p></blockquote><h3 id="死锁的四个条件"><a href="#死锁的四个条件" class="headerlink" title="死锁的四个条件"></a>死锁的四个条件</h3><blockquote><p>互斥条件：资源不能共享，只能由⼀个线程使⽤<br>请求与保持条件：线程已经获得⼀些资源，但因请求其他资源发⽣阻塞，对已经获得的资源保持不释放<br>不可抢占：有些资源是不可强占的，当某个线程获得这个资源后，系统不能强⾏回收，只能由线程使⽤完⾃⼰释放<br>循环等待条件：多个线程形成环形链，每个都占⽤对⽅申请的下个资源</p></blockquote><h2 id="重入锁和不可重入锁"><a href="#重入锁和不可重入锁" class="headerlink" title="重入锁和不可重入锁"></a>重入锁和不可重入锁</h2><h3 id="不可重入锁-1"><a href="#不可重入锁-1" class="headerlink" title="不可重入锁"></a>不可重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BcrLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">boolean</span> flag = <span class="keyword">false</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"进入加锁"</span>);</span><br><span class="line">            flag = <span class="keyword">true</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"进入等待状态"</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"进入解锁"</span>);</span><br><span class="line">        notify();</span><br><span class="line">        flag = <span class="keyword">false</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.Messaging.SYNC_WITH_TRANSPORT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BcrLock bcrLock = <span class="keyword">new</span> BcrLock() ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bcrLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法A加锁"</span> + bcrLock.flag);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bcrLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bcrLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法B加锁"</span> + bcrLock.flag);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bcrLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> TestMain().methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重入锁-1"><a href="#重入锁-1" class="headerlink" title="重入锁"></a>重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.ir.Block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> islock = <span class="keyword">false</span> ;</span><br><span class="line">    <span class="keyword">public</span> String currentThread = <span class="keyword">null</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentThread==<span class="keyword">null</span>) &#123;</span><br><span class="line">            currentThread = Thread.currentThread().getName();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentThread.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"成功加锁"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!currentThread.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"加锁失败"</span>);</span><br><span class="line">                    wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        notify();</span><br><span class="line">        currentThread = <span class="keyword">null</span> ;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"成功解锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.awt.windows.ThemeReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMainB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CrLock crLock = <span class="keyword">new</span> CrLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            crLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法A加锁"</span> + crLock.currentThread);</span><br><span class="line">            methodB();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法a解锁"</span> );</span><br><span class="line">            crLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            crLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法B加锁"</span>+ crLock.currentThread );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法b解锁"</span> );</span><br><span class="line">            crLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">new</span> TestMainB().methodA();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">new</span> TestMainB().methodA();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized说说看"><a href="#synchronized说说看" class="headerlink" title="synchronized说说看"></a>synchronized说说看</h2><blockquote><p>非公平锁，原子性，可重入可以修饰代码块和方法<br>每个对象有⼀个锁和⼀个等待队列，锁只能被⼀个线程持有，其他需要锁的线程需要阻塞等待。锁被释放<br>后，对象会从队列中取出⼀个并唤醒，唤醒哪个线程是不确定的，不保证公平性<br>jdk6优化-&gt; 偏向锁-&gt;轻量级锁-&gt;重量级锁</p></blockquote><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h3><blockquote><p>CAS是一种乐观锁，CompareAndSwap，也就是比较再交换<br>执行过程大概如下： 首先是 内存地址V，预期原值A，新值B ， 如果线程A过来，V = A ,则满足条件把目标值更换成B，如果线程B过来，V ！= A，那么无法<br>将目标值更换成B，而且线程B将进行自旋，直到 A=V ，结束自旋，获取锁<br>缺点也将显而易见： 自旋锁的存在直接导致了cpu的消耗问题<br>CAS是原子性的</p></blockquote><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><blockquote><p>简单来说就是线程在操作过程中，有其它线程将该变量更改后，又有另一个线程把他改回来，到最开始线程操作的时候，发现该值没有变化，则该线程操作成<br>功。加一个版本号可以解决问题，每次修改时都要查看版本号</p></blockquote><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><blockquote><p>AQS本质上是为了解决线程安全所提出的一种解决方案的抽象<br>AQS的组成</p><ul><li>程序计数器</li><li>阻塞队列</li><li>线程标记</li></ul></blockquote><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><blockquote><p>是一个双向的链表，概念上的队列，但不是真正的实现也是队列</p></blockquote><h3 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h3><blockquote><p>是根据condition创建出来的队列，上锁后可以负责对线程的监视，比synchronized的监视器更加灵活，是一个单向的链表，当唤醒界节点的时候会直接添加到阻塞队列中</p></blockquote><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><h4 id="1-waitstatus"><a href="#1-waitstatus" class="headerlink" title="1. waitstatus"></a>1. waitstatus</h4><ol><li><p>CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</p></li><li><p>SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。</p></li><li><p>CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</p></li><li><p>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态</p><h4 id="2-prev"><a href="#2-prev" class="headerlink" title="2. prev"></a>2. prev</h4><blockquote><p>前驱节点</p></blockquote><h4 id="3-next"><a href="#3-next" class="headerlink" title="3. next"></a>3. next</h4><blockquote><p>后继节点</p></blockquote><h4 id="4-thread"><a href="#4-thread" class="headerlink" title="4. thread"></a>4. thread</h4><blockquote><p>thread 同步线程队列主要存储的线程信息。</p></blockquote><h4 id="5-nextwaiter"><a href="#5-nextwaiter" class="headerlink" title="5. nextwaiter"></a>5. nextwaiter</h4><p>AQS中阻塞队列采用的是用双向链表保存，用prve和next相互链接。而AQS中条件队列是使用单向列表保存的，用<br>nextWaiter来连接。阻塞队列和条件队列并不是使用的相同的数据结构</p></li></ol><p><a href="https://segmentfault.com/a/1190000015804888" target="_blank" rel="noopener">精髓原帖</a></p><p>在Node节点的源码中有两个常量属性</p><pre><code class="java"><span class="comment">// 共享模式</span><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();<span class="comment">// 独占模式</span><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;<span class="comment">// 其他模式</span><span class="comment">// 其他非空值：条件等待节点（调用Condition的await方法的时候）</span></code></pre><h3 id="部分核心方法"><a href="#部分核心方法" class="headerlink" title="部分核心方法"></a>部分核心方法</h3><h3 id="acquire-int-arg-源码讲解，好⽐加锁lock操作"><a href="#acquire-int-arg-源码讲解，好⽐加锁lock操作" class="headerlink" title="acquire(int arg) 源码讲解，好⽐加锁lock操作"></a>acquire(int arg) 源码讲解，好⽐加锁lock操作</h3><ol><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回,AQS⾥⾯未实现但没有定义成<br>abstract，因为独占模式下只⽤实现tryAcquire-tryRelease，⽽共享模式下只⽤实现<br>tryAcquireShared-tryReleaseShared，类似设计模式⾥⾯的适配器模式</li><li>addWaiter() 根据不同模式将线程加⼊等待队列的尾部，有Node.EXCLUSIVE互斥模式、<br>Node.SHARED共享模式；如果队列不为空，则以通过compareAndSetTail⽅法以CAS将当前线程<br>节点加⼊到等待队列的末尾。否则通过enq(node)⽅法初始化⼀个等待队列</li><li>acquireQueued()使线程在等待队列中获取资源，⼀直获取到资源后才返回,如果在等待过程<br>中被中断，则返回true，否则返回false<h3 id="release-int-arg-源码讲解-好⽐解锁unlock"><a href="#release-int-arg-源码讲解-好⽐解锁unlock" class="headerlink" title="release(int arg)源码讲解 好⽐解锁unlock"></a>release(int arg)源码讲解 好⽐解锁unlock</h3>独占模式下线程释放指定量的资源，⾥⾯是根据tryRelease()的返回值来判断该线程是<br>否已经完成释放掉资源了；在⾃义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回<br>true，否则返回false<br>unparkSuccessor⽅法⽤于唤醒等待队列中下⼀个线程</li></ol><h2 id="ReentrantLock实现原理"><a href="#ReentrantLock实现原理" class="headerlink" title="ReentrantLock实现原理"></a>ReentrantLock实现原理</h2><blockquote><p>实现大致的思路是和AQS是一致的，ReentrantLock的实现是分为公平锁和非公平锁的，其中上层Lock（Accquire），Unlock（Release）上层一致，唯独在释放的时候有一点区别，公平锁的实现是直接去队列中去找，看看队列中是否有等待，如果有等待的话则排队，无等待的话就直接给锁，对应的方法也就是TryAccquire（） ，而非公平锁则直接判断是不是符合获取锁的条件CompareAndState，如果符合直接给锁，如果不符合，则是按照公平锁的方法处理</p></blockquote><h2 id="ReentrantLock和synchronized区别是什么？"><a href="#ReentrantLock和synchronized区别是什么？" class="headerlink" title="ReentrantLock和synchronized区别是什么？"></a>ReentrantLock和synchronized区别是什么？</h2><ol><li>ReentrantLock和synchronized都是独占锁</li><li>synchronized：<blockquote><p>· 是悲观锁会引起其他线程阻塞，java内置关键字，<br>· ⽆法判断是否获取锁的状态，锁可重⼊、不可中断、只能是⾮公平<br>· 加锁解锁的过程是隐式的,⽤户不⽤⼿动操作,优点是操作简单但显得不够灵活<br>· ⼀般并发场景使⽤⾜够、可以放在被递归执⾏的⽅法上,且不⽤担⼼线程最后能否正确<br>释放锁<br>· synchronized操作的应该是对象头中mark word，参考原先原理图⽚</p></blockquote></li><li>ReentrantLock：<blockquote><p>· 是个Lock接⼝的实现类，是悲观锁，<br>· 可以判断是否获取到锁，可重⼊、可判断、可公平可不公平<br>· 需要⼿动加锁和解锁,且解锁的操作尽量要放在finally代码块中,保证线程正确释放锁<br>· 在复杂的并发场景中使⽤在重⼊时要却确保重复获取锁的次数必须和重复释放锁的次数⼀样，否则可能导致 其他线程⽆法获得该锁。<br>· 创建的时候通过传进参数true创建公平锁,如果传⼊的是false或没传参数则创建的是⾮公平锁<br>· 底层不同是AQS的state和FIFO队列来控制加锁</p></blockquote></li></ol><h2 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h2><p>核心其实是将锁分成了<strong>读锁</strong>和<strong>写锁</strong>两种，其中写锁可以转换成读锁(锁降级)，但是读锁不能是写锁</p><ul><li>读锁是利用了AQS中的共享锁，而写锁则是独占锁</li><li>用高16位用来表示读锁<strong>占有的线程数量</strong>，用低16位表示写锁被同一个<strong>线程申请的次数</strong></li><li>利用Sync实现<ul><li>FairSync<ul><li>hasQueuedPredecessors() 查看前面是否有就绪的线程</li></ul></li><li>NonfairSync<ul><li>判断读锁是否要阻塞，是通过阻塞队列前面是不是写锁，如果是写锁则阻塞。</li></ul></li></ul></li></ul><h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h2><blockquote><p>j.u.c包下的提供了线程安全的队列访问的接⼝，并发包下很多⾼级同步类的实现都是基于阻塞队列实现的<br>1、当阻塞队列进⾏插⼊数据时，如果队列已满，线程将会阻塞等待直到队列⾮满<br>2、从阻塞队列读数据时，如果队列为空，线程将会阻塞等待直到队列⾥⾯是⾮空的时候</p></blockquote><h3 id="ArrayBlockingQueue："><a href="#ArrayBlockingQueue：" class="headerlink" title="ArrayBlockingQueue："></a>ArrayBlockingQueue：</h3><blockquote><p>基于数组实现的⼀个阻塞队列，需要指定容量⼤⼩，FIFO先进先出顺序</p></blockquote><h3 id="LinkedBlockingQueue："><a href="#LinkedBlockingQueue：" class="headerlink" title="LinkedBlockingQueue："></a>LinkedBlockingQueue：</h3><blockquote><p>基于链表实现的⼀个阻塞队列，如果不指定容量⼤⼩，默认Integer.MAX_VALUE, FIFO先进先出顺序</p></blockquote><h3 id="PriorityBlockingQueue："><a href="#PriorityBlockingQueue：" class="headerlink" title="PriorityBlockingQueue："></a>PriorityBlockingQueue：</h3><blockquote><p>⼀个⽀持优先级的⽆界阻塞队列，默认情况下元素采⽤⾃然顺序升序排序，也可以⾃定义排序实现 java.lang.Comparable接⼝</p></blockquote><h3 id="DelayQueue："><a href="#DelayQueue：" class="headerlink" title="DelayQueue："></a>DelayQueue：</h3><blockquote><p>延迟队列，在指定时间才能获取队列元素的功能，队列头元素是最接近过期的元素，⾥⾯的对象必须实现 java.util.concurrent.Delayed 接⼝并实现<br>CompareTo和getDelay⽅法</p></blockquote><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><blockquote><p>并发队列ConcurrentLinkedQueue是基于链表实现的⽆界线程安全队列，采⽤FIFO进⾏排序<br>保证线程安全的三要素：原⼦、有序、可⻅性<br>1、底层结构是Node，链表头部和尾部节点是head和tail，使⽤节点变量和内部类属性使⽤<br>volatile声明保证了有序和可⻅性<br>2、插⼊、移除、更新操作使⽤CAS⽆锁操作，保证了原⼦性</p></blockquote><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote><p>提⾼系统资源的使⽤率，同时避免过多资源竞争，避免堵塞，且可以定时定期执⾏、单线程、并发数控制，配置任务过多任务后的拒绝策略等功能</p></blockquote><h3 id="线程池分类"><a href="#线程池分类" class="headerlink" title="线程池分类"></a>线程池分类</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><blockquote><p>⼀个定⻓线程池，可控制线程最⼤并发数</p></blockquote><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><blockquote><p>⼀个可缓存线程池</p></blockquote><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><blockquote><p>⼀个单线程化的线程池，⽤唯⼀的⼯作线程来执⾏任务</p></blockquote><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><blockquote><p>⼀个定⻓线程池，⽀持定时/周期性任务执⾏</p></blockquote><h3 id="线程池踩坑"><a href="#线程池踩坑" class="headerlink" title="线程池踩坑"></a>线程池踩坑</h3><h4 id="推荐ThreadPoolExecutor的⽅式原因"><a href="#推荐ThreadPoolExecutor的⽅式原因" class="headerlink" title="推荐ThreadPoolExecutor的⽅式原因"></a>推荐ThreadPoolExecutor的⽅式原因</h4><ol><li>newFixedThreadPool和newSingleThreadExecutor:<blockquote><p>队列使⽤LinkedBlockingQueue，队列⻓度为 Integer.MAX_VALUE，可能造成堆积，导致OOM</p></blockquote></li><li>newScheduledThreadPool和newCachedThreadPool:         <blockquote><p>线程池⾥⾯允许最⼤的线程数是Integer.MAX_VALUE，可能会创建过多线程，导致OOM</p></blockquote><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><h4 id="corePoolSize："><a href="#corePoolSize：" class="headerlink" title="corePoolSize："></a>corePoolSize：</h4><blockquote><p>核⼼线程数，线程池也会维护线程的最少数量，默认情况下核⼼线程会⼀直存活，即使没有任务也不会受存keepAliveTime控制<br>坑：在刚创建线程池时线程不会⽴即启动，到有任务提交时才开始创建线程并逐步线程数⽬达到corePoolSize</p></blockquote><h4 id="maximumPoolSize："><a href="#maximumPoolSize：" class="headerlink" title="maximumPoolSize："></a>maximumPoolSize：</h4><blockquote><p>线程池维护线程的最⼤数量，超过将被阻塞<br>坑：当核⼼线程满，且阻塞队列也满时，才会判断当前线程数是否⼩于最⼤线程数，才决定是否创建新线程</p></blockquote><h4 id="keepAliveTime："><a href="#keepAliveTime：" class="headerlink" title="keepAliveTime："></a>keepAliveTime：</h4><blockquote><p>⾮核⼼线程的闲置超时时间，超过这个时间就会被回收，直到线程数量等于corePoolSize</p></blockquote><h4 id="unit："><a href="#unit：" class="headerlink" title="unit："></a>unit：</h4><blockquote><p>指定keepAliveTime的单位，如TimeUnit.SECONDS、TimeUnit.MILLISECONDS</p></blockquote><h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue:"></a>workQueue:</h4><blockquote><p>线程池中的任务队列,常⽤的是 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue</p></blockquote><h4 id="threadFactory："><a href="#threadFactory：" class="headerlink" title="threadFactory："></a>threadFactory：</h4><blockquote><p>创建新线程时使⽤的⼯⼚</p></blockquote><h4 id="handler"><a href="#handler" class="headerlink" title="handler:"></a>handler:</h4><blockquote><p>RejectedExecutionHandler是⼀个接⼝且只有⼀个⽅法,线程池中的数量⼤于maximumPoolSize，对拒绝任务的处理策略，默认有4种策略AbortPolicy、<br>CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy</p></blockquote></li></ol><h4 id="线程池的选择"><a href="#线程池的选择" class="headerlink" title="线程池的选择"></a>线程池的选择</h4><ol><li>针对<strong>高并发，执行时间短的任务</strong>，线程池的核心线程数应为CPU核数+1，减少上下文切换</li><li>针对<strong>并发不高，但是执行时间比较长</strong>的业务<ul><li><strong>IO密集型</strong>，因为IO操作不占用CPU，所以不必要让CPU闲下来，应该设置较多线程数</li><li><strong>计算密集型</strong>，因为计算需要大量占用CPU，则应该较少的设置核心线程数</li></ul></li></ol><h2 id="ThreadLoacl"><a href="#ThreadLoacl" class="headerlink" title="ThreadLoacl"></a>ThreadLoacl</h2><p><img src="https://i.loli.net/2020/07/28/nFbdPvGTR7IjLct.jpg" alt="ThreadLocal数据结构.jpg"></p><ul><li>每一个线程自己维护了ThreadLocalMap<ul><li>ThreadLocalMap的key是ThreadLocal对象本身 （是弱引用，检测到就会gc回收掉）</li><li>Value则是ThreadLocal中的值</li></ul></li><li>ThreadLoaclmap的桶的算法<ul><li>int i = key.threadLocalHashCode &amp; (len-1);<ul><li>key则是threadlocal</li><li>threadLocalHashCode是threadlocal自己维护的</li><li>threadLocalHashCode 是 每次添加一个对象后内部再加上一个斐波那契数 </li><li>之后与容量做与运算，得到桶的位置</li></ul></li></ul></li><li>ThreadLocalMap.set()其实有四种情况需要考虑<ol><li>通过hash计算得到的槽的数据是为空的（key为空，entry为空，也就是没有被占用）<ul><li>直接插入槽位</li></ul></li><li>通过hash计算发现得到的槽位的数据不为空，key不为空，entry也不为空，同时hash计算的key和找到的key是一样的<ul><li>直接在槽位上更新数据</li></ul></li><li>通过hash计算发现得到的槽位的数据都不为空，且key是不一样的，同时在找到key，entry为空的槽位之前，没有遇到key过期，entry不为空的情况<ul><li><strong>由于threadlocalmap的hash冲突是向后找空插入的</strong></li><li>因此直接向后查找，找到空的槽位直接插入就好</li><li>如果是向后查找的过程中有了key相同的，也可以直接更新数据</li></ul></li><li>通过hash计算发现得到的槽位的数据都不为空，且在找到key，entry为空的槽位之前，遇到了key过期，entry不为空的情况<ul><li>由于ThreadlocalMap的key是维护的弱引用，因此会出现key被回收的情况</li><li>会启用探测<br>  <img src="https://i.loli.net/2020/08/11/2kxVwjBRP9MFYWu.jpg" alt="探测A.jpg"><br>  往后遍历过程中，散列数组下标为7位置对应的Entry数据key为null，表明此数据key值已经被垃圾回收掉了<ol><li>执行replaceStaleEntry()<ul><li>初始化探测式清理过期数据扫描的开始位置：slotToExpunge = staleSlot = 7</li></ul></li><li>以stableSlot为起点，向前进行探测<ul><li>如果向前探测的过程中，遇到了key为null的，entry不为null的，也就是key过期的值，则更新slotToExpunge的值</li><li>直到遇到空槽位，也就是key，entry都为null的位置，则停止向前的探测</li></ul></li><li>之后执行stableSlot向后的探测 （又分成两钟情况）<ul><li>找到了key值相同的槽位<ul><li>则直接更新数据，且更新stableslot的下标</li><li>然后进行过期清理，从slotToExpunge到staleSlot进行清理<br>  <img src="https://i.loli.net/2020/08/11/mcUnC3X57jbKNAq.jpg" alt="探测B.jpg"></li></ul></li><li>没有找到key值相同的槽位<ul><li>则向后继续查找，直到直到空槽位（key，entry都为空）则停止<br>  <img src="https://i.loli.net/2020/08/11/iIYeDugKmyVtTkd.jpg" alt="探测C.jpg"></li><li>之后再执行过期清理，从slotToExpunge到staleSlot进行清理</li></ul></li></ul></li></ol></li></ul></li></ol></li><li>ThreadLocalmap清理过程<ul><li>cleanSomeSlots（）启发式清理<ul><li>启发式清理就是把i后移，直到全部探测清理完毕</li></ul></li><li>expungeStaleEntries（）探测式清理<ul><li>从index向后探测，如果是过期key则删除，同时size–，直到遍历到空槽</li><li>之后对散列表重hash，把之前因为hash冲突而放到后面的key-value放到更接近槽的位置</li></ul></li><li>实际上是cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</li></ul></li></ul><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>AtomicInteger 为例</p><ul><li>volatile保证了数据的可见性，但是没有保证原子性</li><li>因此使用CAS保证了volatile的原子性，也就是compareAndSwapInt()方法实现了CAS</li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IO复习总结</title>
    <link href="http://runindark.com/2020/07/18/2020%E7%A7%8B%E6%8B%9B/IO/"/>
    <id>http://runindark.com/2020/07/18/2020秋招/IO/</id>
    <published>2020-07-18T04:16:27.310Z</published>
    <updated>2020-07-24T18:06:07.918Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Linux的五种IO模型"><a href="#Linux的五种IO模型" class="headerlink" title="Linux的五种IO模型"></a>Linux的五种IO模型</h2><ol><li>阻塞IO<blockquote><p>进程或线程等待某个条件，如果不满足则一直等待，进入阻塞</p></blockquote></li><li>非阻塞IO<blockquote><p>如果不满足条件则直接返回，然后轮询全部的请求，如果满足条件则读取</p></blockquote></li><li>信号驱动IO模型<blockquote><p>由于轮询的效率还是不够高，那么则采用信号机制，也就是说采用报警器，如果满足条件则内核让进程去读取</p></blockquote></li><li>IO复用模型<blockquote><p>添加select函数去监听所有的请求，如果哪个成功则直接进行IO读取</p></blockquote></li><li>异步IO模型<blockquote><p>IO读取由内核自己完成，如果读取完则直接告诉进程读取完成</p></blockquote></li></ol><h2 id="Java中的IO"><a href="#Java中的IO" class="headerlink" title="Java中的IO"></a>Java中的IO</h2><ul><li>BIO</li><li>NIO<ul><li>原理图<br>  <img src="https://i.loli.net/2020/07/25/PXLD8Msaf7IoAZ1.jpg" alt="nio基础模型.jpg"><ul><li>channel<br>  数据通过channel到达buffer，之后从buffer再读取到线程</li><li>buffer<br>  作为nio的重要实现，数据不需要像javaIO阻塞读取，而是可以一直被读取，而不影响线程的其它操作</li><li>总结分析<br>  NIO是<strong>同步非阻塞IO</strong>，由于buffer的实现，那么假如有数据需要读取到线程中，那么可以先读取到channel，再读取到buffer，但是如果数据没有完全读取完，<strong>线程在buffer还在不停的被读入数据的同时做其它的操作</strong></li></ul></li><li>selector<br>  <img src="https://i.loli.net/2020/07/25/ybOaCHgf5QPic36.jpg" alt="nio_selector.jpg"><br>  进一步的非阻塞，线程不会只是一个channel写入数据，单个线程可以利用selector控制多个channel写入数据</li></ul></li><li>AIO<blockquote><p>NIO的进化版本，同步的io需要线程本身的资源去读取，而非阻塞异步io，数据的读取过程由内核自己完成，当成功读取到线程中后，会有操作系统来提示线程数据读取完成。</p></blockquote></li></ul><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><blockquote><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p></blockquote><ul><li>select<ul><li>维护了三个状态数组，分别是<ul><li>fd_set* writefds</li><li>fd_set* readfds</li><li>fd_set* exceptfds</li></ul></li><li>通过遍历这三个数组则可以获取到状态</li><li><strong>问题：</strong> 单个进程可以监控的文件描述符有限，linux上是1024个</li></ul></li><li><p>poll</p><ul><li><p>select的进化，三个数组变成一个pollfd链表</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>问题：</strong> 虽然说取消了1024的限制，但是如果变长，效率还是很差</p></li></ul></li><li><p>epoll</p><ul><li>将改进转移到内核中，将<strong>用户关系的文件描述符的事件</strong>存放到<strong>内核的一个事件表</strong>中</li><li><p>epoll的操作过程</p><ul><li>int epoll_create(int size);、<br>  初始化<strong>内核中</strong>事件表的大小，size参数则是指定的大小，但是并不做限制，只是建议</li><li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</p><ul><li>epfd 是 epoll_create()的返回值</li><li>op 是 add，mod，del （增删改查的操作）</li><li>fd 监听的文件描述符</li><li>epoll_event 表示监听的具体什么事件的数组  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event &#123;</span><br><span class="line">    __uint32_t events;  /* Epoll events */</span><br><span class="line">    epoll_data_t data;  /* User data variable */</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //events可以是以下几个宏的集合：</span><br><span class="line">    EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">    EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">    EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">    EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">    EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">    EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">    EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure></li></ul></li><li><p>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);<br>  epoll_create（）返回的<strong>内核处理的事件结果</strong></p><ul><li>epfd 是 epoll_wait的结果</li><li>events 是内核上处理的事件的集合</li><li>maxevent就是告诉内核这些事件有多大，小于创建时的size</li><li>事件的超时事件</li></ul></li></ul></li><li><p>epoll的工作方式</p><ul><li>LT : 可以暂时不处理，等下次再来处理</li><li>ET ：需要立刻处理</li></ul></li><li><p>epoll的全流程总结</p><blockquote><p>epoll首先需要利用epoll_create()去创建一个句柄，方便直接联系到内核<br>之后利用epoll_ctl()去为epoll_create()在内核中空间创建的时间表中，添加文件描述符，或为文件描述符添加，删除或者是修改事件<br>注意一个文件描述符可以添加很多的描述的事件<br>之后，由于内核中存在事件表，如果事件表发生某种变化，可以利用一种callback的方式回调到epoll中<br>这个时候如果调用epoll_wait则可以获取这些状态 （减少了轮询，而是直接通知到epoll）</p></blockquote></li></ul></li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="IO" scheme="http://runindark.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习总结</title>
    <link href="http://runindark.com/2020/07/16/2020%E7%A7%8B%E6%8B%9B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://runindark.com/2020/07/16/2020秋招/计算机网络/</id>
    <published>2020-07-16T12:50:16.525Z</published>
    <updated>2020-09-02T02:45:48.216Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="五层体系网络结构"><a href="#五层体系网络结构" class="headerlink" title="五层体系网络结构"></a>五层体系网络结构</h2><ul><li>应用层<ul><li>http协议</li><li>dns协议</li><li>smtp电子邮件协议</li></ul></li><li>运输层<ul><li>tcp</li><li>udp</li></ul></li><li>网络层<ul><li>网络路由之间的数据传输</li></ul></li><li>数据链路层<ul><li>主机之间的数据传输</li></ul></li><li>物理层<ul><li>数据到主机之间的最低级传输</li></ul></li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h3><p><img src="https://i.loli.net/2020/07/18/Riza942VOKIYfbh.jpg" alt="三次握手.jpg"></p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><p><img src="https://i.loli.net/2020/07/18/cNTwbkAiP9FeD4z.jpg" alt="四次挥手.jpg"></p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li></ul><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p><img src="https://i.loli.net/2020/07/18/PwaJHm2gliRZAdk.jpg" alt="TCP和UDP.jpg"></p><h3 id="TCP如何保证可靠传送"><a href="#TCP如何保证可靠传送" class="headerlink" title="TCP如何保证可靠传送"></a>TCP如何保证可靠传送</h3><ul><li>TCP会自动把数据拆分成合适大小的数据块</li><li>TCP会把切割好的数据块进行编号</li><li>TCP会自动丢弃重复的数据</li><li><strong>超时重传</strong></li><li><strong>窗口滑动</strong></li><li><strong>ARQ协议</strong></li><li><strong>拥塞控制</strong>:TCP在网络拥塞的时候减少数据发送</li><li>校验和: TCP保持它的首部和数据的校验和</li></ul><h4 id="窗口滑动"><a href="#窗口滑动" class="headerlink" title="窗口滑动"></a>窗口滑动</h4><blockquote><p>TCP维护了<strong>发送端缓存窗口</strong>以及<strong>接收方缓存窗口</strong>，滑动窗口也可以理解为动态窗口，接受的时候接收端只能从<strong>接受缓存窗口中的数据</strong>去接受，发送方只能把数据发送到<strong>发送缓存窗口</strong>，<br>在带宽比较好的时候则窗口变大，速度也变大，太短较慢的时候窗口变小，这样子不会造成拥堵</p></blockquote><h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><ul><li><p>停止等待ARQ协议</p><blockquote><p>每当发送一段数据，那么要等对方确认这段数据被接收，才会发送下一段数据;如果发送失败，则会触发<strong>超时重传</strong></p></blockquote></li><li><p>连续ARQ协议</p><blockquote><p>发送数据的时候维护一个发送窗口，只要是处于发送窗口，就可以<strong>一直发送数据，不需要等接收方确认</strong>，每当接收到一个ACK则把窗口移动即可。<br>但是会存在回退的问题，如果发送5个分组，第3个丢失了，那么后面的全部都会丢失，只能把后三个重新传输一次</p></blockquote></li></ul><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul><li>慢开始<blockquote><p>由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，拥塞窗口cwnd加倍</p></blockquote></li><li>拥塞避免<blockquote><p>拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1</p></blockquote></li><li>快重传<blockquote><p>当接收方收到不是按照TCP编号排序的分组，则应当发送重新确认，一旦重新确认次数为3次，则立即重新传输丢失的分组</p></blockquote></li><li><p>快恢复</p><blockquote><p>当收到三个重复确认，确认丢失的时候则将ssthresh门限减半，将cwnd设置为ssthresh的大小，并开始使用拥塞避免算法（因为能连续收到3个确认，则没必要再慢开始）</p></blockquote></li><li><p>算法使用条件</p><ul><li>当cwnd&lt;ssthresh时，使用慢开始算法。</li><li>当cwnd&gt;ssthresh时，改用拥塞避免算法。</li><li>当cwnd=ssthresh时，慢开始与拥塞避免算法任意</li></ul></li></ul><h3 id="time-wait-和-time-close"><a href="#time-wait-和-time-close" class="headerlink" title="time_wait 和 time_close"></a>time_wait 和 time_close</h3><p><img src="https://i.loli.net/2020/08/15/TzcfryQKVHuNICg.png" alt="time_close分析.png"><br>在图中的情况，由于SEQ=3被丢弃了，本质上这段tcp链接是不能复用了，但是第二次的时候，这段错误的TCP还是被使用，这样会导致错误不断的延续下去，同时数据也会发生错误。</p><ul><li>time_Wait存在的原因<ol><li>为了保证tcp连接不会被重用，导致错误延续<ul><li>TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭。</li><li>TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间<ul><li>等待2MSL是为了保证链接的上数据要么一定处理完成，要么别直接丢弃。不会干扰第二个链接的建立</li><li>如果没有time_wait比较短，或者没有time_wait则会直接进入上图的那种错误情况</li></ul></li><li>CLOSE_WAIT 是被动关闭连接是形成的。</li></ul></li><li>为了保证连接的正常关闭<ul><li>如果接收方发送fin之后，发送方发送的ack意外丢失</li><li>导致接收方会继续发送fin，使得接收方产生RST（复位标识，重建连接）</li></ul></li></ol></li></ul><h2 id="从输入Url到底发生了什么"><a href="#从输入Url到底发生了什么" class="headerlink" title="从输入Url到底发生了什么"></a>从输入Url到底发生了什么</h2><p><img src="https://i.loli.net/2020/07/18/ILC5lzpTGd9KE6F.jpg" alt="url到前端.jpg"></p><p>url -&gt; 浏览器缓存 -&gt; dns -&gt; tcp -&gt; 服务端 -&gt; 返回请求 -&gt; 浏览器渲染</p><h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><h3 id="http1-0-和-http1-1"><a href="#http1-0-和-http1-1" class="headerlink" title="http1.0 和 http1.1"></a>http1.0 和 http1.1</h3><ul><li>http1.1把http1.0默认的短连接改为长连接</li><li>http1.1新增状态码，比如410表示资源从服务器上删除</li><li>http1.1头部引入range，http1.0一旦发送请求会把所有的内容都请求过来，通过range可以请求到自己需要的数据就好</li><li>缓存处理，引入了更多的缓存策略</li></ul><h3 id="http-和-https"><a href="#http-和-https" class="headerlink" title="http 和 https"></a>http 和 https</h3><ul><li>http默认使用80，https则默认使用443</li><li>HTTPS协议需要到CA申请证书</li><li><p>https运行再ssl之上<br><img src="http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribXL5PwzkqQdmyY9egu2hpzzMCgz2F5HhhkdSNc5eYJ9UGMDBGjeCGiag/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="https和http"></p></li><li><p>所有传输的内容都经过加密，<strong>加密采用对称加密</strong>，但对称加密的密钥用服务器方的<strong>证书进行了非对称加密</strong>。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p><ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等</li></ul></li></ul><h3 id="ssl过程"><a href="#ssl过程" class="headerlink" title="ssl过程"></a>ssl过程</h3><ol><li>客户端发送请求<ul><li>发送<strong>版本号</strong></li><li>客户端生成一个<strong>随机数（第一个）</strong></li><li>支持的<strong>加密方式</strong></li></ul></li><li>服务器回应请求<ul><li>确认版本号</li><li>服务端生成一个<strong>随机数（第二个）</strong></li><li>确认使用的加密方式</li><li>发送<strong>证书</strong></li></ul></li><li>客户端回应请求<ul><li>客户端生成一个<strong>随机数（第三个）</strong></li><li>将随机数用<strong>公匙</strong>加密，</li></ul></li><li>服务端最后回应请求<ul><li>服务端收到三个随机数后生成<strong>会话密匙</strong></li></ul></li></ol></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://runindark.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java集合复习总结</title>
    <link href="http://runindark.com/2020/07/16/2020%E7%A7%8B%E6%8B%9B/%E9%9B%86%E5%90%88/"/>
    <id>http://runindark.com/2020/07/16/2020秋招/集合/</id>
    <published>2020-07-16T06:41:31.145Z</published>
    <updated>2020-07-18T04:57:39.182Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul><li>Vector<ul><li>线程安全</li></ul></li><li>ArrayList<ul><li>基于数组实现</li><li>适合读，不适合改</li><li>线程不安全</li></ul></li><li>LinkedList<ul><li>基于链表实现</li><li>适合修改，但不适合读</li><li>线程不安全</li></ul></li><li>CopyOnWriteArrayList<ul><li>读写分离</li><li>在执行修改操作的时候会复制一块新的空间</li><li>写操作会出现进程阻塞，但是读操作不会</li></ul></li><li>Collectionbs.synchronizedlist<ul><li>线程安全所有方法都加了synchronized关键字</li></ul></li></ul><h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><ul><li>扩容机制以及初始化<ul><li>JDK1.7之前默认大小为10，JDk1.8之后，之后开始使用list集合才会分配10的空间</li><li>1.5倍扩容</li></ul></li><li>读写操作分析<ul><li>扩容<br>扩容利用Arrays.copyOf() (在原来的数组中重新创建数组) 进行扩容</li><li>插入或修改<br>利用System.arraycopy()进行操作，如果是删除，则向前移动，如果是插入则向后移动<h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3></li></ul></li><li>删除插入都比较容易双向链表的插入</li><li><p>在指定位置插入数据</p><ul><li>toArray转化成对象数组</li><li>之后遍历对象数组</li><li>之后再插入<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2></li></ul></li><li><p>hashmap</p><ul><li>线程不安全</li><li>默认大小16</li><li>可以存储值为null的key和value</li><li>双倍扩容</li></ul></li><li>hashtable<ul><li>线程安全</li><li>默认大小11</li><li>不可以存储值为null的key和value</li><li>2n+1倍扩容</li></ul></li><li>concurrentHashmap<ul><li>线程安全</li><li>读取用cas，更改用synchronized</li><li>发生hash冲突，会用cas写入</li></ul></li></ul><h3 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h3><ul><li>参阅原帖<br>  <a href="https://blog.csdn.net/v123411739/article/details/78996181" target="_blank" rel="noopener">hashmap</a></li><li>扩容机制和默认大小<br>  默认大小为16，扩容为双倍扩容</li><li>链表转红黑树<br>  当链表节点超过8时，转为红黑树</li><li>红黑树转链表<br>  6个节点红黑树转回链表</li><li><p>定位哈希桶数组的位置<br>  <img src="https://i.loli.net/2020/07/18/O5SaVqh9uyYC7Q4.jpg" alt="hash桶.jpg"></p><ol><li>获取map中 key的hash值</li><li>将 hashCode 的高位参与运算，重新计算 hash 值（当table比较小的时候，让高位也参与运算）<ul><li>hashcode 异或 hashcode高16位 以此获取hash值</li><li>如果没有这一步，table长度为16，直接进行 与 运算，那么高28位的运算结果都是0，那么hash桶则只在15的区间内分布，那么hash冲突的概率就会上升。<br><img src="https://i.loli.net/2020/07/18/w2FxO7p1GjvJySU.jpg" alt="hashmap1.8优化.jpg"></li></ul></li><li>计算出来的 hash 值与 (table.length - 1) 进行 &amp; 运算</li></ol></li><li><p>jdk1.7为头插法，jdk1.8改为尾插法</p></li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="集合" scheme="http://runindark.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>框架复习总结</title>
    <link href="http://runindark.com/2020/07/12/2020%E7%A7%8B%E6%8B%9B/%E6%A1%86%E6%9E%B6/"/>
    <id>http://runindark.com/2020/07/12/2020秋招/框架/</id>
    <published>2020-07-12T15:12:55.051Z</published>
    <updated>2020-09-14T13:12:16.441Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="IOC控制翻转和DI"><a href="#IOC控制翻转和DI" class="headerlink" title="IOC控制翻转和DI"></a>IOC控制翻转和DI</h2><p><img src="https://i.loli.net/2020/07/12/PtGuHK12XoI9Qf5.jpg" alt="控制反转-依赖注入.jpg"></p><blockquote><p>控制反转和依赖注入其实说的是一个东西，为了解耦，将创建对象的任务交付给Spring的容器来创建，而不是用new来创建。</p></blockquote><h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><h3 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h3><ul><li>Singleton : 单例，在IOC容器中只存在一个，会在容器内缓存</li><li>prototype : 多例，利用getBean()频繁创建，同时也会频繁的销毁</li><li>Web<ul><li>request : 每一次 HTTP 请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效</li><li>session : session 作用域表示该针对每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效</li><li>global session</li></ul></li></ul><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p><img src="https://i.loli.net/2020/07/17/gtXnOM6Geyv4h1i.jpg" alt="bean生命周期.jpg"><br>bean的生命周期分为四个阶段</p><ol><li>实例化 (createBeanInstance)<ul><li>resolveBeforeInstantiation<ul><li>InstantiationAwareBeanPostProcessor</li></ul></li></ul></li><li>属性赋值(populateBean)</li><li>初始化(initializeBean)<ul><li>后置修正<ul><li>检查是否实现了Aware类的接口</li><li>然后判断（invokeAware） BeanNameAware,BeanFactoryAware,ApplicationContextAware接口</li><li>BeanPostProcessor<ul><li>postProcessBeforeInitialzation</li><li>postConstruct</li><li>postProcessAfterInitialzation</li></ul></li></ul></li><li>InitializingBean 可以在正式完成前增加自定义逻辑</li><li>为了减小侵入程度，bean提供了配置init-method，通过设置函数名，然后在InitializingBean中完成指定函数逻辑</li></ul></li><li>销毁</li></ol><h2 id="静态代理和动态代理"><a href="#静态代理和动态代理" class="headerlink" title="静态代理和动态代理"></a>静态代理和动态代理</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>A方法需要C方法来修饰，那么需要创建B实现A+C，之后调用B来实现<br><img src="https://i.loli.net/2020/07/12/in1JIsCrfOvyj8d.jpg" alt="静态代理.jpg"></p></blockquote><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/49790288.jpg" alt=""></p><p><img src="https://i.loli.net/2020/07/18/viBtdYRCmyUFW9O.jpg" alt="springmvc执行流程.jpg"></p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul><li>Proxy + InvocationHandler<br>被代理对象接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>被代理类接口实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add user into database."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        System.out.println(<span class="string">"getUser from database."</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代理（中间）类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtil</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;    <span class="comment">// 被代理的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do sth before...."</span>);</span><br><span class="line">        Object result =  method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"do sth after...."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ProxyUtil(Object target)&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object proxyedObject = <span class="keyword">new</span> UserServiceImpl();    <span class="comment">// 被代理的对象</span></span><br><span class="line">        ProxyUtil proxyUtils = <span class="keyword">new</span> ProxyUtil(proxyedObject);</span><br><span class="line">        <span class="comment">// 生成代理对象，对被代理对象的这些接口进行代理：UserServiceImpl.class.getInterfaces()</span></span><br><span class="line">        UserService proxyObject = (UserService) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), </span><br><span class="line">                    UserServiceImpl.class.getInterfaces(), proxyUtils);</span><br><span class="line">        proxyObject.getUser(<span class="number">1</span>);</span><br><span class="line">        proxyObject.addUser(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>核心则在于被代理的对象必须要有含有自己方法的接口，才可以使用Proxy+InvocationHandler，同时，代理类中主要是通过调用被重写的invoke（）方法。</p></blockquote><ul><li>CGlib + MethodInterceptor</li></ul><p>Cglib代理的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;    <span class="comment">// 被代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method arg1, Object[] arg2, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do sth before...."</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(arg0, arg2);</span><br><span class="line">        System.out.println(<span class="string">"do sth after...."</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());    <span class="comment">// 设置父类</span></span><br><span class="line">        <span class="comment">// 设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);    <span class="comment">// 在调用父类方法时，回调 this.intercept()</span></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object proxyedObject = <span class="keyword">new</span> UserServiceImpl();    <span class="comment">// 被代理的对象</span></span><br><span class="line">        CGProxy cgProxy = <span class="keyword">new</span> CGProxy(proxyedObject);</span><br><span class="line">        UserService proxyObject = (UserService) cgProxy.getProxyObject();</span><br><span class="line">        proxyObject.getUser(<span class="number">1</span>);</span><br><span class="line">        proxyObject.addUser(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>与Proxy+InvocationHandler不同，Cglib是利用enhancer.create创造了一个代理对象，而这个大力对象的父类就是被代理类，利用enhancer.setSuperclass()指定，同时利用enhancer.setCallback()回调被重写的intercept，完成对方法的包裹</p></blockquote><h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><blockquote><p>事务是<strong>一组</strong>操作，要么全部成功，要么全部失败</p><ul><li>事务特性 ACID<ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul></li></ul></blockquote><h3 id="事务分类"><a href="#事务分类" class="headerlink" title="事务分类"></a>事务分类</h3><ul><li>声明式事务（推荐，@Transactional）</li><li>编程式事务 （TransactionManager）<h3 id="事务隔离级别（和mysql一直）"><a href="#事务隔离级别（和mysql一直）" class="headerlink" title="事务隔离级别（和mysql一直）"></a>事务隔离级别（和mysql一直）</h3></li></ul><ul><li>未提交读</li><li>提交读</li><li>可重复读</li><li>串行化<h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3></li></ul><ul><li>PROPAGATION_REQUIRED（默认开启）<ul><li>如果外部没有开启事务，则内部自己开启子事务</li><li>如果外部开启事务，则内部和外部属于同一个事务</li></ul></li><li>PROPAGATION_REQUIRES_NEW<ul><li>不论外部有没有开启事务，则内部自己都开启子事务</li><li>如果当前已存在事务，则直接挂起</li></ul></li><li>PROPAGATION_NESTED<ul><li>外部未开启事务，和require一样</li><li>外部开启事务，则内部方法变成子事务，可以一起会滚，内部的子事务可以独立回滚</li></ul></li><li>PROPAGATION_MANDATORY<ul><li>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li></ul></li></ul><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p><img src="https://i.loli.net/2020/07/12/CMxHmBaleUA7d8V.jpg" alt="JDBC.jpg"></p><blockquote><p>一般来说多使用PreparedStatement在执行之前会进行预编译<br>效率高于Statement,且能够有效防止SQL注入<br>PreparedStatement支持?占位符而不是直接拼接，提高可读性</p></blockquote><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul><li>Mybatis工作流程<br><img src="https://i.loli.net/2020/07/13/N2x4z1bkUsB8uCW.jpg" alt="Mybatis.jpg"></li><li>Myabtis多级缓存<br><img src="https://i.loli.net/2020/07/13/lEtTkvVJLHZcXB5.jpg" alt="Mybatis缓存.jpg"></li></ul><blockquote><p>当一级缓存和耳机缓存同时打开的时候，先到二级缓存再到一级缓存</p></blockquote><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><h3 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h3><p>自动装配原理主要集中在@SpringbootApplication注解中</p><ul><li>@EnableAutoConfiguration<br>  启用 SpringBoot 的自动配置机制</li><li>@Configuration<br>  启用 SpringBoot 的自动配置机制</li><li>@ComponentScan<br>  扫描被@Component (@Service,@Controller)注解的bean，注解默认会扫描该类所在的包下所有的类</li></ul><p><img src="https://i.loli.net/2020/07/25/aXsUJvcjWm9nx3e.jpg" alt="Springboot自动装配原理.jpg"></p><ol><li>进入@SpringbootApplication</li><li>利用@EnableAutoConfiguration注解开启自动装配</li><li>在EnableAutoConfiguration接口的实现中利用@Import主节导入了 EnableAutoConfigurationImportSelector.class</li><li>EnableAutoConfigurationImportSelector 的父类AutoConfigurationImportSelector利用List集合存储了配置信息<ul><li>在AutoConfigurationImportSelector中selectImports()方法详解<br><img src="https://i.loli.net/2020/09/01/R8P43xGkBav9ZNJ.jpg" alt="selectImport.jpg"></li><li>第一步会优先的判断是不是开启了自动装配，如果没有开启的话则返回<strong>空数组</strong></li><li>之后会找到一个spring-autoconfigure-metadata.properties的文件去预加载一些配置文件<ul><li>tips：（这个文件是，如果要加载一个类，那么要加载这个类需要的其它的类或是配置）</li></ul></li><li>之后利用 <strong>this.getCandidateConfigurations</strong> 在List中存储相关的配置文件</li><li>之后用<strong>Set<string> exclusions = this.getExclusions</string></strong>去除list中的配置<ul><li>tips：这个地方是@EnableAutoConfiguration上一些exclude、excludeName属性</li></ul></li><li>最后返回一个String[]的数组</li></ul></li><li>其中getcandidateConfiguration中是利用SpringFactoriesloader获取了配置对象</li></ol><h3 id="Springboot执行流程"><a href="#Springboot执行流程" class="headerlink" title="Springboot执行流程"></a>Springboot执行流程</h3><ol><li>StopWatch stopWatch = new StopWatch();用来记录时间</li><li>SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting();<ul><li>在start方法中使用ApplicationStartingEvent(this.application, this.args)); </li><li>监听所有的启动事件</li></ul></li><li>ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments); <ul><li>创建运行时环境 StandardServletEnvironment</li><li>配置配置<strong>PropertySources</strong></li><li>配置<strong>Profiles</strong></li></ul></li><li>configureIgnoreBeanInfo(environment); // 获取系统属性</li><li>context = createApplicationContext(); // 创建相应的环境<ul><li>创建ApplicationContext</li></ul></li><li>exceptionReporters = getSpringFactoriesInstances(); <ul><li>SpringBoot启动失败后异常处理相关的组件</li></ul></li><li>refreshContext(context); // 初始化容器</li><li>发送发送ApplicationReadyEvent事件</li></ol></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="框架" scheme="http://runindark.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis复习总结</title>
    <link href="http://runindark.com/2020/07/12/2020%E7%A7%8B%E6%8B%9B/Redis/"/>
    <id>http://runindark.com/2020/07/12/2020秋招/Redis/</id>
    <published>2020-07-12T02:36:30.624Z</published>
    <updated>2020-08-14T13:44:51.534Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Redis内存模型"><a href="#Redis内存模型" class="headerlink" title="Redis内存模型"></a>Redis内存模型</h2><h3 id="Redis内存分配"><a href="#Redis内存分配" class="headerlink" title="Redis内存分配"></a>Redis内存分配</h3><ul><li>数据 ：Redis存储的数据对象 字符串、哈希、列表、集合、有序集合 </li><li>进程本身所需内存 ： Redis进程自己运行所需要的内存，比如代码，占用内存，常量池等</li><li>缓存内存： <ul><li>客户端缓冲区 ： 连接客户端输入输出的缓存</li><li>复制积压缓冲区： 在主从同步时，非全量复制时，所需要的缓存区</li><li>复制积压缓冲区： AOF写入时的缓存</li></ul></li><li>内存碎片：内存碎片是Redis在分配、回收物理内存过程中产生的</li></ul><h3 id="Redis内存分配器-（jemalloc）"><a href="#Redis内存分配器-（jemalloc）" class="headerlink" title="Redis内存分配器 （jemalloc）"></a>Redis内存分配器 （jemalloc）</h3><ul><li>jemalloc 将空间分为 小（Small）、大（Large）、巨大（Huge）三种<br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001126509-2023165562.png" alt="jemalloc"></li></ul><h3 id="Redis内存统计"><a href="#Redis内存统计" class="headerlink" title="Redis内存统计"></a>Redis内存统计</h3><ul><li>used_memory （Redis内存分配器分配的内存）<blockquote><p>存储的数据的内存</p></blockquote></li><li>used_memory_rss （Redis占操作系统的内存）<blockquote><p>包括存储的数据内存还有内存碎片以及Redis本身占用内存</p></blockquote></li></ul><h3 id="Redis数据的存储过程"><a href="#Redis数据的存储过程" class="headerlink" title="Redis数据的存储过程"></a>Redis数据的存储过程</h3><ul><li><p>RedisObject<br><img src="https://i.loli.net/2020/07/12/xQOXjFEvNzgoaf8.jpg" alt="RedisObject"></p></li><li><p>数据类型</p><ul><li><p>SDS<br>  <img src="https://i.loli.net/2020/07/12/hpUmPNkzaR9e4n1.jpg" alt="SDS.jpg"></p><ul><li>空间预分配<br>  sdscat =》给字符串后面再拼接一个字符串<br>  当sdscat 之后内存小于 1M，字符串长度*2+1 （’\0’）<br>  当sdscat 之后内存大于 1M, 字符串长度 + 1M + 1（’\0’）</li><li>空间懒分配<br>  如果sdstrim（减少字符串），则不急着回收空间，下次如果需要添加长度，直接使用多余的空间。</li></ul></li><li><p>List<br>  <img src="https://i.loli.net/2020/07/12/AcZDGyX5IJnYl6h.jpg" alt="List.jpg"></p></li><li>Hash<br>  <img src="https://i.loli.net/2020/07/12/Di1vVNXMo83Zfsb.jpg" alt="hash.jpg"><br>  在字典中存在dictht数组，表明是两个hash表<br>  ht[1]的容量是ht[0]的两倍<br>  把ht[0]中的元素rehash复制到ht[1]中</li><li>set</li><li>zset</li></ul></li><li><p>数据存储过程</p><blockquote><p>RedisObject -&gt; 具体的数据类型</p></blockquote></li></ul><h3 id="Redis内存回收策略"><a href="#Redis内存回收策略" class="headerlink" title="Redis内存回收策略"></a>Redis内存回收策略</h3><ul><li>noeviction:不会回收策略,返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令(大部分的写入指令，但DEL和几个例外)</li><li>allkeys-lru:尝试回收最少使用的键(LRU) ，使得新添加的数据有空间存放。</li><li>volatile-lru:尝试回收最少使用的键(LRU) ，但仅限于在过期集合的键,使得新添加的数据有空间存放。</li><li>allkeys-random:回收随机的键使得新添加的数据有空间存放。</li><li>volatile-random:回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</li><li>volatile-ttl:回收在过期集合的键，并且优先回收存活时间(TTL) 较短的键（剩余时间最短），使得新添加的数据有空间存放。</li></ul><h2 id="Redis的原子性保证"><a href="#Redis的原子性保证" class="headerlink" title="Redis的原子性保证"></a>Redis的原子性保证</h2><ul><li>单指令原子性<blockquote><p>Redis是单线程的，一个线程只能执行一个指令，因此具有原子性</p></blockquote></li><li>Lua原子性<blockquote><p>官方解释来看，Lua脚本和Redis的事务一样，被exec/mutl包裹，redis保证每次只能执行一个lua脚本，别的lua脚本不会被执行，由此保证了原子性。</p></blockquote></li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h3><ul><li>setnx 不存在key才可以操作</li><li>set 与set相反<h3 id="锁续期"><a href="#锁续期" class="headerlink" title="锁续期"></a>锁续期</h3><blockquote><p>利用<strong>Redission</strong>，当成功获取一个锁的时候，产生看门狗（watch dog）进行锁续期，一般来说是10s检查一次<br>核心在于Redission使用了Lua脚本</p></blockquote><h3 id="分布式锁的极端情况"><a href="#分布式锁的极端情况" class="headerlink" title="分布式锁的极端情况"></a>分布式锁的极端情况</h3><blockquote><p>当服务A从Master中获取锁，A获取锁成功后，还没来得及同步到从节点，master挂了，从节点<br>重新成为master，服务B过来后，发现该锁还未被获取，于是锁被重复获取</p></blockquote></li></ul><h2 id="Redis的冷备和热备"><a href="#Redis的冷备和热备" class="headerlink" title="Redis的冷备和热备"></a>Redis的冷备和热备</h2><ul><li>热备 - AOF<ul><li>数据文件比RDB更大</li><li>每秒都去持久化，数据丢失少</li><li>存储的文件是每条的指令</li><li>先执行命令，之后才存储到磁盘（由于redis不是完全维护，只有执行以后才知道结果，单纯的语法监测是无用的）</li><li>bgrewriteaof 可以对aof的日志文件进行瘦身，也就是fork一个子进程把原来的日志全部转化成redis命令存到一个新的日志中执行</li></ul></li><li>冷备 - RDB<ul><li>需要fork子进程，数据量大的话会导致几秒的延迟，对于秒杀场景危险</li><li>是段时间保存数据，一旦发生宕机，数据丢失较多</li><li>RDB恢复的更快</li></ul></li></ul><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="哨兵监控"><a href="#哨兵监控" class="headerlink" title="哨兵监控"></a>哨兵监控</h3><ul><li>主观下线<blockquote><p>从节点无法ping通master，则主观认为master挂了</p></blockquote></li><li>客观下线（主节点的下线）<blockquote><p>多个从节点都无法ping通master，则从节点们客观认为master挂了，<strong>需要重新选举</strong></p></blockquote></li><li>定时任务</li><li>错误转移<ul><li>过滤不健康的节点</li><li>选举出新的节点</li><li>让从节点成为主节点</li><li>让原来的master成为从节点</li></ul></li><li>哨兵选举<blockquote><p>Raft : 谁先申请成为主节点，谁就是主节点</p></blockquote></li></ul><h2 id="主从同步的过程"><a href="#主从同步的过程" class="headerlink" title="主从同步的过程"></a>主从同步的过程</h2><ol><li>从节点向master发送slaveof获取主节点的信息<ul><li>定时任务获取主节点信息</li><li>从节点去ping主节点，主节点则返回pang和runid等信息</li></ul></li><li>从节点根据保存的Master runid判断是不是第一次同步复制</li><li>如果是第一次psync?-1，则进行全量复制<ul><li>全量复制址启用用RDB生成快照<ul><li>启动RDB会fork子进程，则子进程运行期间，新命令进入到缓存区</li></ul></li><li>RDB生成到磁盘，之后在读取到内存，再进行数据同步<ul><li>快照内容同步完以后，再将缓存的命令缓存到从节点</li></ul></li></ul></li><li>如果不是第一次，则进行部分复制，从节点向master发送Psync runid offset</li><li>Master收到命令后会查看，runid是否一致，之后查看偏移量offset是否超过复制积压缓存区<ul><li>如果偏移量超过复制积压缓存区，则err，进行全量复制</li><li>如果未超过，则offset+偏移量+命令长度进行部分复制 </li></ul></li></ol><h3 id="复制积压缓存区"><a href="#复制积压缓存区" class="headerlink" title="复制积压缓存区"></a>复制积压缓存区</h3><blockquote><p>在主从同步的期间，仍然会有写命令在执行，这时命令在写入主节点的同时还会写入<strong>复制积压缓存区</strong>,同时记录偏移量，如果这期间缓存的命令过多，则没必要再进行部分复制，直接进行全量复制即可</p></blockquote><h2 id="缓存的常见问题"><a href="#缓存的常见问题" class="headerlink" title="缓存的常见问题"></a>缓存的常见问题</h2><ol><li>缓存穿透<ul><li>恶意访问不存在的数据，导致打入数据库</li><li>增加认证（接口访问功能）</li></ul></li><li>缓存击穿<ul><li>某热点数据突然失效，打入数据库</li><li>设置null值</li></ul></li><li>缓存雪崩<ul><li>大量数据同时失效</li><li>设置随机时间种子</li></ul></li></ol><h2 id="redis中的-HyperLogLog"><a href="#redis中的-HyperLogLog" class="headerlink" title="redis中的  HyperLogLog"></a>redis中的  HyperLogLog</h2><h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><blockquote><p>访问网站的独立访客UV，例如每个访客访问某网站，访问多次，其实只能算作一次。<br>那么带来的直接问题是，如果每个用户都占用一个key，那么就会产生数据量巨大的问题</p></blockquote><h3 id="解决方案拆分"><a href="#解决方案拆分" class="headerlink" title="解决方案拆分"></a>解决方案拆分</h3><ul><li>借鉴数据库的b+树<blockquote><p>解决了插入和查找的问题，但是解决不了数据量大，占用内存的问题</p></blockquote></li><li>bitmap<blockquote><p>如果是一亿个数据，那么100_000_000(数据量)/ 8（字节）/ 1024（KB）/ 1024（MB） ≈ 12 M</p></blockquote></li></ul><h3 id="概率统计"><a href="#概率统计" class="headerlink" title="概率统计"></a>概率统计</h3><blockquote><p>可以看到bitmap已经是属于极致的优化了，但是还是不够，不管怎么说，为了一个统计功能，单一个对象就是12M,但是再多一些还是会很多<br>则使用 “估计的方法可能会好一些”，则使用 <strong>概率统计</strong></p></blockquote><h4 id="redis的实现"><a href="#redis的实现" class="headerlink" title="redis的实现"></a>redis的实现</h4><p>HLL中实际存储的是一个长度为mm的大数组SS，将待统计的数据集合划分成mm组，每组根据算法记录一个统计值存入数组中。数组的大小mm由算法实现方自己确定，redis中这个数组的大小是16834（2的14次方），m越大，基数统计的误差越小，但需要的内存空间也越大<br><img src="https://i.loli.net/2020/07/27/Sctp8ygmNfFUJ5K.jpg" alt="hll的redis过程.jpg"></p><h4 id="hll的实现原理-伯努利试验"><a href="#hll的实现原理-伯努利试验" class="headerlink" title="hll的实现原理 - 伯努利试验"></a>hll的实现原理 - 伯努利试验</h4><ul><li>伯努利实现也就是掷硬币实现，那么我们说假设存在第一次掷出正面所用的最多的次数为kmax，则可以提出假设</li><li><p>假设：</p><ul><li>掷出n次正面所用的次数一定少于n*kmax</li><li>掷出n次正面所用的次数一定有那么一次是等于kmax的（其实正好是1减去上面的概率）<br><img src="https://i.loli.net/2020/07/23/1YSsrdghimzlXK8.jpg" alt="伯努利假设.jpg"></li></ul></li><li><p>推断：</p><ul><li>那么当n远大于kmax的时候，那么第一个不成立</li><li>那么当n远小于kmax的时候，那么第二个不成立</li></ul></li><li><p>继续推断</p><ul><li>那么用kmax推断n的次数貌似是最好的情况<br>则 n = 2^kmax</li></ul></li><li><p>继续思考</p><ul><li>如果很大的一段二进制，只用一个kmax误差比较大</li><li>那么把一段很大的分开估计就好了，因此有<strong>分桶原理</strong>，也就是redis过程中对应的数组S的m</li></ul></li></ul><h3 id="稀疏存储和密集存储"><a href="#稀疏存储和密集存储" class="headerlink" title="稀疏存储和密集存储"></a>稀疏存储和密集存储</h3><ol><li>密集存储就是按照原来16834来存储</li><li>稀疏存储就是连续两个0作为统计接下来的 6bit 整数值加 1 <h3 id="hll对象头"><a href="#hll对象头" class="headerlink" title="hll对象头"></a>hll对象头</h3><pre><code class="c"><span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> {</span> <span class="keyword">char</span> magic[<span class="number">4</span>];      <span class="comment">/* 魔术字符串"HYLL" */</span> <span class="keyword">uint8_t</span> encoding;   <span class="comment">/* 存储类型 HLL_DENSE or HLL_SPARSE. */</span> <span class="keyword">uint8_t</span> notused[<span class="number">3</span>]; <span class="comment">/* 保留三个字节未来可能会使用 */</span> <span class="keyword">uint8_t</span> card[<span class="number">8</span>];    <span class="comment">/* 总计数缓存 */</span> <span class="keyword">uint8_t</span> registers[]; <span class="comment">/* 所有桶的计数器 */</span>};</code></pre></li></ol><h2 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h2><h3 id="PubSub"><a href="#PubSub" class="headerlink" title="PubSub"></a>PubSub</h3><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>没有ack确认信息，不能保证数据连续</li><li><p>不持久化消息</p><h4 id="PubSub-1"><a href="#PubSub-1" class="headerlink" title="PubSub"></a>PubSub</h4><p><img src="https://i.loli.net/2020/07/24/6jHO7DIZMxAkvGL.jpg" alt="redis_PubSub订阅模式.jpg"></p></li><li><p>精确匹配</p><blockquote><p>订阅某个精确频道，则需要精确的知道这个频道的key值，才可以订阅，比如client订阅redis频道<br><img src="https://i.loli.net/2020/07/24/MtX9ZLSxukBohrY.jpg" alt="redis_发布订阅_channel.jpg"></p></blockquote></li><li>前缀多匹配<blockquote><p>订阅某种类型的全部频道，也就是说知道某频道类型的前缀，则可以订阅该类型下的全部频道，例如<strong>client订阅redis.*的频道</strong>,<br>则会<strong>订阅redis.log,redis.rdb等一系列符合redis.*的一系列前缀频道</strong><br><img src="https://i.loli.net/2020/07/24/CSMaz6mKxd3svFq.jpg" alt="redis_patten_多匹配原理.jpg"></p></blockquote></li></ul><h4 id="steam"><a href="#steam" class="headerlink" title="steam"></a>steam</h4><p><img src="https://i.loli.net/2020/07/24/ZM5drvlSyHApVOF.jpg" alt="redis_steam.jpg"></p><ul><li>Consumer Group：消费者组<blockquote><p>多个consumer需要某消息的一个群组</p></blockquote></li><li>last_delivered_id：消息游标<blockquote><p>群组需要哪个消息，则指向这个消息的id,消息 ID 如果是由 XADD 命令返回自动创建的话，那么它的格式会像这样：timestampInMillis-sequence (毫秒时间戳-序列号)，例如 1527846880585-5，它表示当前的消息是在毫秒时间戳 1527846880585 时产生的，并且是该毫秒内产生的第 5 条消息。</p></blockquote></li><li>pending_ids：状态数组<blockquote><p>记录未确认ack的消息的数组，如果客户端发送ack则数组中的内容减少，如果不发送则会一直增加</p></blockquote></li></ul><h2 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h2><h3 id="cluster原理"><a href="#cluster原理" class="headerlink" title="cluster原理"></a>cluster原理</h3><h3 id="哈希槽"><a href="#哈希槽" class="headerlink" title="哈希槽"></a>哈希槽</h3><p>在redis提供了cluster的集群维护方式后，与以往的哨兵模式不一样，哨兵模式下的节点的数据是一样的，但是cluster的出现，可以将<strong>数据水平切割</strong>，也就是说不同的节点可以负责不同部分的数据。<br>那么不同的数据如何知道怎么去找不同的节点呢，最开始有出现的是<strong>范围分片</strong>，也就是按照id顺序指定到不同的位置，但是存在热点数据会存在最后一个节点的问题，所以redis cluster使用了hash槽</p><ul><li>哈希槽是redis中利用bitmap维护的</li><li>哈希槽有2^14个，也就是规定不同的哈希槽对应到不同的节点上<br><img src="https://i.loli.net/2020/08/13/Yw7v5XmBbFn6Kho.jpg" alt="哈希槽.jpg"></li><li><p>hash槽定位 CRC16 &amp; (2^14-1)</p></li><li><p>哈希槽为什么是2^14次方呢<br>  <img src="https://i.loli.net/2020/08/13/k5hoIYTS6xtBZfX.jpg" alt="cluster.jpg"></p><ul><li>redis cluster的通信<ol><li>利用cluster meet来进行通信为了让彼此知道存在</li><li>节点一旦meet成功之后会定时进行ping/pong进行数据交换<ul><li>其中维护了一个myslots[cluster_slots/8]的数组，大约是2kb，如果频繁通信的话数据量过大，因此如果是2^16次方的话会更大<ul><li>每秒随机找五个节点进行ping，找出最早久没有通信的进行ping</li><li>没0.1s找本地的节点链表，找找过timeout/2以上没进行通信的节点进行通信<br><img src="https://img2018.cnblogs.com/blog/725429/201908/725429-20190829164739879-973731722.jpg" alt="消息头"></li></ul></li></ul></li></ol></li></ul></li></ul><h2 id="redis线程模型"><a href="#redis线程模型" class="headerlink" title="redis线程模型"></a>redis线程模型</h2><ul><li><strong>socket（套接字）</strong>：多个socket发来请求</li><li><strong>IO多路复用程序</strong>：监听套接字的请求</li><li><strong>文件事件分派器</strong>：更具io多路复用监听到的事件，分派到不同的事件处理器</li><li><strong>事件处理器</strong>：处理事件<ul><li>连接请求应答器 ： 于对连接服务器监听套接字的客户端进行应答</li><li>命令请求处理器 ： 从套接字中读入客户端发送的命令请求内容</li><li>命令回复处理器 ： 将服务器执行命令后得到的命令回复通过套接字返回给客户端<br><img src="https://i.loli.net/2020/08/14/ZtXksiop4zql5CN.jpg" alt="redis线程模型01.jpg"></li></ul></li></ul><h3 id="完整流程："><a href="#完整流程：" class="headerlink" title="完整流程："></a>完整流程：</h3><ol><li>服务器初始化，会把监听AE_READABLE事件的套接字与相应的<strong>应答处理器</strong>关联起来</li><li>此时一个客户端向redis发起请求，那么监听AE_READABLE的套接字会产生AE_READABLE事件，同时触发<strong>应答处理器</strong></li><li>应答处理器会<strong>创建客户端套接字</strong>，客户端状态</li><li>同时再把<strong>客户端套接字和AE_READABLE事件相关联</strong></li><li>客户端向主服务器发送一个命令请求</li><li><strong>客户端套接字产生AE_READABLE事件</strong>，引发<strong>命令请求处理器</strong></li><li>命令请求处理器处理后会产生相应的回复命令</li><li>服务器会把<strong>客户端套接字AE_WRITABLE事件与命令回复处理器关联</strong></li><li>命令回复处理器全部写入套接字后</li><li>服务器就会解除客户端套接字的 AE_WRITABLE 事件与命令回复处理器之间的关联</li></ol><p>重要点规划：</p><ul><li>第一次连接之前，是依赖初始化的套接字去监听AE_READABLE的事件</li><li>客户端套接字是单独创建的</li><li>当客户端套接字发起命令，也就是连接到命令请求处理器，先是AE_READABLE事件，之后才是AE_WRITABLE 事件</li><li>AE_WRITABLE 事件与命令回复处理器之间的关联才可以回复</li></ul><p><img src="https://i.loli.net/2020/08/14/j28flx3iMc7OgnI.jpg" alt="redis线程模型.jpg"></p><h2 id="数据库和缓存双写一致"><a href="#数据库和缓存双写一致" class="headerlink" title="数据库和缓存双写一致"></a>数据库和缓存双写一致</h2><ol><li>先更新数据库，再删缓存（较好）<ul><li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li>命中：应用程序从cache中取数据，取到后返回。</li><li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li></ul></li><li>先删缓存，再更新数据库<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）<strong>请求B将旧值写入缓存</strong><br>（5）<strong>请求A将新值写入数据库</strong><br>那么旧值会一致存在缓存中，可以使用延迟淘汰的策略，比如延迟一秒，则淘汰全部的数据</li></ol><h2 id="实际的场景问题"><a href="#实际的场景问题" class="headerlink" title="实际的场景问题"></a>实际的场景问题</h2><ul><li>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据（LRU）<blockquote><ol><li>可以适当的增加缓存的过期时间，如果在redis中每次命中一次数据，那么就进行延长时间，到最后，热点数据相对来说时间会更长</li><li>设置相应的淘汰策略，由于redisobject有最后使用的时间和引用次数，可以回收最少使用的键</li></ol></blockquote></li></ul><ol><li>监听套接字的 AE_READABLE 事件应该正处于监听状态，该事件所对应的处理器为<strong>连接应答处理器</strong></li><li>，客户端发起请求，监听套接字将产生 AE_READABLE 事件， 触发连接应答处理器执行： 处理器会对客户端的连接请求进行应答</li><li>然后创建客户端套接字， 以及客户端状态， 并将客户端套接字的 AE_READABLE 事件与<strong>命令请求处理器进行关联</strong>， 使得客户端可以向主服务器发送命令请求</li><li>客户端向Redis服务器发送一个命令请求，那么客户端套接字将产生 AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容， 然后传给相关程序去执行</li><li>执行命令将产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的AE_WRITABLE事件与<strong>命令回复处理器</strong>进行关联：当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITABLE事件， 触发命令回复处理器执行</li><li>当命令回复处理器将命令回复全部写入到套接字之后， 服务器就会解除客户端套接字的AE_WRITABLE事件与命令回复处理器之间的关联。</li></ol></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Redis" scheme="http://runindark.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Jvm复习总结</title>
    <link href="http://runindark.com/2020/06/28/2020%E7%A7%8B%E6%8B%9B/jvm/"/>
    <id>http://runindark.com/2020/06/28/2020秋招/jvm/</id>
    <published>2020-06-28T15:54:20.982Z</published>
    <updated>2020-07-18T09:47:17.074Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="Jvm数据区"><a href="#Jvm数据区" class="headerlink" title="Jvm数据区"></a>Jvm数据区</h3><p><img src="https://i.loli.net/2020/07/14/nPEm8sD7v6dMLXQ.png" alt="jvm_数据区.png"></p><ul><li>线程共享区<ul><li>方法区（运行常量池）<br>  主要用于存放堆内存中的一些执行逻辑和变量，类的加载信息，常量，静态变量等一系列信息，和堆不同，方法去不需要频繁gc等操作，又叫<strong>永久代</strong></li><li>堆<br>  Java中的类<strong>实例，数组</strong>都将存放在堆中，gc发生也是在堆中，堆是Jvm内存中最大的一块内存地址</li></ul></li><li>线程私有区<ul><li>虚拟机栈<br>  虚拟机栈就是线程所私有Java方法的内存区域，包括方法所引用的基本数据类型和引用。<br>  Java方法的使用就是压栈过程，基本数据类型和引用则是存在栈帧中，当方法抛出异常或结束则是出栈的操作。</li><li>本地方法区<br>  native修饰的非Java方法<br>  本地方法栈也有自己的栈帧等，栈帧里面也相应的有局部变量表，操作数栈，动态链接，出口信息等</li><li>程序计数器<br>  Jvm的本质是多线程交替的，但是如何保证每一个线程拿到cpu资源的时候可以从结束的地方接着开始，就需要程序技术器来保证</li></ul></li></ul><h4 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h4><ul><li>Eden</li><li>Survivor0</li><li>Survivor1 </li><li>老年代</li></ul><blockquote><p>首先分配内存到Eden区，当发生Gc之后转移到s0或者s1中（如果s0先被使用，那么下一次则使用s1，总之是为了保留新生代的内容），每一次gc都会给新生代数据记录次数，一般来说超过15次则进入老年代</p></blockquote><h4 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h4><ul><li>字符串内容</li><li>final修饰的关键字</li><li>基本数据类型的值</li><li>符号引用<ul><li>类和结构完全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul></li></ul><h3 id="Java对象的创建过程"><a href="#Java对象的创建过程" class="headerlink" title="Java对象的创建过程"></a>Java对象的创建过程</h3><ol><li>类加载</li><li>分配内存</li><li>初始化零值</li><li>设置对象头</li><li>执行init</li></ol><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p><img src="https://img-blog.csdnimg.cn/2019062014564165.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9jdWl0,size_16,color_FFFFFF,t_70" alt="类加载过程图"></p><ol><li><p>加载 （所需类的加载过程）</p><ul><li>通过类的全限定名获取该类的二进制流（通过class全限定名从本地，网络，专有数据库中的jar或者zip中获取.class文件）</li><li>生成java.lang.class对象作为<strong>方法区</strong>进入该对象的入口</li><li>将字节流的存储结构转化到jvm方法区中运行时的数据结构</li></ul></li><li><p>验证 （了解Class字节文件是否符合当前虚拟机要求）</p><ul><li>文件格式验证: 字节流是否符合class文件规范</li><li>元数据验证: 是否符合java的语法规范，例如继承接口，是否实现了接口中的方法</li><li>字节码验证: 数据和控制流验证，保证方法中的类型转换有效</li><li>符号引用验证: 验证是否可以通过符号引用找到相应的对象和变量</li></ul></li><li><p>准备 （为类的变量分配内存和设置类的初始值（即<strong>方法区</strong>分配这些变量空间））</p><ul><li>为变量分配空间</li><li>为变量初始化赋值的过程，例如int 赋值为 0 ，对象赋值为 null 等</li><li><strong>特殊</strong> private static final a = 1<br>正常来说，应该是初始化阶段赋值，但是这个情况下直接在方法去中替换a = 1 ，则在<strong>准备阶段就完成赋值</strong></li></ul></li><li>解析 （虚拟机将常量池中的符号引用转为直接引用的过程）<ul><li>什么是符号引用？<br>用一串不会有歧义的符号来标识引用的对象或者是变量</li><li>什么是直接引用？<br>正式用指针去引用符号和变量</li></ul></li><li>初始化<blockquote><p>真正按照程序员的意愿去初始化值</p></blockquote></li></ol><h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><h5 id="分配方法"><a href="#分配方法" class="headerlink" title="分配方法"></a>分配方法</h5><ol><li>指针碰撞<br>内存空间比较<strong>整洁</strong>，直接移动指针分配空间</li><li>空闲链表<br>“见缝插针”，空间不连续，则找到空闲的地方插入数据</li></ol><h5 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h5><ol><li>利用CAS不都安的尝试获取内存空间直到成功（目前虚拟机的解决方案）</li><li>TLAB： 为每个线程独自分配一部分空间，且独有，分配的时候优先分配到该空间中</li></ol><h4 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h4><p>例如Synchronized关键字需要Mark Word中的monitor对象（MonitorExit，MonitorEnter）</p><h3 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h3><ol><li>句柄访问<br><img src="https://i.loli.net/2020/07/14/xNo3TZC4ir98tDL.jpg" alt="句柄.jpg"><br>reference -&gt; 句柄池中指针 -&gt; 实例数据</li><li><p>直接访问<br><img src="https://i.loli.net/2020/07/14/hvbVfx1298l6QUP.jpg" alt="直接访问.jpg"><br>reference -&gt; 实例数据</p></li><li><p>句柄和直接访问的优缺点分析</p><blockquote><p>论访问速度直接访问最快，但是如果需要删除的话需要直接删除数据<br>句柄中则可以直接把句柄值赋null，效率更快</p></blockquote></li></ol><h3 id="对象死亡的分析方法"><a href="#对象死亡的分析方法" class="headerlink" title="对象死亡的分析方法"></a>对象死亡的分析方法</h3><ol><li>程序计数法 ： 清零以后则可以判断死亡</li><li>可达性分析法 ： 以Gc root为起点 看看各个对象是否可以连接起来，如果连接不起来，被独立则可以判断回收</li></ol><ul><li>什么是Gc root（GC Roots一般在JVM的栈区域里产生）<ul><li>处于激活状态的线程</li><li>栈中的对象</li><li>JNI中的变量</li><li>JNI的全局引用</li><li>对象头的Monitor对象</li></ul></li></ul><h3 id="引用的类型"><a href="#引用的类型" class="headerlink" title="引用的类型"></a>引用的类型</h3><ul><li>强引用 （大部分是强引用，虚拟机就算oom，也不会回收引用）</li><li>软引用 （当内存不足的时候，会回收软引用）</li><li>弱引用 （只要被回收器判定为垃圾，则直接回收，可以用于判断是否被gc回收）</li><li>虚引用 （虚引用不在乎引用了什么对象，可以说是一种gc标志，必须配合引用队列，可以在对象被回收之前做一些操作）</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul><li>标记清除算法（标记为垃圾后，直接删除）</li><li>复制算法 （开辟两块空间，直接将为被回收的部分复制到另一部分的空间内）</li><li>标记整理算法 （先标记，之后移动，使得内存空间干净）</li><li>分代收集算法 （分为年轻代和老年代，分别使用不同的算法，新生代用复制算法， 老年代用标记整理算法）</li></ul><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><ul><li>Serial （单线程）<blockquote><p>单线程回收垃圾，回收的时候需要暂停其它的一切线程</p></blockquote></li><li>Parnew （多线程）<blockquote><p>对Serial的升级，其它不变，就是变成多线程</p></blockquote></li><li>Parallel Scavenge （多线程）<blockquote><p>提升吞吐量（程序运行时间/CPU使用时间），<strong>提高回收次数，减少回收时间</strong></p></blockquote></li><li>CMS （真正意义上的多线程）<ul><li>标记清除算法</li><li>过程<ol><li>初始标记 （暂停所有线程，标记Gc Root相连的对象）</li><li>并发标记 （进行可达性分析，标记一系列回收对象）</li><li>重新标记 （修正并发标记期间用户的修改）</li><li>并发清除 （开始清理）</li></ol></li><li>缺点<ul><li>对CPU资源敏感</li><li>无法清理浮动垃圾</li><li>有太多的空间碎片</li></ul></li></ul></li><li>G1 （多线程，不区分新生代和老年代）<ul><li>预览图<br><img src="https://c1.staticflickr.com/5/4678/40093686972_25da5b859f_z.jpg" alt="region"></li><li>分区 Region （G1对内存的使用以分区(Region)为单位，而对对象的分配则以卡片(Card)为单位。）<blockquote><p>不区分老年代和年轻代都会直接被划分成Region，每个Region还会被细分为若干个大小为512 Byte的Card，卡片还会记录在全局卡片表(Global Card Table)中.<br>不同卡中的对象可能会互相引用，还可能是跨域Region引用，如果存在的话会直接<strong>写屏障（并发标记阶段）</strong></p></blockquote></li><li>分区模型<ul><li>预览图<br>  <img src="https://c1.staticflickr.com/5/4619/40093686872_ce639c1121_z.jpg" alt=""></li><li>巨型对象 Humongous Region<br>  由于太大会导致分区出现问题，因此直接在老年代中分配空间</li><li>已记忆集合 Remember Set (RSet)  （存在于Region中）<ul><li>记录引用分区内对象的卡片索引</li><li>内部使用Per Region Table (PRT) 记录使用引用的情况（稀少，细粒度，粗粒度）<ul><li>稀少 （记录到卡）</li><li>细粒度 （记录到region）</li><li>粗粒度 （记录到引用的数目）</li></ul></li></ul></li><li>过程<ol><li>初始标记 （GC Root的标记）</li><li>并发标记 （三色标记法开始）</li><li>最终标记 （三色标记的最终标记）</li><li>筛选回收 （复制清除算法）</li></ol></li><li>三色标记<ul><li>white （不可达回收）</li><li>grey （子对象还未扫描完）</li><li>black （gc root）</li></ul></li><li>STAB<blockquote><p>本质是上对对象的一次快照，快照的内容就是查看对象的颜色（三色标记）以维持并发的效率。</p></blockquote></li></ul></li></ul></li></ul><h3 id="Jvm什么时候发生full-gc"><a href="#Jvm什么时候发生full-gc" class="headerlink" title="Jvm什么时候发生full gc"></a>Jvm什么时候发生full gc</h3><ol><li>永久代满的时候</li><li>老年代空间不足</li></ol><h3 id="双清委派模型"><a href="#双清委派模型" class="headerlink" title="双清委派模型"></a>双清委派模型</h3><p><img src="https://i.loli.net/2020/07/14/TGzqAd9XPJBQ1xN.jpg" alt="双亲委派模型.jpg"></p><blockquote><p>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。<br>而有了双亲委派模型，黑客自定义的java.lang.String类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的java.lang.String类，最终自定义的类加载器无法加载java.lang.String类</p></blockquote><h4 id="双亲委派模型的破坏-借鉴CSDN博主的文章说的很完整了"><a href="#双亲委派模型的破坏-借鉴CSDN博主的文章说的很完整了" class="headerlink" title="双亲委派模型的破坏 (借鉴CSDN博主的文章说的很完整了)"></a>双亲委派模型的破坏 (借鉴CSDN博主的文章说的很完整了)</h4><blockquote><p>原生的JDBC中Driver驱动本身只是一个接口，并没有具体的实现，具体的实现是由不同数据库类型去实现的。例如，MySQL的mysql-connector-.jar中的Driver类具体实现的。 原生的JDBC中的类是放在rt.jar包的，是由启动类加载器进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而mysql-connector-.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由应用程序启动类去进行类加载。于是乎，这个时候就引入线程上下文件类加载器(Thread Context ClassLoader)。有了这个东西之后，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了。<br>————————————————<br>版权声明：本文为CSDN博主「Jack老师」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/luoyang_java/article/details/92598142" target="_blank" rel="noopener">https://blog.csdn.net/luoyang_java/article/details/92598142</a></p></blockquote><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://blog.csdn.net/zhaocuit/article/details/93038538" target="_blank" rel="noopener">https://blog.csdn.net/zhaocuit/article/details/93038538</a></li><li><a href="https://blog.csdn.net/qq_34402394/article/details/72793119" target="_blank" rel="noopener">https://blog.csdn.net/qq_34402394/article/details/72793119</a></li><li><a href="https://www.cnblogs.com/bigbaby/p/12348973.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigbaby/p/12348973.html</a></li><li><a href="https://blog.csdn.net/fedorafrog/article/details/104503829/" target="_blank" rel="noopener">https://blog.csdn.net/fedorafrog/article/details/104503829/</a></li><li><a href="https://blog.csdn.net/luoyang_java/article/details/92598142" target="_blank" rel="noopener">https://blog.csdn.net/luoyang_java/article/details/92598142</a></li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="jvm" scheme="http://runindark.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Mysql复习总结</title>
    <link href="http://runindark.com/2020/06/28/2020%E7%A7%8B%E6%8B%9B/mysql/"/>
    <id>http://runindark.com/2020/06/28/2020秋招/mysql/</id>
    <published>2020-06-28T01:50:52.410Z</published>
    <updated>2020-09-02T02:58:17.993Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="数据库特性"><a href="#数据库特性" class="headerlink" title="数据库特性"></a>数据库特性</h3><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote><p>所谓原子性就是事务的执行，要么全部成功，要么全部失败。</p></blockquote><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><blockquote><p>事务操作的完整性约束不会破坏，是原子性的一种表现，例如A向B转账，不会发生A金额发生变化，但是B金额不会发生变化的情况</p></blockquote><h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><blockquote><p>事务之间的操作是互相隔离的，且不受彼此的影响</p></blockquote><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><blockquote><p>事务完成后，所有数据保存在数据库中，持久存在，且不能回滚。</p></blockquote></li></ul><h3 id="Mysql事务所存在的问题"><a href="#Mysql事务所存在的问题" class="headerlink" title="Mysql事务所存在的问题"></a>Mysql事务所存在的问题</h3><ul><li>脏读 （Select没有规矩）<blockquote><p>事务A插入了一条数据，但是还没有提交，结果事务B去读取数据表，发现了数据A要插入的数据，就是脏读</p></blockquote></li><li>不可重复读 （Update没有规矩）<blockquote><p>事务A首次读某条数据为a，但是事务b此时更新了该条数据为b，结果A再次读取这条数据的时候就变成了b，就是不可重复读</p></blockquote></li><li>幻读 （insert，delete没有规矩）<blockquote><p>事务A读取了数据表，事务B又插入了几条数据，当事务A再次读取数据表的时候，发现数据多了几条，就是幻读</p></blockquote></li></ul><h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><ul><li>未提交读<blockquote><p>事务之间可以读取到事务未提交的数据 （完美的符合了上面出现的所有问题）</p></blockquote></li><li>提交读<blockquote><p>事务必须提交之后，提交的数据才可以被其它的事务所看到。</p></blockquote></li><li>可重复读<blockquote><p>悲观锁读，若一个事务A读取该条数据，那么不管其它的事务如何去更改这条数据，那么事务A依然读取到的是第一次读取到的数据。</p></blockquote></li><li>串行化<blockquote><p>事务操作一个一个按照顺序来，慢是最大的问题</p></blockquote></li></ul><h3 id="Mysql中的log"><a href="#Mysql中的log" class="headerlink" title="Mysql中的log"></a>Mysql中的log</h3><ul><li>bin log<blockquote><p>记录数据库的变更操作，例如delete，insert，update等操作，不会记录select，用于数据的恢复和复制，<br>记录形式为 一些sql语句还有一些事务id等内容</p></blockquote></li><li>redo log<br><img src="https://i.loli.net/2020/07/14/cwz8epYn4Q2gxTu.jpg" alt="redolog.jpg"><blockquote><p>数据的读取或者说是修改操作，是先找到页，再读到内存，如果发生修改，读到内存后，还没来得及刷到磁盘，数据库gg了，那么数据容易丢失，但是redo log会记录页的变更内容，那么恢复数据库的话，就不会丢失数据了。</p></blockquote></li><li>undo log<blockquote><p>和redo log相反，在读到内存的时候，undo log还会记录相反的内容，比如redo是insert那么undo就是要记录delete的操作，记录的和binlog一样，属于逻辑变化</p></blockquote></li></ul><h4 id="bin-log-VS-redo-log"><a href="#bin-log-VS-redo-log" class="headerlink" title="bin log VS redo log"></a>bin log VS redo log</h4><ul><li>binlog记录的是sql的语句等内容，redolog记录的则是XX页在XX行改了XX数据</li><li>binlog存在于所有的数据库系统，redo则是innodb的独家内容</li><li>redolog 和 binlog 必须数据都一致才算是正常，要不然都会回滚</li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><blockquote><p>多版本并发控制，其实就是为每一条数据都填设一个版本号，因此提交读和重复读所读取的数据都是其中的快照读的一种</p></blockquote><h3 id="ACID如何被保证的"><a href="#ACID如何被保证的" class="headerlink" title="ACID如何被保证的"></a>ACID如何被保证的</h3><ul><li>原子性如何保证<blockquote><p>如果事务失败则使用undolog进行会滚</p></blockquote></li><li>隔离性如何保证<blockquote><p>MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据。 =&gt; 也就是快照读</p></blockquote></li><li>持久性如何保证<blockquote><p>redolog用于保证其持久性</p></blockquote><h3 id="存储引擎-（Innodb-和-MyISAM）"><a href="#存储引擎-（Innodb-和-MyISAM）" class="headerlink" title="存储引擎 （Innodb 和 MyISAM）"></a>存储引擎 （Innodb 和 MyISAM）</h3></li><li>InnoDB支持事务，但是MyISAM不支持事务</li><li>InnoDB支持外键，但是MyISAM不支持外键</li><li>InnoDB是行级锁，但是MyISAM是表级锁</li><li>InnoDB是聚集索引（数据文件和索引是绑定的，也就是说，先查到索引，之后才可以查到数据），但是MyISAM是非聚集索引（也就是说数据和索引是相互分开的，索引直接链接着数据的地址）<br>(换句话说：InnoDB下，索引就真的是索引，辅助索引则是数据的指针;但是MyISAM的主索引和辅助索引则都是数据指针)</li><li>InnoDB不支持全文搜索，但是MyISAM则支持全文搜索 （！mysql5.7之后innoDB也是可以支持全文搜索的）</li><li>面试考的比较少了，但是可以看看<ul><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描，而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可</li><li>MyISAM表格可以被压缩后进行查询操作</li></ul></li></ul><h3 id="InnoDB的自适应hash算法-Adaptive-Hash-Index-AHI"><a href="#InnoDB的自适应hash算法-Adaptive-Hash-Index-AHI" class="headerlink" title="InnoDB的自适应hash算法((Adaptive Hash Index, AHI))"></a>InnoDB的自适应hash算法((Adaptive Hash Index, AHI))</h3><blockquote><p>InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引<br>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引</p></blockquote><h4 id="InnoDB为什么推荐使用自增ID作为主键？"><a href="#InnoDB为什么推荐使用自增ID作为主键？" class="headerlink" title="InnoDB为什么推荐使用自增ID作为主键？"></a>InnoDB为什么推荐使用自增ID作为主键？</h4><blockquote><p>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p></blockquote><h3 id="数据结构-查找树，红黑树，b树和b-树"><a href="#数据结构-查找树，红黑树，b树和b-树" class="headerlink" title="数据结构 - 查找树，红黑树，b树和b+树"></a>数据结构 - 查找树，红黑树，b树和b+树</h3><blockquote><p>查找树是不平衡的，举个例子来说，如果是插入（1，2，3，4，5），那么数据查找在查找树中会全部在一边，构成一个链表<br>红黑树是平衡的，但是红黑树是一颗二叉树，深度问题还是没有解决<br>b树在一定程度上其实已经解决了前两个的问题，简单的说就是：多叉的平衡树;但是b+树需要指定叶子节点的最大值，因此是无法也不能更好的始应数据库的需求<br>b+树是b树的升级版，b+树的<strong>非叶子节点只存储数据索引</strong>，且从左向右也是从小到大的排列，这样就可以更多的让索引存储，之后在<strong>叶子节点才是真正的数据部分</strong>，且每个叶子节点的最后会是指针指向旁边的叶子节点<br><img src="https://pic2.zhimg.com/80/v2-9644d1a1f83d3e45da779f2e63c35d55_1440w.jpg" alt=""></p></blockquote><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul><li>普通索引<blockquote><p>就是最基本的添加一个索引，用于加速查找</p></blockquote></li><li>唯一索引<blockquote><p>列值必须唯一，可以为空值，加速查找</p></blockquote></li><li>主键索引<blockquote><p>利用主键作为索引，而且不可以为空，加速查找</p></blockquote></li><li>覆盖索引<blockquote><p>就是查查找的数据也是索引值</p></blockquote></li><li>组合索引<blockquote><p>几列合并成一个索引，但是遵循最左原则</p></blockquote></li><li>全文索引<blockquote><p>全文分词查找，innoDB是做不到的，需要第三方，比如es等</p></blockquote><h4 id="索引带来的问题"><a href="#索引带来的问题" class="headerlink" title="索引带来的问题"></a>索引带来的问题</h4><blockquote><p>使用索引的时候不可以随便使用，过度的使用索引会导致消耗大量的资源，热点核心业务的数据应该多使用索引<br>索引会浪费磁盘空间，不要创建非必要的索引,插入、更新、删除需要维护索引，带来额外的开销,索引过多，修改表的时候重构索引性能差<br>但是索引使用的时候可以减少查询次数，提高效率</p></blockquote><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4></li><li>在组合索引中没有遵循最左匹配的原则</li><li>前导模糊查询 </li><li>(like ‘%XX’或者like ‘%XX%’)</li><li>使用or</li><li>在where中使用了&gt;,&lt;,=等计算的符号</li><li>判断为null<h3 id="sql查询慢的原因"><a href="#sql查询慢的原因" class="headerlink" title="sql查询慢的原因"></a>sql查询慢的原因</h3></li><li>sql偶尔查询比较慢<ul><li>服务器带宽，io性能</li><li>或者是redolog啥的占据性能</li></ul></li><li>sql查询一直都很慢<ul><li>未使用索引</li><li>索引失效<h3 id="查询的顺序"><a href="#查询的顺序" class="headerlink" title="查询的顺序"></a>查询的顺序</h3></li></ul></li></ul><ol><li>from 从哪个表查询</li><li>where 初步过滤条件</li><li>group by 过滤后进行分组[重点]</li><li>having 对分组后的数据进行二次过滤[重点]</li><li>select 查看哪些结果字段</li><li>order by 按照怎样的顺序进行排序返回[重点]</li></ol><h3 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式"></a>数据库设计三范式</h3><ol><li>1NF : 原子性 字段不可再分,否则就不是关系数据库</li><li>2NF : 唯一性 每一个主键是唯一的</li><li>3NF : 要求一个数据库表中不包含已在其他表中已包含的非主关键字信息， 例如 存在一个课程表，课程表中有课程号(Cno),课程名(Cname),学分(Ccredit)，那么在学生信息表中就没必要再把课程名，学分再存储到学生表中，这样会造成数据的冗余</li></ol><h3 id="参考文章链接"><a href="#参考文章链接" class="headerlink" title="参考文章链接"></a>参考文章链接</h3><ul><li>InnoDB与MyISAM  <a href="https://blog.csdn.net/qq_35642036/article/details/82820178" target="_blank" rel="noopener">https://blog.csdn.net/qq_35642036/article/details/82820178</a></li><li>敖丙  <a href="https://mp.weixin.qq.com/s/Lx4TNPLQzYaknR7D3gmOmQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Lx4TNPLQzYaknR7D3gmOmQ</a></li><li>三范式 <a href="https://blog.csdn.net/qq_43079376/article/details/93647335" target="_blank" rel="noopener">https://blog.csdn.net/qq_43079376/article/details/93647335</a></li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="mysql" scheme="http://runindark.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《天净沙·我·二面知识点总结》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/22/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-%E4%BA%8C%E9%9D%A2%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://runindark.com/2020/03/22/2020春招/我为阿里-二面知识点/</id>
    <published>2020-03-22T03:12:52.385Z</published>
    <updated>2020-06-28T01:43:26.137Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><blockquote><p>布隆过滤器主要是针对大量数据的一个预判，可以给出两种结果，1.一定不存在 2. 可能存在的<br>布隆过滤器使用多个映射的hash函数将一个数据直接映射到一个bit数组上，当进行插入的时候，n个映射函数的值会直接到达布隆过滤器的索引位置，并且设置树脂为1，因此如果发生hash碰撞会发生，某个数组的位置多次为1，情况，因此会得出可能存在的结论，但是如果查找的时候，n个hash函数有任意一位过滤的数组值为不为1，那么则一定不存在。</p></blockquote><h2 id="秒杀系统中为什么会产生超卖的现象？"><a href="#秒杀系统中为什么会产生超卖的现象？" class="headerlink" title="秒杀系统中为什么会产生超卖的现象？"></a>秒杀系统中为什么会产生超卖的现象？</h2><blockquote><p>由于使用mysql的时候数据库本身的存储引擎innodb是改操作是排他锁，但是读的操作是不上锁的，当到达最后一个的时候，如果都查到还剩下一个，那么其它的请求过来都会同时的更改数据库，那么就会造成超卖，也是快照读的一个弊病。</p></blockquote><h3 id="怎么解决超卖现象？"><a href="#怎么解决超卖现象？" class="headerlink" title="怎么解决超卖现象？"></a>怎么解决超卖现象？</h3><blockquote><p>最简单的思路，就是每次在sql语句中，更改的时候，在where的时候设条件大于0，但是这样子一旦超过数据库的承受能力，还是会超读<br>每次的读操作都上排他锁，这样子可以避免这个现象，但是会导致性能大幅度降低<br>使用redis是最好的方法，可以把要秒杀的内容放到redis的队列中，使用一次则删除一次</p></blockquote><h4 id="细致深入：Redis实现秒杀系统"><a href="#细致深入：Redis实现秒杀系统" class="headerlink" title="细致深入：Redis实现秒杀系统"></a>细致深入：Redis实现秒杀系统</h4><blockquote><p>核心redis的操作命令，sextnx（细粒度上锁） + expire（强制锁释放）</p><ol><li>首先需要将秒杀的数据放到一个redis中，然后在操作redis的时候可以用setnx去操作数据，所谓细粒度锁是一个抽象概念，sexnx就是具体实现（其实更加直白的理解一些，普通的get/put是一个原子操作,但是一系列操作就不再是原子性的了，setnx是一个原子操作，所以可以作为一个细粒度锁）</li><li>更加直接的来，就是将数据都加入到redis的list中，然后使用Lpop命令不断获取就ok（移除并返回列表的第一个元素）</li></ol></blockquote><h2 id="Redis深入"><a href="#Redis深入" class="headerlink" title="Redis深入"></a>Redis深入</h2><h3 id="redis能用的的加锁命令分表是INCR、SETNX、SET"><a href="#redis能用的的加锁命令分表是INCR、SETNX、SET" class="headerlink" title="redis能用的的加锁命令分表是INCR、SETNX、SET"></a>redis能用的的加锁命令分表是INCR、SETNX、SET</h3><blockquote><p>redis所有的单独的命令都是原子的</p></blockquote><h4 id="INCR"><a href="#INCR" class="headerlink" title="INCR"></a>INCR</h4><blockquote><p>这种加锁的思路是， key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作进行加一。然后其它用户在执行 INCR 操作进行加一时，如果返回的数大于 1 ，说明这个锁正在被使用当中。</p></blockquote><h4 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h4><blockquote><p>这种加锁的思路是，如果 key 不存在，将 key 设置为 value如果 key 已存在，则 SETNX 不做任何动作</p></blockquote><h4 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h4><blockquote><p>借助 Expire 来设置就不是原子性操作了。所以还可以通过事务来确保原子性，但是还是有些问题，所以官方就引用了另外一个，使用 SET 命令本身已经从版本 2.6.12 开始包含了设置过期时间的功能</p></blockquote><h4 id="上锁可能出现的问题"><a href="#上锁可能出现的问题" class="headerlink" title="上锁可能出现的问题"></a>上锁可能出现的问题</h4><h5 id="1、-redis发现锁失败了要怎么办？中断请求还是循环请求？"><a href="#1、-redis发现锁失败了要怎么办？中断请求还是循环请求？" class="headerlink" title="1、 redis发现锁失败了要怎么办？中断请求还是循环请求？"></a>1、 redis发现锁失败了要怎么办？中断请求还是循环请求？</h5><blockquote><p>可以利用循环进行重复请求</p></blockquote><h5 id="2、-循环请求的话，如果有一个获取了锁，其它的在去获取锁的时候，是不是容易发生抢锁的可能？"><a href="#2、-循环请求的话，如果有一个获取了锁，其它的在去获取锁的时候，是不是容易发生抢锁的可能？" class="headerlink" title="2、 循环请求的话，如果有一个获取了锁，其它的在去获取锁的时候，是不是容易发生抢锁的可能？"></a>2、 循环请求的话，如果有一个获取了锁，其它的在去获取锁的时候，是不是容易发生抢锁的可能？</h5><blockquote><p>循环的时候可以sleep一下</p></blockquote><h5 id="3、-锁提前过期后，客户端A还没执行完，然后客户端B获取到了锁，这时候客户端A执行完了，会不会在删锁的时候把B的锁给删掉？"><a href="#3、-锁提前过期后，客户端A还没执行完，然后客户端B获取到了锁，这时候客户端A执行完了，会不会在删锁的时候把B的锁给删掉？" class="headerlink" title="3、 锁提前过期后，客户端A还没执行完，然后客户端B获取到了锁，这时候客户端A执行完了，会不会在删锁的时候把B的锁给删掉？"></a>3、 锁提前过期后，客户端A还没执行完，然后客户端B获取到了锁，这时候客户端A执行完了，会不会在删锁的时候把B的锁给删掉？</h5><blockquote><p>不一定，可以借助key-value的value进行判断</p></blockquote><h5 id="锁续约问题"><a href="#锁续约问题" class="headerlink" title="锁续约问题"></a>锁续约问题</h5><blockquote><p><strong>Redission</strong><br>当成功的获取一个锁的时候，就会产生一个 watch dog 进行锁续期，每10秒去检查一次，然后重置成设定的过期时间<br>加锁机制是lua脚本<br>解锁过程就比较简单了，如果是程序计数器则继续进行-1，直到等于0，然后删除该key即可（unlock操作）</p></blockquote><h5 id="Lua原子性"><a href="#Lua原子性" class="headerlink" title="Lua原子性"></a>Lua原子性</h5><blockquote><p>Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行： 当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 这和使用 MULTI / EXEC 包围的事务很类似。 在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed)</p></blockquote><h2 id="了解java内存模型吗，JVM整体和并发的一些关系"><a href="#了解java内存模型吗，JVM整体和并发的一些关系" class="headerlink" title="了解java内存模型吗，JVM整体和并发的一些关系"></a>了解java内存模型吗，JVM整体和并发的一些关系</h2><blockquote><p>Java内存模型就是定义程序中变量（静态变量、数组对象元素等，不包括局部变量、方法参数）的访问规则</p></blockquote><h3 id="内存模型操作的八个指令"><a href="#内存模型操作的八个指令" class="headerlink" title="内存模型操作的八个指令"></a>内存模型操作的八个指令</h3><p><a href="https://www.cnblogs.com/zzq6032010/p/10328399.html" target="_blank" rel="noopener">博客原文</a></p><ul><li><p>lock：作用于主内存变量，将该变量标识为一个线程独占的状态</p></li><li><p>unlock：作用于主内存变量，将独占状态释放</p></li><li><p>read：作用于主内存变量，将值拷贝到工作内存中</p></li><li><p>load：作用于工作内存中的变量，将值放到工作内存中的变量副本中</p></li><li><p>use：作用于工作内存中的变量，将值传给执行引擎</p></li><li><p>asign：作用于工作内存中的变量，将执行引擎中的值赋给工作内存中的变量</p></li><li><p>store：作用于工作内存中的变量，将值传给主内存</p></li><li><p>write：作用于主内存中的变量，将工作内存中返回的值放到主内存变量中</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><blockquote><p>保证load与use必须相邻调用，即要use这个变量，必定先执行read/load，这样每次都能获取到最新的变量值；它又保证asign与store必须相邻调用，即在工作内存中将该变量改了之后，必定会先同步到主内存中</p></blockquote></li></ul><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><blockquote><p>是一个双向的链表，概念上的队列，但不是真正的实现也是队列</p></blockquote><h3 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h3><blockquote><p>是根据condition创建出来的队列，上锁后可以负责对线程的监视，比synchronized的监视器更加灵活，是一个单向的链表，当唤醒界节点的时候会直接添加到阻塞队列中</p></blockquote><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><h4 id="1-waitstatus"><a href="#1-waitstatus" class="headerlink" title="1. waitstatus"></a>1. waitstatus</h4><ol><li><p>CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</p></li><li><p>SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。</p></li><li><p>CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</p></li><li><p>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态</p><h4 id="2-prev"><a href="#2-prev" class="headerlink" title="2. prev"></a>2. prev</h4><blockquote><p>前驱节点</p></blockquote><h4 id="3-next"><a href="#3-next" class="headerlink" title="3. next"></a>3. next</h4><blockquote><p>后继节点</p></blockquote><h4 id="4-thread"><a href="#4-thread" class="headerlink" title="4. thread"></a>4. thread</h4><blockquote><p>thread 同步线程队列主要存储的线程信息。</p></blockquote><h4 id="5-nextwaiter"><a href="#5-nextwaiter" class="headerlink" title="5. nextwaiter"></a>5. nextwaiter</h4><p>AQS中阻塞队列采用的是用双向链表保存，用prve和next相互链接。而AQS中条件队列是使用单向列表保存的，用<br>nextWaiter来连接。阻塞队列和条件队列并不是使用的相同的数据结构</p></li></ol><p><a href="https://segmentfault.com/a/1190000015804888" target="_blank" rel="noopener">精髓原帖</a></p><p>在Node节点的源码中有两个常量属性</p><pre><code class="java"><span class="comment">// 共享模式</span><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();<span class="comment">// 独占模式</span><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;<span class="comment">// 其他模式</span><span class="comment">// 其他非空值：条件等待节点（调用Condition的await方法的时候）</span></code></pre><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><blockquote><p>Channel(通道)，Buffer(缓冲区), Selector</p></blockquote><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><blockquote><p>通道是双向的，通过一个Channel既可以进行读，也可以进行写</p></blockquote><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><ul><li><p>capacity:缓冲区数组的总长度</p></li><li><p>position:下一个要操作的数据元素的位置</p></li><li><p>limit:缓冲区数组中不可操作的下一个元素的位置：limit&lt;=capacity</p></li><li><p>mark:用于记录当前position的前一个位置或者默认是-1</p></li></ul><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><blockquote><p>Selector类是NIO的核心类，Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理</p></blockquote><h2 id="http-和-https"><a href="#http-和-https" class="headerlink" title="http 和 https"></a>http 和 https</h2><p>HTTPS和HTTP的主要区别</p><ul><li><p>https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</p></li><li><p>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。</p></li><li><p>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p></li><li><p>http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</p></li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·蘑菇街总结》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/18/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-%E8%98%91%E8%8F%87%E8%A1%97%E6%80%BB%E7%BB%93/"/>
    <id>http://runindark.com/2020/03/18/2020春招/我为阿里-蘑菇街总结/</id>
    <published>2020-03-18T14:23:17.382Z</published>
    <updated>2020-06-28T01:43:26.137Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>2020-03-18 蘑菇街一面 是凉凉了 但是很高兴的是面试官真的很耐心 自己也发现了很多的问题和不足<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h4 id="动态代理的两种方法"><a href="#动态代理的两种方法" class="headerlink" title="动态代理的两种方法"></a>动态代理的两种方法</h4><h5 id="Proxy-InvocationHandler"><a href="#Proxy-InvocationHandler" class="headerlink" title="Proxy + InvocationHandler"></a>Proxy + InvocationHandler</h5><p>被代理对象接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被代理类接口实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add user into database."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        System.out.println(<span class="string">"getUser from database."</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代理（中间）类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtil</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;    <span class="comment">// 被代理的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do sth before...."</span>);</span><br><span class="line">        Object result =  method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"do sth after...."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ProxyUtil(Object target)&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object proxyedObject = <span class="keyword">new</span> UserServiceImpl();    <span class="comment">// 被代理的对象</span></span><br><span class="line">        ProxyUtil proxyUtils = <span class="keyword">new</span> ProxyUtil(proxyedObject);</span><br><span class="line">        <span class="comment">// 生成代理对象，对被代理对象的这些接口进行代理：UserServiceImpl.class.getInterfaces()</span></span><br><span class="line">        UserService proxyObject = (UserService) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), </span><br><span class="line">                    UserServiceImpl.class.getInterfaces(), proxyUtils);</span><br><span class="line">        proxyObject.getUser(<span class="number">1</span>);</span><br><span class="line">        proxyObject.addUser(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>核心则在于被代理的对象必须要有含有自己方法的接口，才可以使用Proxy+InvocationHandler，同时，代理类中主要是通过调用被重写的invoke（）方法。</p></blockquote><h5 id="CGlib"><a href="#CGlib" class="headerlink" title="CGlib"></a>CGlib</h5><p>Cglib代理的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;    <span class="comment">// 被代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method arg1, Object[] arg2, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do sth before...."</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(arg0, arg2);</span><br><span class="line">        System.out.println(<span class="string">"do sth after...."</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());    <span class="comment">// 设置父类</span></span><br><span class="line">        <span class="comment">// 设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);    <span class="comment">// 在调用父类方法时，回调 this.intercept()</span></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object proxyedObject = <span class="keyword">new</span> UserServiceImpl();    <span class="comment">// 被代理的对象</span></span><br><span class="line">        CGProxy cgProxy = <span class="keyword">new</span> CGProxy(proxyedObject);</span><br><span class="line">        UserService proxyObject = (UserService) cgProxy.getProxyObject();</span><br><span class="line">        proxyObject.getUser(<span class="number">1</span>);</span><br><span class="line">        proxyObject.addUser(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>与Proxy+InvocationHandler不同，Cglib是利用enhancer.create创造了一个代理对象，而这个大力对象的父类就是被代理类，利用enhancer.setSuperclass()指定，同时利用enhancer.setCallback()回调被重写的intercept，完成对方法的包裹</p></blockquote><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><h3 id="聚合索引-和-非聚合索引"><a href="#聚合索引-和-非聚合索引" class="headerlink" title="聚合索引 和 非聚合索引"></a>聚合索引 和 非聚合索引</h3><blockquote><p>聚合索引是 数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。<br>非聚合索引是 该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引<br>言外之意，索引是有序的，如果存储数据和索引一样有序就是聚合索引，非聚合索引就是数据不是和索引本身一样有序</p></blockquote><h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><blockquote><p>数据和索引放在一起就是聚簇索引<br>地址和索引在一起，数据是通过地址再关联在一起是非聚簇索引</p></blockquote><h3 id="主索引，辅助索引"><a href="#主索引，辅助索引" class="headerlink" title="主索引，辅助索引"></a>主索引，辅助索引</h3><h3 id="聚合索引状态下"><a href="#聚合索引状态下" class="headerlink" title="聚合索引状态下"></a>聚合索引状态下</h3><blockquote><p>就是根据主键值建立的索引就是主索引<br>辅助索引又叫二级索引，他的索引存主键的值</p></blockquote><h3 id="非聚合索引状态下"><a href="#非聚合索引状态下" class="headerlink" title="非聚合索引状态下"></a>非聚合索引状态下</h3><blockquote><p>非聚簇索引的主索引和辅助索引的叶子节点的data都是存储的数据的物理地址，也就是说索引和数据并不是存储在一起的，数据的顺序和索引的顺序并没有任何关系，也就是索引顺序与数据物理排列顺序无关。</p></blockquote><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><h4 id="插入缓存"><a href="#插入缓存" class="headerlink" title="插入缓存"></a>插入缓存</h4><ol><li>正常情况下正常的插入速度很快</li><li>但是如果使用UUID的话，需要离散的先访问非聚集索引索引页，判断非索引也是否在缓冲池中，若在，则直接插入，若没在则放入Insert Buffer中，在Insert Buffer 中合并后插入到索引页，提高了插入性能<h3 id="索引失效问题"><a href="#索引失效问题" class="headerlink" title="索引失效问题"></a>索引失效问题</h3></li></ol><h4 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4><blockquote><p>如果组合索引是abc那么用where a或者where a，b 或者where abc都可以，但是如果用 where b这样子的跳跃会导致索引失效</p></blockquote><h4 id="前导模糊系列"><a href="#前导模糊系列" class="headerlink" title="前导模糊系列"></a>前导模糊系列</h4><blockquote><p>例：(like ‘%XX’或者like ‘%XX%’)</p></blockquote><h4 id="or失效"><a href="#or失效" class="headerlink" title="or失效"></a>or失效</h4><blockquote><p>使用 or 的时候会导致索引失效，可以改用union</p></blockquote><h4 id="判断null"><a href="#判断null" class="headerlink" title="判断null"></a>判断null</h4><blockquote><p>索引是b+树的排序结构，如果是null的话，导致节点不知道应该放在哪里</p></blockquote><h4 id="where-子句中使用-或-lt-gt-操作符"><a href="#where-子句中使用-或-lt-gt-操作符" class="headerlink" title="where 子句中使用!=或&lt;&gt;操作符"></a>where 子句中使用!=或&lt;&gt;操作符</h4><h4 id="in-和-not-in-也要慎用，"><a href="#in-和-not-in-也要慎用，" class="headerlink" title="in 和 not in 也要慎用，"></a>in 和 not in 也要慎用，</h4><blockquote><p>select id from t where num in(1,2,3)</p></blockquote><h3 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h3><p><a href="https://blog.csdn.net/qq_43079376/article/details/93647335" target="_blank" rel="noopener">原文博客</a></p><h4 id="属性原子性"><a href="#属性原子性" class="headerlink" title="属性原子性"></a>属性原子性</h4><h4 id="行可以唯一识别性"><a href="#行可以唯一识别性" class="headerlink" title="行可以唯一识别性"></a>行可以唯一识别性</h4><h4 id="数据信息不冲突"><a href="#数据信息不冲突" class="headerlink" title="数据信息不冲突"></a>数据信息不冲突</h4><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><ol><li>非主属性依赖主属性</li><li>主属性也要依赖其它的非主属性</li><li>非主属性不能被依赖<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="HashMap根据hashcode查找到对应位置的方法"><a href="#HashMap根据hashcode查找到对应位置的方法" class="headerlink" title="HashMap根据hashcode查找到对应位置的方法"></a>HashMap根据hashcode查找到对应位置的方法</h3><a href="https://blog.csdn.net/v123411739/article/details/78996181" target="_blank" rel="noopener">原帖地址</a></li><li>拿到 key 的 hashCode 值</li><li>将 hashCode 的高位参与运算，重新计算 hash 值</li><li>将计算出来的 hash 值与 (table.length - 1) 进行 &amp; 运算<h3 id="原因解释如下"><a href="#原因解释如下" class="headerlink" title="原因解释如下"></a>原因解释如下</h3><blockquote><p>首先拿到key的hashcode值，如果是并利用  hashcode ^ table.length  (table.length是2次幂)得到hash值，如果是与运算的话，假如table是初始化的16位，那么高位是无法进行运算的，结果值也就是被hashcode值的后四位所决定<br>之后用hash值 进行 hash &amp; (table.length)</p></blockquote><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3>满了以后用调用线程池的线程去执行他<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3>直接拒绝，啥也不干<h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3>报个错，然后直接拒绝，啥也不干<h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3>抛出最先加入使用的线程</li></ol></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;2020-03-18 蘑菇街一面 是凉凉了 但是很高兴的是面试官真的很耐心 自己也发现了很多的问题和不足&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·被字节血洗篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/16/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-%E5%AD%97%E8%8A%82%E8%A1%80%E6%B4%97/"/>
    <id>http://runindark.com/2020/03/16/2020春招/我为阿里-字节血洗/</id>
    <published>2020-03-16T13:15:03.321Z</published>
    <updated>2020-06-28T01:43:26.137Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br>总结了3.15日字节面试的一些问题，鲜血淋漓篇<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="高并发-为什么Synchronized可以保证线程的安全？"><a href="#高并发-为什么Synchronized可以保证线程的安全？" class="headerlink" title="高并发 - 为什么Synchronized可以保证线程的安全？"></a>高并发 - 为什么Synchronized可以保证线程的安全？</h2><p><a href="https://www.jianshu.com/p/7ddb0956590c" target="_blank" rel="noopener">博客参考</a></p><blockquote><p>JVM中对于同步方法和同步代码块是不一样的，本质上都有monitor对象，但是同步方法使用了monitorentre/monitorexit，而同步代码块则使用了ACC_SYNCHRONIZED标志（隐式）</p></blockquote><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><blockquote><p>Java中在JVM的处理上，每一个对象都会有一个对象头，monitor 存在于对象头的Mark Word 中(存储monitor引用指针)</p></blockquote><h3 id="Jvm对同步方法的处理（monitorenter-monitorexit）"><a href="#Jvm对同步方法的处理（monitorenter-monitorexit）" class="headerlink" title="Jvm对同步方法的处理（monitorenter/monitorexit）"></a>Jvm对同步方法的处理（monitorenter/monitorexit）</h3><h4 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h4><blockquote><ol><li>首先一个对象要有自己的monitor，当对象的monitor被占用的时候，则monitor被锁定，之后当一个线程需要获取该对象的时候，则需要调用monitorexit指令，首先要判断monitor的进入数，如果进入数为0，那么monitorenter进入成功，线程进入monitor，然后将进入数设为1，该线程则成为monitor的所有者。</li><li>如果线程已经占有了monitor，只是重新进入，那么monitor的进入数+1</li><li>如果其它线程在monitor被占领的时候来获取monitor那么，该线程则自动进入到阻塞状态，知道monitor的进入数为0，再重新尝试获取monitor的权限</li></ol></blockquote><h3 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h3><blockquote><ol><li>执行monitorexit必须是该对象monitor的所有者</li><li>monitorexit执行成功的时候，则monitor的进入数-1</li></ol></blockquote><h3 id="Jvm对同步代码块的处理（ACC-SYNCHRONIZED）"><a href="#Jvm对同步代码块的处理（ACC-SYNCHRONIZED）" class="headerlink" title="Jvm对同步代码块的处理（ACC_SYNCHRONIZED）"></a>Jvm对同步代码块的处理（ACC_SYNCHRONIZED）</h3><blockquote><ol><li>对于同步代码块，其常量池多了ACC_SYNCHRONIZED标志，也是flag的地方多了ACC_SYNCHRONIZED</li><li>同步代码块被调用的时候，JVM会调用指令去检查ACC_SYNCHRONIZED是否被设置，如果设置了则获取monitor，获取成功后则执行代码块中的内容，执行期间其它的线程将无法再获得monitor</li></ol></blockquote><h3 id="wait-notify-notifyall"><a href="#wait-notify-notifyall" class="headerlink" title="wait/notify/notifyall"></a>wait/notify/notifyall</h3><blockquote><ol><li>wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因</li><li>要特别理解的一点是，与sleep方法不同的是wait方法调用完成后，线程将被暂停，但wait方法将会释放当前持有的监视器锁(monitor)，直到有线程调用notify/notifyAll方法后方能继续执行，而sleep方法只让线程休眠并不释放锁。同时notify/notifyAll方法调用后，并不会马上释放监视器锁，而是在相应的synchronized(){}/synchronized方法执行结束后才自动释放锁</li></ol></blockquote><h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><ol><li>//中断线程（实例方法）<br>public void Thread.interrupt();</li><li>//判断线程是否被中断（实例方法）<br>public boolean Thread.isInterrupted();</li><li>//判断是否被中断并清除当前中断状态（静态方法）<br>public static boolean Thread.interrupted();</li></ol><h3 id="Interrupt的作用"><a href="#Interrupt的作用" class="headerlink" title="Interrupt的作用"></a>Interrupt的作用</h3><blockquote><p>可以直接中断阻塞的线程，但是<strong>无法阻塞获取锁或者拿到锁的线程</strong></p></blockquote><h2 id="JVM-private-final-a-1-请问他的创建的过程？"><a href="#JVM-private-final-a-1-请问他的创建的过程？" class="headerlink" title="JVM - private final a = 1; 请问他的创建的过程？"></a>JVM - private final a = 1; 请问他的创建的过程？</h2><h3 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h3><ol><li>加载</li><li>验证</li><li>准备<blockquote><p>在准备阶段就直接将将值进行替换，不占用内存空间</p></blockquote></li><li>解析</li><li>初始化</li></ol><h3 id="深入："><a href="#深入：" class="headerlink" title="深入："></a>深入：</h3><blockquote><p>static 静态变量在正常情况下是 在准备阶段在方法区分配空间，但是直到最后的初始化阶段才正确的赋值<br>例： public static int value = 5<br>在准备阶段  value 已在方法区获得空间,但是值为0<br>在最后的初始化阶段才真正的编程 5 </p></blockquote><h3 id="加载，验证阶段的内容补充"><a href="#加载，验证阶段的内容补充" class="headerlink" title="加载，验证阶段的内容补充"></a>加载，验证阶段的内容补充</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><blockquote><p>在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下3件事情： </p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）； </li></ol></blockquote><blockquote><ol start="2"><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； </li></ol></blockquote><blockquote><ol start="3"><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口； </li></ol></blockquote><blockquote><p>加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。 </p></blockquote><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><blockquote><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br>验证阶段大致会完成4个阶段的检验动作： </p></blockquote><blockquote><ol><li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 </li></ol></blockquote><blockquote><ol start="2"><li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 </li></ol></blockquote><blockquote><ol start="3"><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 </li></ol></blockquote><blockquote><ol start="4"><li>符号引用验证：确保解析动作能正确执行。 </li></ol></blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</p><h2 id="JVM-GC回收的时候那些垃圾是怎么被标识的？"><a href="#JVM-GC回收的时候那些垃圾是怎么被标识的？" class="headerlink" title="JVM - GC回收的时候那些垃圾是怎么被标识的？"></a>JVM - GC回收的时候那些垃圾是怎么被标识的？</h2><h3 id="语义双关注意"><a href="#语义双关注意" class="headerlink" title="语义双关注意"></a>语义双关注意</h3><blockquote><p>可能面试官想问的是标记垃圾的方法（可达性分析和程序计数器法）<br>还可能是想问具体是怎么标记的？</p></blockquote><h3 id="相关的内容补充"><a href="#相关的内容补充" class="headerlink" title="相关的内容补充"></a>相关的内容补充</h3><h4 id="OopMap"><a href="#OopMap" class="headerlink" title="OopMap"></a>OopMap</h4><blockquote><p>垃圾回收的时候需要对栈上的内存进行扫描，判断哪些位置存在Reference类型，但是如果是直接查找的话，会产生遍历的问题，这样是慢的。<br>所以HotSpot用OopMap对Reference进行存储，这样子就可以用空间换时间，避免了全栈的扫描</p></blockquote><h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p><strong>并发标记</strong></p><ol><li>黑色：根对象，或者该对象与它的子对象都被扫描过（对象被标记了，且它的所有field也被标记完了）。</li><li>灰色：对象本身被扫描，但还没扫描完该对象中的子对象（它的field还没有被标记或标记完）。</li><li>白色：未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，既垃圾对象（对象没有被标记到）。<h4 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h4>(RememberSet)[<a href="https://img-blog.csdn.net/20170705174843116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGZ6MDMzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center]" target="_blank" rel="noopener">https://img-blog.csdn.net/20170705174843116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGZ6MDMzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center]</a></li></ol><blockquote><p>以G1收集器为例，G1由于将内存空间分配成了Region，因此如果每个Region都去记录自己的对象引用了什么其它的对象，会造成很多不必要的开销，那么如果换个思维只记录自己的新生代被谁的老年代引用了就可以减小开销（因为新生代无论如何都是要被全部扫描的，记录不同Region新生代与新生代之间的引用是没有意义的，同时老年代很少，因此扫描老年代是不是引用其它新生代会更快），如果被记录的话，则直接假如到GcRoot中这样就可以避免一些不必要的扫描。<br>开始说卡表，每个Region被分成了若干个<strong>卡（Card）</strong>，这些<strong>Card</strong>都会记录在全局卡表中，<strong>Card</strong>中每个元素对应着内存区域中一个特定大小的内存块，这个内存块则被称之为<strong>卡页</strong>，一个卡页一般里面不只一个对象，所以卡页存在着跨Region引用，那么这样的元素的值标识为1。<br>这样在Minor GC时，只需要将变脏的Region(写屏障,这个事情是并发标记的时候完成的，直接加入到GcRoot可以提升效率)中的那个卡页加入GC Roots一并扫描即可。比起扫描老年代的所有对象，大大减少了扫描的数据量，提升了效率</p></blockquote><h2 id="TCP-的连接过程（从网络层去分析）"><a href="#TCP-的连接过程（从网络层去分析）" class="headerlink" title="TCP 的连接过程（从网络层去分析）"></a>TCP 的连接过程（从网络层去分析）</h2><blockquote><p>TCP三次握手 四次招手</p></blockquote><h2 id="口述TCP是如何保证数据传输的？"><a href="#口述TCP是如何保证数据传输的？" class="headerlink" title="口述TCP是如何保证数据传输的？"></a>口述TCP是如何保证数据传输的？</h2><h2 id="线程共享的部分"><a href="#线程共享的部分" class="headerlink" title="线程共享的部分"></a>线程共享的部分</h2><ul><li><p>堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）</p></li><li><p>全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的</p></li><li><p>静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的</p></li><li><p>文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。</p></li></ul><h2 id="深入到操作系统线程之间什么什么是独享的资源"><a href="#深入到操作系统线程之间什么什么是独享的资源" class="headerlink" title="深入到操作系统线程之间什么什么是独享的资源"></a>深入到操作系统线程之间什么什么是独享的资源</h2><ul><li>栈 栈是独享的</li><li>寄存器<h2 id="请问只要是加了Synchronized就安全了吗？"><a href="#请问只要是加了Synchronized就安全了吗？" class="headerlink" title="请问只要是加了Synchronized就安全了吗？"></a>请问只要是加了Synchronized就安全了吗？</h2><blockquote><p>静态方法 和 实例方法  的区别</p></blockquote><h2 id="有关List集合的删改功能知道吗？"><a href="#有关List集合的删改功能知道吗？" class="headerlink" title="有关List集合的删改功能知道吗？"></a>有关List集合的删改功能知道吗？</h2><blockquote><p>就是利用System.copy的功能往前或者往后移动一位<br>扩容机制就是利用调用EnsureCapacityInternal()方法去调用grow函数，再使用Arrays.copyOf进行扩容</p></blockquote></li></ul><h2 id="Java-线程池的实现"><a href="#Java-线程池的实现" class="headerlink" title="Java 线程池的实现"></a>Java 线程池的实现</h2><h3 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h3><p><a href="https://baijiahao.baidu.com/s?id=1641469444994560637&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">原帖</a><br>线程池能够对线程进行统一分配，调优和监控：</p><ul><li>降低资源消耗（线程无限制地创建，然后使用完毕后销毁）</li><li>提高响应速度（无须创建线程）</li><li>提高线程的可管理性</li></ul><h3 id="线程的执行过程"><a href="#线程的执行过程" class="headerlink" title="线程的执行过程"></a>线程的执行过程</h3><ol><li>首先添加到核心线程池</li><li>核心线程池满以后，直接进入阻塞队列</li><li>阻塞队列满了以后判断最大核心数</li><li>如果未达到核心线程数目，则线程池进行扩容创建一个Worker执行提交任务，新建的Worker会被添加到线程集合workers中</li><li>如果超过maximumPoolSize会执行拒绝策略<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4></li><li>调用线程执行 ： 就是调用其它的线程</li><li>终止执行： 直接抛出RejectExecutionException异常</li><li>丢弃任务： 直接丢弃，不会抛异常</li><li>丢失老任务： 删除等待队列中最老的任务，然后重新执行</li></ol><h2 id="Mybatis缓存"><a href="#Mybatis缓存" class="headerlink" title="Mybatis缓存"></a>Mybatis缓存</h2></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;总结了3.15日字节面试的一些问题，鲜血淋漓篇&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·Redis篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/14/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-Redis/"/>
    <id>http://runindark.com/2020/03/14/2020春招/我为阿里-Redis/</id>
    <published>2020-03-14T09:58:51.001Z</published>
    <updated>2020-06-28T01:43:26.138Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="来来来，讲一讲为什么Redis这么快？"><a href="#来来来，讲一讲为什么Redis这么快？" class="headerlink" title="来来来，讲一讲为什么Redis这么快？"></a>来来来，讲一讲为什么Redis这么快？</h2><blockquote><p>首先，采用了多路复用io阻塞机制<br>然后，数据结构简单，操作节省时间<br>最后，运行在内存中，自然速度快</p></blockquote><h3 id="Redis为什么是单线程的？"><a href="#Redis为什么是单线程的？" class="headerlink" title="Redis为什么是单线程的？"></a>Redis为什么是单线程的？</h3><blockquote><p>Redis的瓶颈不是cpu的运行速度，而往往是网络带宽和机器的内存大小。再说了，单线程切换开销小，容易实现既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了</p></blockquote><h3 id="如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办"><a href="#如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办" class="headerlink" title="如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办"></a>如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办</h3><blockquote><p>多起几个Redis进程就好了。Redis是keyvalue数据库，又不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。redis-cluster可以帮你做的更好</p></blockquote><h3 id="我们使用单线程的方式是无法发挥多核CPU-性能，有什么办法发挥多核CPU的性能嘛？"><a href="#我们使用单线程的方式是无法发挥多核CPU-性能，有什么办法发挥多核CPU的性能嘛？" class="headerlink" title="我们使用单线程的方式是无法发挥多核CPU 性能，有什么办法发挥多核CPU的性能嘛？"></a>我们使用单线程的方式是无法发挥多核CPU 性能，有什么办法发挥多核CPU的性能嘛？</h3><blockquote><p>我们可以通过在单机开多个Redis</p></blockquote><h2 id="简述一下Redis值的五种类型"><a href="#简述一下Redis值的五种类型" class="headerlink" title="简述一下Redis值的五种类型"></a>简述一下Redis值的五种类型</h2><ul><li>String 整数，浮点数或者字符串</li><li>Set 集合</li><li>Zset 有序集合</li><li>Hash 散列表</li><li>List 列表</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>数据结构 =&gt; SDS<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">//记录当前字节数组的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">//记录了当前字节数组总共分配的内存大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">//记录了当前字节数组的属性、用来标识到底是sdshdr8还是sdshdr16等</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">//保存了字符串真正的值以及末尾的一个\0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><blockquote><ol><li>记录数组的长度，把复杂度从o(n)变成了0(1)</li><li>SDS预分配存储空间的方式来减少内存的频繁分配</li><li>redis不同长度的字符串用不同的数据结构，因此用flag标记当前是什么类型的数据结构</li></ol></blockquote><h4 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h4><p>（sdscat =》给字符串后面再拼接一个字符串）</p><ul><li>当sdscat 之后内存小于 1M，字符串长度*2+1 （’\0’）</li><li>当sdscat 之后内存大于 1M, 字符串长度 + 1M + 1（’\0’） <h4 id="空间懒惰回收"><a href="#空间懒惰回收" class="headerlink" title="空间懒惰回收"></a>空间懒惰回收</h4>如果sdstrim（减少字符串），则不急着回收空间，下次如果需要添加长度，直接使用多余的空间。</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><blockquote><p>结构是双向链表<br>由于数据结构的设计，可以更方便的获取链表长度</p></blockquote><p>链表的数据结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">     <span class="comment">//表头节点</span></span><br><span class="line">     listNode *head;</span><br><span class="line">     <span class="comment">//表尾节点</span></span><br><span class="line">     listNode *tail;</span><br><span class="line">     <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">     <span class="comment">//节点值复制函数</span></span><br><span class="line">     <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值释放函数</span></span><br><span class="line">     <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值对比函数</span></span><br><span class="line">     <span class="keyword">int</span> (*match) (<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></p><p>ListNode节点数据结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">       <span class="comment">//前置节点</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">       <span class="comment">//后置节点</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">       <span class="comment">//节点的值</span></span><br><span class="line">       <span class="keyword">void</span> *value;  </span><br><span class="line">&#125;listNode</span><br></pre></td></tr></table></figure></p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>哈希表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure></p><p>哈希表节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">// 单链表结构</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>字典<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><blockquote><p>在字典中存在dictht数组，表明是两个hash表<br>ht[1]的容量是ht[0]的两倍<br>把ht[0]中的元素rehash复制到ht[1]中</p></blockquote><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p><a href="https://blog.csdn.net/wangmaohong0717/article/details/84611426" target="_blank" rel="noopener">原帖地址</a></p><blockquote><p>进行读操作：会先去ht[0]中找，找不到再去ht[1]中找。<br>进行写操作：直接写在ht[1]中。<br>进行删除操作：与读类似。</p></blockquote><p>但是每一次的增删改查的操作都会把数据从ht[0]转移到ht[1],是为了避免数据迁移导致的cpu负载问题</p><h3 id="有序集合的实现方式是哪种数据结构？"><a href="#有序集合的实现方式是哪种数据结构？" class="headerlink" title="有序集合的实现方式是哪种数据结构？"></a>有序集合的实现方式是哪种数据结构？</h3><blockquote><p>跳跃表</p></blockquote><h2 id="Redis怎样防止异常数据不丢失？"><a href="#Redis怎样防止异常数据不丢失？" class="headerlink" title="Redis怎样防止异常数据不丢失？"></a>Redis怎样防止异常数据不丢失？</h2><h3 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h3><blockquote><p>将某个时间点的所有数据都存放到硬盘上。<br>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。<br>如果系统发生故障，将会丢失最后一次创建快照之后的数据。<br>如果数据量很大，保存快照的时间会很长。</p></blockquote><h3 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h3><blockquote><p>将写命令添加到 AOF 文件（Append Only File）的末尾。<br>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：<br>选项同步频率always每个写命令都同步everysec每秒同步一次no让操作系统来决定何时同步<br>always 选项会严重减低服务器的性能；<br>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；<br>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量<br>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p></blockquote><h2 id="讲一讲缓存穿透，缓存雪崩以及缓存击穿吧"><a href="#讲一讲缓存穿透，缓存雪崩以及缓存击穿吧" class="headerlink" title="讲一讲缓存穿透，缓存雪崩以及缓存击穿吧"></a>讲一讲缓存穿透，缓存雪崩以及缓存击穿吧</h2><ul><li>缓存穿透：就是客户持续向服务器发起对不存在服务器中数据的请求。客户先在Redis中查询，查询不到后去数据库中查询。</li><li>缓存击穿：就是一个很热门的数据，突然失效，大量请求到服务器数据库中</li><li>缓存雪崩：就是大量数据同一时间失效。</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>缓存穿透：<br>1.接口层增加校验，对传参进行个校验，比如说我们的id是从1开始的，那么id&lt;=0的直接拦截；<br>2.缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户反复用同一个id暴力攻击</li><li>缓存击穿：<br>最好的办法就是设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员</li><li>缓存雪崩：<br>1.缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。<br>2.如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="主从同步过程"><a href="#主从同步过程" class="headerlink" title="主从同步过程"></a>主从同步过程</h3><blockquote><ol><li>master启动线程生成RDB                                 </li><li>同时master把新增的请求放到内存中          </li><li>slaver先将RDB文件写入磁盘                      </li><li>slaver把RDB写入磁盘后再加载到内存中</li><li>最后master将缓存的请求再发送给slaver</li></ol></blockquote><h4 id="同步过程细述"><a href="#同步过程细述" class="headerlink" title="同步过程细述"></a>同步过程细述</h4><ol><li>客户端向服务器发送SLAVEOF命令，让当前服务器成为Slave；<blockquote><p>从节点执行slaveof保存主节点信息<br>从节点通过定时任务发现主节点信息，并建立连接<br>从节点发送ping命令，主节点则返回pong命令<br>成功建立连接</p></blockquote></li><li>从节点根据自己是否保存Master runid来判断是否是第一次复制,</li><li>如果是第一次复制，则进行全量复制，从节点向Master发送PSYNC ? -1 命令来进行完整同步；</li><li>如果不是第一次复制，从节点向Master发送PSYNC runid offset；</li><li>Master接收到PSYNC 命令后首先判断runid是否和本机的id一致，如果一致则会再次判断offset偏移量和本机的偏移量相差有没有超过 大小，如果没有那么就给Slave发送CONTINUE，此时Slave只需要等待Master传回失去连接期间丢失的命令；如果runid和本机id不一致或者双方offset差距超过了复制积压缓冲区大小，那么就会返回FULLRESYNC runid offset，Slave将runid保存起来，并进行完整同步。<blockquote><p>上述涉及三个信号<br>FullReSync -&gt; 全量复制信号<br>Continue -&gt; 部分复制信号<br>Err -&gt; psync进行部分复制的时候发现，offset偏移量和主节点的偏移量超过了复制积压缓存区，返回错误信号，进行全量复制FullResync</p></blockquote></li></ol><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p><a href="https://mp.weixin.qq.com/s/nDqNYC0wYFH2Y21acAGNiw?from=groupmessage&amp;scene=1&amp;subscene=10000&amp;clicktime=1585109654&amp;enterid=1585109654" target="_blank" rel="noopener">原帖地址</a></p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><h5 id="1-定时任务"><a href="#1-定时任务" class="headerlink" title="1. 定时任务"></a>1. 定时任务</h5><ul><li>通过向主从节点发送info命令获取最新的主从结构；</li><li>通过发布订阅功能获取其他哨兵节点的信息；</li><li>通过向其他节点发送ping命令进行心跳检测，判断是否下线<h5 id="2-主观下线"><a href="#2-主观下线" class="headerlink" title="2. 主观下线"></a>2. 主观下线</h5><blockquote><p>心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线</p></blockquote><h5 id="3-客观下线"><a href="#3-客观下线" class="headerlink" title="3. 客观下线"></a>3. 客观下线</h5><blockquote><p>哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。<br><strong>客观下线是主节点才有的概念；如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作</strong></p></blockquote><h5 id="4-选举领导者哨兵节点"><a href="#4-选举领导者哨兵节点" class="headerlink" title="4. 选举领导者哨兵节点"></a>4. 选举领导者哨兵节点</h5><blockquote><p>Raft算法 ： 哪个节点先发出申请成为主节点，哪个节点就当master</p></blockquote><h5 id="5-故障转移"><a href="#5-故障转移" class="headerlink" title="5. 故障转移"></a>5. 故障转移</h5></li></ul><ol><li>先过滤不健康的节点</li><li>根据优先级推荐出节点</li><li>选出来的节点成为主节点</li><li>原来的主节点变成新的主节点的从节点</li></ol><h2 id="Redis-和-Memcached-有啥区别，为啥选择用Redis作为你们的缓存中间件？"><a href="#Redis-和-Memcached-有啥区别，为啥选择用Redis作为你们的缓存中间件？" class="headerlink" title="Redis 和 Memcached 有啥区别，为啥选择用Redis作为你们的缓存中间件？"></a>Redis 和 Memcached 有啥区别，为啥选择用Redis作为你们的缓存中间件？</h2><ol><li>Redis 相比 Memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。</li><li>在 redis3.x 版本中，便能支持 Cluster 模式，而 Memcached 没有原生的集群模式</li><li>Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Remcached，还是稍有逊色</li><li>memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小 </li></ol><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><blockquote><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>Redis的事务本质上就是一串命令的执行，已经不可被打断</p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·网络协议篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/13/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>http://runindark.com/2020/03/13/2020春招/我为阿里-网络协议/</id>
    <published>2020-03-13T03:52:12.673Z</published>
    <updated>2020-06-28T01:43:26.138Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="五层协议体系结构"><a href="#五层协议体系结构" class="headerlink" title="五层协议体系结构"></a>五层协议体系结构</h2><ol start="5"><li>应用层<blockquote><p>顾名思义就是上层的网络应用 域名，Http协议等</p></blockquote></li><li>运输层<blockquote><p>两台主机之间提供统用的数据传输服务</p></blockquote></li><li>网络层<blockquote><p>选择合适的路由进行数据交换</p></blockquote></li><li>数据链路层<blockquote><p>一段一段的将数据发送</p></blockquote></li><li>物理层<blockquote><p>物理主机之间的比特流交换</p></blockquote></li></ol><h2 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://upload-images.jianshu.io/upload_images/7368936-abf0a9b7fc6c8eb3.png?imageMogr2/auto-orient/strip|imageView2/2/w/470/format/webp" alt=""></p><ol><li>第一次握手： 客户端（client）向接收端（server）发送标志SYN/ACK，但是 <strong>客户端什么都不知道（接收端直到了自己接收正常，也知道客户端发送正常）</strong> </li><li>第二次握手： 接收端（server）向客户端（client）发送标志SYN/ACK数据包，现在<strong>客户端知道自己接收正常，自己发送正常，但是服务端不知道自己是不是发送正常</strong></li><li>第三次握手， 客户端（client）向接收端（server）发送标志ACK数据包，现在<strong>客户端知道自己发送接收正常，服务端也直到自己发送接收正常</strong></li></ol><blockquote><p>总结：三次握手的原因就是因为数据传输时单向的，对方接收后，发送方属于不知情着，所以才有了三次握手</p></blockquote><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="https://img-blog.csdn.net/20170606084851272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><ol><li>客户端向接收端发送Fin请求，告诉接收端说我这边没什么要发送的了</li><li>接收端向客户端发送一个ACK，告诉客户端说我知道你这边没啥要发送的了</li><li>接收端向客户端发送一个Fin，也告诉客户端说我也没什么要发送的了</li><li>客户端也发送一个ACK给接收端，确认知道了接收端没什么要发送的了</li></ol><h2 id="TCP-VS-UDP"><a href="#TCP-VS-UDP" class="headerlink" title="TCP VS UDP"></a>TCP VS UDP</h2><blockquote><p>TCP保证可靠的连接，UDP只负责交付数据，因此UDP占用的资源少，发送的数据多，TCP占用资源多，发送的数据较少，但是保证了数据传输的绝对稳定</p></blockquote><h3 id="TCP为啥稳定"><a href="#TCP为啥稳定" class="headerlink" title="TCP为啥稳定"></a>TCP为啥稳定</h3><ul><li>TCP会把数据自动分成合适有序有编号的数据包</li><li>TCP发送的时候会对头部和数据进行校验</li><li>TCP会有流量控制，会设立缓冲区，每次发送的时候也是从缓冲区中读取发送</li><li>发送超时会重新进行发送</li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·Spring》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/12/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-Spring/"/>
    <id>http://runindark.com/2020/03/12/2020春招/我为阿里-Spring/</id>
    <published>2020-03-12T15:02:23.758Z</published>
    <updated>2020-06-28T01:43:26.634Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br>[文章都是搬运艿艿的]<br>[<a href="http://svip.iocoder.cn/Java/Core/Interview/]" target="_blank" rel="noopener">http://svip.iocoder.cn/Java/Core/Interview/]</a></excerpt></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Spring-核心组件-（8大模块）"><a href="#Spring-核心组件-（8大模块）" class="headerlink" title="Spring 核心组件 （8大模块）"></a>Spring 核心组件 （8大模块）</h2><h3 id="Spring-Core"><a href="#Spring-Core" class="headerlink" title="Spring Core"></a>Spring Core</h3><blockquote><p>核心容易，主要是提供Ioc的依赖注入功能</p></blockquote><h3 id="Spring-Aspects"><a href="#Spring-Aspects" class="headerlink" title="Spring Aspects"></a>Spring Aspects</h3><blockquote><p>为了让Spring可以更好的融合AspectJ，实际上也是切面</p></blockquote><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><blockquote><p>提供了面向切面编程的实现</p></blockquote><h3 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h3><blockquote><p>数据库连接驱动</p></blockquote><h3 id="Spring-JMS"><a href="#Spring-JMS" class="headerlink" title="Spring JMS"></a>Spring JMS</h3><blockquote><p>Java 消息服务（ Java Message Service  ， JMS ）</p></blockquote><h3 id="Spring-ORM"><a href="#Spring-ORM" class="headerlink" title="Spring ORM"></a>Spring ORM</h3><blockquote><p>ORM的全称是Object Relational Mapping，即对象关系映射 ==&gt; 为Mybatis，Hibernate提供支持</p></blockquote><h3 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h3><blockquote><p>为Web应用提供支持</p></blockquote><h3 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h3><blockquote><p>顾名思义就是为了测试 Junit等</p></blockquote><h2 id="RestController-vs-Controller"><a href="#RestController-vs-Controller" class="headerlink" title="@RestController  vs @Controller"></a>@RestController  vs @Controller</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><blockquote><p>如果是@Controler，Return的值将直接指向一个页面，或者用转发和重定向的方式<br>如果加上@ResponseBody 那么就是@Controller</p></blockquote><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><blockquote><p>也就是 前后分离 模式下最常用的解决方式</p></blockquote><h3 id="Request-Response-的过程"><a href="#Request-Response-的过程" class="headerlink" title="Request / Response 的过程"></a>Request / Response 的过程</h3><blockquote><p>DispatcherServlet -&gt; Handler Mapping -&gt; Controller/RestController<br>如果是 @Controller则是继续到View层 ，如果是@RestController 直接返回Client</p></blockquote><h2 id="谈谈自己对IOC的理解"><a href="#谈谈自己对IOC的理解" class="headerlink" title="谈谈自己对IOC的理解"></a>谈谈自己对IOC的理解</h2><blockquote><p>谈到Ioc就是一种托付的关系，最传统的应用所创建的对象等全部都托付给系统本身之间的<br>依赖,无论耦合度，都是在不断的变大，Ioc控制反转，也就是责任托付从系统本身变成了<br>由Ioc容器管理，我们只需要明白自己需要什么，不用去想怎么管理怎么创建，如果需要的话可以直接使用xml，注解等方式直接配置引用</p></blockquote><h2 id="Ioc初始化机制"><a href="#Ioc初始化机制" class="headerlink" title="Ioc初始化机制"></a>Ioc初始化机制</h2><blockquote><p>XML &gt;读取&gt; Resource &gt;解析&gt; BeanDefinition &gt;注册&gt; BeanFactory</p></blockquote><blockquote><p>xml 是程序员的配置 ，并根据反射机制可以通过BeanDefinition映射，在BeanFactory中创建出对象</p></blockquote><h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP 面向切面编程"></a>AOP 面向切面编程</h2><blockquote><p>Aop就是一种想要把自己构造出来的方法切入到某个已经写好的类指定的方法之中</p></blockquote><h3 id="1-通知（Advice）"><a href="#1-通知（Advice）" class="headerlink" title="1.通知（Advice）"></a>1.通知（Advice）</h3><blockquote><p>自己需要在某类的指定方法上实现的功能，日志，事务，安全等功能</p></blockquote><h3 id="2-连接点（JoinPoint）"><a href="#2-连接点（JoinPoint）" class="headerlink" title="2.连接点（JoinPoint）"></a>2.连接点（JoinPoint）</h3><blockquote><p>就是Spring中可以插入通知的地方</p></blockquote><h3 id="3-切入点（Pointcut）"><a href="#3-切入点（Pointcut）" class="headerlink" title="3.切入点（Pointcut）"></a>3.切入点（Pointcut）</h3><blockquote><p>就是在需要插入通知的方法重新实现一下，可以说是作为一个标记</p></blockquote><h3 id="4-切面（Aspect）"><a href="#4-切面（Aspect）" class="headerlink" title="4.切面（Aspect）"></a>4.切面（Aspect）</h3><blockquote><p>就是切入点和通知放在一起，同时构成的一个类的某个位置</p></blockquote><h3 id="5-引入（introduction）"><a href="#5-引入（introduction）" class="headerlink" title="5.引入（introduction）"></a>5.引入（introduction）</h3><blockquote><p>就是把切面的功能正式融入到类中使用</p></blockquote><h3 id="6-目标（target）"><a href="#6-目标（target）" class="headerlink" title="6.目标（target）"></a>6.目标（target）</h3><blockquote><p>别切入的类</p></blockquote><h3 id="7-代理-proxy"><a href="#7-代理-proxy" class="headerlink" title="7.代理(proxy)"></a>7.代理(proxy)</h3><blockquote><p>Java的动态代理机制　　</p></blockquote><h3 id="8-织入-weaving"><a href="#8-织入-weaving" class="headerlink" title="8.织入(weaving)"></a>8.织入(weaving)</h3><blockquote><p>引入到类中后，开始正式的调用</p></blockquote><h3 id="串读理解"><a href="#串读理解" class="headerlink" title="串读理解"></a>串读理解</h3><h4 id="Java的动态代理机制"><a href="#Java的动态代理机制" class="headerlink" title="Java的动态代理机制"></a>Java的动态代理机制</h4><h5 id="Proxy-InvocationHandler"><a href="#Proxy-InvocationHandler" class="headerlink" title="Proxy + InvocationHandler"></a>Proxy + InvocationHandler</h5><blockquote><p>让目标类implemet InvocationHandler<br>再调用的时候，利用Proxy的静态方法newProxyInstance() ，通过反射机制，调用目标类的方法等</p></blockquote><h5 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h5><blockquote><p>生成目标类的一个子类</p></blockquote><h4 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h4><blockquote><p>在理解切面之后，深入到方法本身，如何去插入一个另外写好的类，就是在程序运行时<br>利用动态代理的特点，在调用某个方法的时候，再调用proxy将另一个方法调用进去，<br>Before/After等，所以与其说是切入了方法，不如说是切入到了动态代理的执行过程中</p></blockquote><h2 id="SpringBean"><a href="#SpringBean" class="headerlink" title="SpringBean"></a>SpringBean</h2><h3 id="SpringBean-的作用域"><a href="#SpringBean-的作用域" class="headerlink" title="SpringBean 的作用域"></a>SpringBean 的作用域</h3><blockquote><p>Request :每次HTTP请求都会创建一个新的Bean<br>Session :同一个HTTP Session共享一个Bean，不同Session使用不同Bean<br>singleton : 唯一的bean实例<br>prototype : 每次请求都会创建一个新的bean实例</p></blockquote><blockquote><p>SpringBean没有解决线程安全问题<br>可以用ThreadLocal成员变量</p></blockquote><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/05/java0-1558500658.jpg" alt="Bean生命周期"></p><ol><li>创建调用构造函数</li><li>set方法注入属性</li><li>BeanNameAware</li><li>BeanFactoryAware</li><li>ApplicationContextAware</li><li>BeanPostProcessor的before方法</li><li>initializingBean</li><li>自定义init方法</li><li>BeanPostProcessor的after方法</li><li>使用</li><li>容器的销毁</li><li>DisposableBean的destry</li><li>自定义的销毁方法</li></ol><ul><li><p>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</p></li><li><p>Bean实例化后对将Bean的引入和值注入到Bean的属性中</p></li><li><p>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</p></li><li><p>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</p></li><li><p>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</p></li><li><p>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</p></li><li><p>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</p></li><li><p>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</p></li><li><p>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</p></li><li><p>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</p><h3 id="Bean-和-Component"><a href="#Bean-和-Component" class="headerlink" title="@Bean 和  @Component"></a>@Bean 和  @Component</h3><h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><blockquote><p>修饰方法级  可以用Autowired装配</p></blockquote><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><blockquote><p>用于修饰类级别 可以用@CompontScan装配</p></blockquote></li></ul><h2 id="SpringMVC-工作流程"><a href="#SpringMVC-工作流程" class="headerlink" title="SpringMVC 工作流程"></a>SpringMVC 工作流程</h2><ol><li>client 向 DispatcherServlet 发送请求</li><li>DispatcherServlet根据请求信息调用HandlerMapping ，解析请求到handle</li><li>解析到handle以后开始用HandlerAdapter适配器处理</li><li>HandlerAdapter会根据Haddler调用真正的处理器处理请求和逻辑</li><li>之后返回一个ModelAndView对象</li><li>ViewResolver会把逻辑View查询具体的视图</li><li>DispatcherServlet会把返回的Model给view 或者 Client</li></ol><h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><ol><li>编程式事务：在代码中用</li><li>声明式事务（xml，注解）：在配置文件中用</li></ol><blockquote><p>隔离等问题跟数据库一致</p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;[文章都是搬运艿艿的]&lt;br&gt;[&lt;a href=&quot;http://svip.iocoder.cn/Java/Core/Interview/]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://svip.iocoder.cn/Java/Core/Interview/]&lt;/a&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·jvm篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/11/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-Jvm/"/>
    <id>http://runindark.com/2020/03/11/2020春招/我为阿里-Jvm/</id>
    <published>2020-03-11T07:41:05.384Z</published>
    <updated>2020-06-28T01:43:26.430Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Java的内存区域（运行时数据区）"><a href="#Java的内存区域（运行时数据区）" class="headerlink" title="Java的内存区域（运行时数据区）"></a>Java的内存区域（运行时数据区）</h2><h3 id="线程共享区"><a href="#线程共享区" class="headerlink" title="线程共享区"></a>线程共享区</h3><ol><li>堆</li><li>方法区 （方法区中包含运行时常量池）</li></ol><h3 id="线程私有区"><a href="#线程私有区" class="headerlink" title="线程私有区"></a>线程私有区</h3><ol><li>虚拟机栈</li><li>本地方法栈</li><li>程序计数器<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h3 id="Java1-8之后的变化"><a href="#Java1-8之后的变化" class="headerlink" title="Java1.8之后的变化"></a>Java1.8之后的变化</h3><blockquote><p>线程共享的方法区糅合到了直接内存中的元空间</p></blockquote></li></ol><h2 id="为什么每一个线程需要一个程序计数器"><a href="#为什么每一个线程需要一个程序计数器" class="headerlink" title="为什么每一个线程需要一个程序计数器"></a>为什么每一个线程需要一个程序计数器</h2><h3 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h3><blockquote><p>是一块比较小的线程空间，可以当作字节码指令的指示器，字节码解释器通过程序计数器<br>来控制字节码指令，比如循环，跳转，分支，异常处理等</p></blockquote><h3 id="为啥线程需要程序计数器？"><a href="#为啥线程需要程序计数器？" class="headerlink" title="为啥线程需要程序计数器？"></a>为啥线程需要程序计数器？</h3><blockquote><p>由于线程是不断切换的，所以线程在切换后，如何进行哪一步的继续操作，是需要程序计的<br>同时程序计数器是唯一一个不会出现OutOfMemoryError的内存区域</p></blockquote><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><blockquote><p>虚拟栈其实更通俗的讲也就是线程私有化的方法栈，用于执行线程中Java方法调用的内存模型，每次调用都是通过栈来传递的<br>其实Java内存中可以区分成栈空间，和堆空间，栈空间就是现在的虚拟机栈等，同共享<br>区的方法区一样，栈空间的栈帧依然包含局部变量表（各种基本数据类型和引用）<br>同程序计数器不同的是，虚拟机栈会出现超过栈数目的 StackOutOfFlow 以及超过内存<br>内存空间的OutOfMemoryError</p></blockquote><h3 id="Java的两种返回方式"><a href="#Java的两种返回方式" class="headerlink" title="Java的两种返回方式"></a>Java的两种返回方式</h3><ol><li>return</li><li>异常抛出</li></ol><blockquote><p>方法每一次的调用都会压栈，同时每一次返回都会出栈，上面两个方法的调用都会导致<br>出栈</p></blockquote><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><h2 id="本地方法栈是做什么的？"><a href="#本地方法栈是做什么的？" class="headerlink" title="本地方法栈是做什么的？"></a>本地方法栈是做什么的？</h2><blockquote><p>本地方法栈和虚拟机栈不同，本地方法栈是用来执行Native修饰的方法，但是虚拟机栈<br>是用来执行Java的方法，但是对于HotSpot虚拟机来说，虚拟机栈和本地方法栈合并了<br>所以一样的可以推出，本地方法栈也有自己的栈帧等，栈帧里面也相应的有局部变量表<br>操作数栈，动态链接，出口信息等</p></blockquote><h2 id="堆-（GC堆）"><a href="#堆-（GC堆）" class="headerlink" title="堆 （GC堆）"></a>堆 （GC堆）</h2><blockquote><p>堆是线程共享区的，也是Jvm管理的最大的内存空间，没有之一，几乎所有的对象实例和<br>都在这里分配内存，当然了线程中的类的实例等，都通过reference进行引用<br>由于垃圾大多数也都是由堆产生，因此也被称作为 GC堆</p></blockquote><h2 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h2><blockquote><p>堆中可以粗略的说有 新生代和老年代 ，新生代用完以后可能就不会再引用，所以要更多的被释放掉<br>老年代则趋于稳定，长久的存在或被使用</p></blockquote><p>更加细致的划分</p><blockquote><p>被分为Eden区和From Survivor，To Survivor<br>大部分情况下，首先会再Eden区进行空间分配，在一次垃圾回收后，对象还存活则年龄加一<br>当年龄增加到默认的15岁，则进入到老年代，当然晋升的年龄阈值是可以调节的-XX:MaxTenuringThreshold</p></blockquote><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><blockquote><p>属于线程共享的内存区域，用于存放虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码量，主要是用于存放堆中的逻辑操作等。<br>方法区也就是永久代，永久代不用纠结就是HotSpot规定的一种规范方法区的一种实现</p></blockquote><pre><code class="java">-XX:PermSize=N <span class="comment">//⽅法区(永久代)初始⼤⼩</span>-XX:MaxPermSize=N <span class="comment">//⽅法区(永久代)最⼤⼤⼩,超过这个值将会抛出OutOfMemoryError异</span>常:java.lang.OutOfMemoryError: PermGen</code></pre><blockquote><p>不过到JDK1.8的时候已经被移除了，直接变成了元空间，也就是直接存入内存空间。</p></blockquote><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><blockquote><p>是属于方法区的一部分，Class文件中有类型，方法，接口，版本等信息外，还有一些常量（最特征的就是final修饰的）<br>但是1.7之后这部分又去到了堆中开辟了一片空间，因此</p></blockquote><h3 id="运行时常量池包含什么"><a href="#运行时常量池包含什么" class="headerlink" title="运行时常量池包含什么"></a>运行时常量池包含什么</h3><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><ol><li>文本字符串</li><li>final修饰的</li><li>基本数据类型的值<h4 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h4></li><li>类和结构完全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ol><h2 id="Java对象的创建过程"><a href="#Java对象的创建过程" class="headerlink" title="Java对象的创建过程"></a>Java对象的创建过程</h2><h3 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1. 类加载检查"></a>1. 类加载检查</h3><blockquote><p>从常量池中定位new的符号引用，看看找个类是不是被加载，解析，初始化过。如果没有再执行相应的类加载过程</p></blockquote><h3 id="2-分配内存"><a href="#2-分配内存" class="headerlink" title="2. 分配内存"></a>2. 分配内存</h3><blockquote><p>在堆中直接分配内存，在类加载后会直到该对象需要分配的大小，分配方法有两种（指针碰撞 和 空闲列表），分配方式的选择是由Java堆是否规整决定的</p></blockquote><h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><blockquote><p>就是内存如果工整，那么直接就移动指针分配空间</p></blockquote><h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><blockquote><p>内存不工整，类加载确定出空间后，进行“见缝插针”</p></blockquote><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><h5 id="CAS乐观解决"><a href="#CAS乐观解决" class="headerlink" title="CAS乐观解决"></a>CAS乐观解决</h5><blockquote><p>就是继续利用CAS算法尝试去获取内存空间，直到成功，虚拟机就是这么做的</p></blockquote><h5 id="TLAB解决"><a href="#TLAB解决" class="headerlink" title="TLAB解决"></a>TLAB解决</h5><blockquote><p>在堆中给每个线程分配一丢丢空间，让他自己独有，分配的时候就先分配给TLAB空间，<br>但是这么做的后果就是空间浪费问题</p></blockquote><h3 id="3-初始化零值"><a href="#3-初始化零值" class="headerlink" title="3. 初始化零值"></a>3. 初始化零值</h3><blockquote><p>不包括对象头 ，就是给一一些值赋0或者null</p></blockquote><h3 id="4-设置对象头"><a href="#4-设置对象头" class="headerlink" title="4. 设置对象头"></a>4. 设置对象头</h3><blockquote><p>对象的hash码，分代年龄等，同时个synchronized锁也在对象头</p></blockquote><h3 id="5-执行init（）方法"><a href="#5-执行init（）方法" class="headerlink" title="5. 执行init（）方法"></a>5. 执行init（）方法</h3><blockquote><p>可以理解为Jvm已经创建完成，但是这里才是按照程序员的意愿开始创建，有点感觉是构造方法执行</p></blockquote><h2 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h2><ol><li>句柄</li><li>直接访问</li></ol><blockquote><p>二者的区别在于对于对象实例数据的处理上，句柄是先访问实例苏话剧的指针，在访问实例数据<br>直接指针是直接去Heap中去访问实例数据，不过相应的二者访问类型数据都是先去堆中访问类型数据指针再去方法区去拿到类型数据</p></blockquote><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><blockquote><p>如果是读取的话，看上面过程也就直到，直接指针直接读取会更快一些，但是同样的如果<br>进行删除操作等，需要一个一个的更改数据，效率差，如果是句柄的话直接地址赋null值<br>就可以了，这个赋null值其实和c++的回收是一样的，直接赋null，就证明这一块空间又<br>可以被分配利用了</p></blockquote><h2 id="对象的分配策略"><a href="#对象的分配策略" class="headerlink" title="对象的分配策略"></a>对象的分配策略</h2><blockquote><p>大对象，长期存活对象分配到老年代，但是一般的对象有限分配到Eden区</p></blockquote><h3 id="Minor-GC，-Full-GC的区别"><a href="#Minor-GC，-Full-GC的区别" class="headerlink" title="Minor GC， Full GC的区别"></a>Minor GC， Full GC的区别</h3><blockquote><p>MinorGC也就是新生代的垃圾回收，很频繁，而且速度快<br>FullGC是指老年代的垃圾回收，不是很频繁</p></blockquote><h2 id="对象的死亡判断"><a href="#对象的死亡判断" class="headerlink" title="对象的死亡判断"></a>对象的死亡判断</h2><h3 id="程序计数器法"><a href="#程序计数器法" class="headerlink" title="程序计数器法"></a>程序计数器法</h3><blockquote><p>就是一个对象被引用一次那么计数器加一，如果引用失效那么计数器减一,如果为0，则<br>直接回收</p></blockquote><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><blockquote><p>形象的来说就是以GC Root作为起点，然后查看各个对象到GCRoot是否有一条路劲可以<br>连起来，如果连不起来则直接回收</p></blockquote><h4 id="补充：一般哪些可以作为GCRoot呢："><a href="#补充：一般哪些可以作为GCRoot呢：" class="headerlink" title="补充：一般哪些可以作为GCRoot呢："></a>补充：一般哪些可以作为GCRoot呢：</h4><blockquote><p>通过System Class Loader或者Boot Class Loader加载的class对象，通过自定义类加载器加载的class不一定是GC Root<br>处于激活状态的线程<br>栈中的对象<br>JNI（Java Native Interface）栈中的对象<br>JNI中的全局对象<br>正在被用于同步的各种锁对象<br>JVM自身持有的对象，比如系统类加载器等</p></blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>Java1.2之前定义引用就是reference如果指向的是内存空间的起始地址。</p></blockquote><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><blockquote><p>大多数使用的基本都是强引用，垃圾回收器则不会去回收他，及时空间不足，直接oom，也不会去回收强引用</p></blockquote><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><blockquote><p>区别于强引用，当发生内存不足的时候，才可以被垃圾回收掉。 也正是这样，可以用来<br>处理对内存比较敏感的高速缓存</p></blockquote><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><blockquote><p>区别于软引用，只要垃圾回收器扫描到这部分视作垃圾，那么就直接回收掉<br>可以配合一个引用队列，来查看是是否被GC回收</p></blockquote><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><blockquote><p>虚引用的实际用途不在乎是引用了什么对象，粗略的说可以说成一种 即将被GC回收的标<br>志，也是一种跟踪GC回收的一种方法，虚引用必须配合 引用队列来使用，即在某对象回<br>收之前，则虚引用入队，告诉Jvm该对象即将要被回收，可以在某对象被回收前做一些操作</p></blockquote><h2 id="废弃常量的判定方法"><a href="#废弃常量的判定方法" class="headerlink" title="废弃常量的判定方法"></a>废弃常量的判定方法</h2><blockquote><p>如果是在常量池，而且没用String对象引用，那么就说他是废弃常量，如果内存回收需要的话，直接清理出去</p></blockquote><h2 id="如何判定一个类的废弃"><a href="#如何判定一个类的废弃" class="headerlink" title="如何判定一个类的废弃"></a>如何判定一个类的废弃</h2><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><blockquote><p>ClassLoader是一个类加载器，它的工作是将一个类的全限名在Jvm外部进行转化成一个<br>二进制流,转成二进制流是为了Jvm读取，但是是在虚拟机外部就转化成，这样的目的是<br>让应用程序自己可以选择这个类，这也是为啥在对象回收时，Jvm Rooter可以是<br>Classroader的原因</p></blockquote><h3 id="java-lang-Class"><a href="#java-lang-Class" class="headerlink" title="java.lang.Class"></a>java.lang.Class</h3><blockquote><p>反射机制的核心，也就就是所有类自身的一个独有的镜子，在一个类被编译成.class文件的时候，在jvm中运行，会同时自动生成一个和自己创建的类想匹配的Class类</p></blockquote><h3 id="一个类废弃的判定方法"><a href="#一个类废弃的判定方法" class="headerlink" title="一个类废弃的判定方法"></a>一个类废弃的判定方法</h3><ol><li>所有的实例已经被回收掉，堆中不再有这个类的实例</li><li>该类的Classloader也已经被回收</li><li>该类对应的java.lang.class文件没有在任何地方被引用，也无法在任何地方通过反射机制来访问该类</li></ol><h2 id="垃圾回收机制的算法"><a href="#垃圾回收机制的算法" class="headerlink" title="垃圾回收机制的算法"></a>垃圾回收机制的算法</h2><h3 id="无脑清空法-–-标记清除算法"><a href="#无脑清空法-–-标记清除算法" class="headerlink" title="无脑清空法 – 标记清除算法"></a>无脑清空法 – 标记清除算法</h3><blockquote><p>标记需要回收的对象，然后标记完后，通过一轮回收直接把标记的位置回收</p><ol><li>效率差</li><li>清理完空间不连续</li></ol></blockquote><h3 id="复制填坑法-–-复制算法"><a href="#复制填坑法-–-复制算法" class="headerlink" title="复制填坑法 – 复制算法"></a>复制填坑法 – 复制算法</h3><blockquote><p>将内存空间分成两份，然后将不需要回收的内存（活着的对象）复制到另一块空间去，保证整洁</p><ol><li>需要两份一样的空间</li><li>复制的时候消耗太大</li></ol></blockquote><h3 id="洁癖整理法-–-标记整理算法"><a href="#洁癖整理法-–-标记整理算法" class="headerlink" title="洁癖整理法 – 标记整理算法"></a>洁癖整理法 – 标记整理算法</h3><blockquote><p>也是先标记，但是不同的是，标记以后直接向某一端直接移动，然后GC直接回收边界的无用的空间</p></blockquote><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><blockquote><p>分配空间的空间按照新生代和老年代区别，新生代可以用复制算法，老年代的内存大，而且多，可以使用 标记整理算法，也可以酌情标记清空算法</p></blockquote><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial-（年轻代）"><a href="#Serial-（年轻代）" class="headerlink" title="Serial （年轻代）"></a>Serial （年轻代）</h3><ol><li>单线程收集器</li><li>当进行单线程回收垃圾的时候，其它线程必须停止</li><li>但是对一个客户端的还不错，毕竟切换没那么复杂，而且单线程自然可以调用的资源更多<h3 id="ParNew-（年轻代）"><a href="#ParNew-（年轻代）" class="headerlink" title="ParNew （年轻代）"></a>ParNew （年轻代）</h3><blockquote><p>上述Serial的一个升级，其实就是升级成了多线程</p></blockquote></li><li>多线程收集</li><li>stop the world ，还是要停止所有的线程工作<h3 id="Parallel-Scavenge-（年轻代）"><a href="#Parallel-Scavenge-（年轻代）" class="headerlink" title="Parallel Scavenge （年轻代）"></a>Parallel Scavenge （年轻代）</h3><blockquote><p>为了吞吐量而减少收集时间，提高收集次数的一种收集算法，（吞吐量：程序运行时间/CPU使用时长）<br>适合执行批量处理、订单处理</p></blockquote><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3></li></ol><h3 id="CMS-（老年代）"><a href="#CMS-（老年代）" class="headerlink" title="CMS （老年代）"></a>CMS （老年代）</h3><blockquote><p>HotSpot的第一款真正意义上的并发垃圾回收机制，是用的标记清除算法</p></blockquote><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><h5 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h5><blockquote><p>暂停掉所有的线程，标记一下与GC root相连的对象（可达性分析里面的那个GC Root）</p></blockquote><h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h5><blockquote><p>继续类似可达性分析，标记一系列可达的的队形 GC Root Trancing</p></blockquote><h5 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h5><blockquote><p>并发标记是并发的，重新标记是为了修正重新标记期间的用户变动</p></blockquote><h5 id="并发清除"><a href="#并发清除" class="headerlink" title="并发清除"></a>并发清除</h5><blockquote><p>开始对标记的区域做清理</p></blockquote><ol><li>对CPU资源敏感</li><li>无法清理浮动垃圾<br>3 标记清除算法有太多的空间碎片<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><blockquote><p>面向服务器的垃圾回收器，针对配备多核处理起的cpu<br>宏观上是复制，微观上有标记整理算法<br>不区分内存块 Eden surviovor old在微观上还是被保留的</p></blockquote><h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><h5 id="初始标记-1"><a href="#初始标记-1" class="headerlink" title="初始标记"></a>初始标记</h5><h5 id="并发标记-1"><a href="#并发标记-1" class="headerlink" title="并发标记"></a>并发标记</h5><h5 id="最终标记"><a href="#最终标记" class="headerlink" title="最终标记"></a>最终标记</h5><h5 id="筛选回收"><a href="#筛选回收" class="headerlink" title="筛选回收"></a>筛选回收</h5></li></ol><blockquote><p>过程其实大同小异，相比于CMS其实更多的在于标记的时候多了Remember Set，到了最终标记还有Remeber Set Log合并到了Remeber Set因此避免了浮动垃圾问题<br>Region在宏观是其实是复制原则，但是在Region的内部其实是标记整理算法<br>Region内部除了Eden s0 s1 old 还有超大对象，面对超大对象，会选择移动老年代的<br>对象来为超大内存的对象提供内存</p></blockquote><h2 id="Jvm类加载模式"><a href="#Jvm类加载模式" class="headerlink" title="Jvm类加载模式"></a>Jvm类加载模式</h2><ol><li>加载<blockquote><p>这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口</p></blockquote></li><li>验证<blockquote><p>了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求</p></blockquote></li><li>准备<blockquote><p>是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。</p></blockquote></li><li>解析<blockquote><p>虚拟机将常量池中的符号引用替换为直接引用的过程</p></blockquote></li><li>初始化<blockquote><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。</p></blockquote></li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ol><li>启动类加载器<blockquote><p>负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被<br>虚拟机认可（按文件名识别，如 rt.jar）的类</p></blockquote></li><li>扩展类加载器<blockquote><p>负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类<br>库</p></blockquote></li><li><p>应用程序类加载器</p><blockquote><p>负责加载用户路径（classpath）上的类库<br>利用双亲委派模型进行类的加载，通过继承java.lang.classloader实现自定义类加载器</p></blockquote><pre><code>                启动类加载器（Bootstrap ClassLoader）                                /\                                ||                扩展类加载器 （Extension ClassLoader）                                /\                                ||                应用程序类加载器 （Application ClassLoader）                        /\                  /\                        ||                  ||自定义加载器（User ClassLoader）    自定义加载器（UserClassLoader）</code></pre></li></ol><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><blockquote><p>当一个类收到类加载的请求，他首先不会尝试自己去加载这个类，而是把请求委托给父类去完成，每一层的类加载器都是如此（如上图，箭头向上），因此最终所有的加载类都应该送到启动类加载器去完成，只有当父类的加载器返回自己无法加载这个请求的时候，子类加载器才会自己尝试去加载。<br>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载<br>器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载<br>器最终得到的都是同样一个 Object 对象</p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·mysql篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/10/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-mysql/"/>
    <id>http://runindark.com/2020/03/10/2020春招/我为阿里-mysql/</id>
    <published>2020-03-10T03:03:04.084Z</published>
    <updated>2020-06-28T01:43:26.639Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Mysql事务的特性-ACID"><a href="#Mysql事务的特性-ACID" class="headerlink" title="Mysql事务的特性 - ACID"></a>Mysql事务的特性 - ACID</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><blockquote><p>和线程是一样的，意思就是要么成功，要么失败 =》 事务要么执行成功，要么执行失败</p></blockquote><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><blockquote><p>从一个一致性到另一个一致性是传递的，就是一个业务流程，一个环节不是一致性，下一个环节就会失败</p></blockquote><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><blockquote><p>数据库事务和事务之间是隔离的，也就是说事务A看不到事务B，相应的事务B也不晓得事务A干啥</p></blockquote><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><blockquote><p>也就是说，只要事务存入数据库的就是永久存在的，哪怕数据库出异常了，数据也还在</p></blockquote><h2 id="Mysql事务的出现的问题"><a href="#Mysql事务的出现的问题" class="headerlink" title="Mysql事务的出现的问题"></a>Mysql事务的出现的问题</h2><h3 id="事务会发生的意外"><a href="#事务会发生的意外" class="headerlink" title="事务会发生的意外"></a>事务会发生的意外</h3><h4 id="脏读（Select-没有规矩）"><a href="#脏读（Select-没有规矩）" class="headerlink" title="脏读（Select 没有规矩）"></a>脏读（Select 没有规矩）</h4><blockquote><p>事务A插入了一个数据，但是人家事务A没有提交。结果事务B他没有规矩，他查了一下表，结果发现了事务A插入的数据。这就是脏读</p></blockquote><h4 id="不可重复读（Update-没有规矩）"><a href="#不可重复读（Update-没有规矩）" class="headerlink" title="不可重复读（Update 没有规矩）"></a>不可重复读（Update 没有规矩）</h4><blockquote><p>事务A查询一条数据是A，但是事务b他没有规矩，他更新了数据A变成了B，当事务A再查这条数据的时候，发现变成了B，这就是不可重复读</p></blockquote><h4 id="幻读-（Insert-Delete-没有规矩）"><a href="#幻读-（Insert-Delete-没有规矩）" class="headerlink" title="幻读 （Insert Delete 没有规矩）"></a>幻读 （Insert Delete 没有规矩）</h4><blockquote><p>事务A差某表，查出A条数据，事务B这时候删了几条数据，事务A此刻又去读了一下，发现数据少了，这就是不可重复读。</p></blockquote><h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><h4 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h4><blockquote><p>事务之间可以读取到事务未提交的数据 （完美的符合了上面出现的所有问题）</p></blockquote><h4 id="提交读"><a href="#提交读" class="headerlink" title="提交读"></a>提交读</h4><blockquote><p>顾名思义就是可以读取到已经提交的数据，引申一下，里面涉及到的一种“快照读”，也就是读历史确定的版本</p></blockquote><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><blockquote><p>也就是悲观锁读，当前的一个事务如果读取到该数据，那么给当前读取上锁，其它事务将无法再获取该数据，但是这个并不能限制事务继续插入数据，所以就会<br>引起幻读</p></blockquote><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><blockquote><p>顾名思义就是一个一个慢慢来，一次只能来一个，活该这么慢</p></blockquote><h2 id="Mysql的存储引擎"><a href="#Mysql的存储引擎" class="headerlink" title="Mysql的存储引擎"></a>Mysql的存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><blockquote><p>Mysql所默认的一种存储引擎，满足ACID的事务要求，他使用了“一次性非锁定性读”（也就是给数据读取等添加版本，这个里面有些和上述的快照读概念差不<br>多）</p></blockquote><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><blockquote><p>依靠逗号来分割数据的一种存储方式</p></blockquote><h4 id="InnoDB的一些优点缺点"><a href="#InnoDB的一些优点缺点" class="headerlink" title="InnoDB的一些优点缺点"></a>InnoDB的一些优点缺点</h4><ol><li>行锁粒度，粒度更小，更适合并发场景</li><li>支持事务，有外键</li><li>缺点： 缺点也很明显不支持全文搜索，可以用es搜索</li></ol><h2 id="Mysql数据库索引"><a href="#Mysql数据库索引" class="headerlink" title="Mysql数据库索引"></a>Mysql数据库索引</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><blockquote><p>可以理解成一种排序后的数据结构，通过节点存储索引，之后在查到找相应的结果，通过数据结构加速，比如用二叉树，那么就可以通过节点左右比较减少<br>遍历查找的次数，当然了如果1 2 3 4 5 6 就会变成链表，如果是红黑树则解决了这个问题，但是会导致深度过深，因此使用B+树，降低深度，添加广度</p></blockquote><h3 id="常用的功能索引"><a href="#常用的功能索引" class="headerlink" title="常用的功能索引"></a>常用的功能索引</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><blockquote><p>就是最基本的添加一个索引，用于加速查找</p></blockquote><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><blockquote><p>列值必须唯一，可以为空值，加速查找</p></blockquote><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><blockquote><p>利用主键作为索引，而且不可以为空，加速查找</p></blockquote><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><blockquote><p>就是查查找的数据也是索引值</p></blockquote><h4 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4><blockquote><p>几列合并成一个索引，但是遵循最左原则</p></blockquote><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><blockquote><p>全文分词查找，innoDB是做不到的，需要第三方，比如es等</p></blockquote><h3 id="使用索引存在的问题"><a href="#使用索引存在的问题" class="headerlink" title="使用索引存在的问题"></a>使用索引存在的问题</h3><blockquote><p>使用索引的时候不可以随便使用，过度的使用索引会导致消耗大量的资源，热点核心业务的数据应该多使用索引<br>索引会浪费磁盘空间，不要创建非必要的索引,插入、更新、删除需要维护索引，带来额外的开销,索引过多，修改表的时候重构索引性能差<br>但是索引使用的时候可以减少查询次数，提高效率</p></blockquote><h2 id="Sql-的查询顺序"><a href="#Sql-的查询顺序" class="headerlink" title="Sql 的查询顺序"></a>Sql 的查询顺序</h2><ol><li>from 从哪个表查询</li><li>where 初步过滤条件</li><li>group by 过滤后进行分组[重点]</li><li>having 对分组后的数据进行二次过滤[重点]</li><li>select 查看哪些结果字段</li><li>order by 按照怎样的顺序进行排序返回[重点]</li></ol></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
