<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cat&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://runindark.com/"/>
  <updated>2020-07-26T09:32:55.712Z</updated>
  <id>http://runindark.com/</id>
  
  <author>
    <name>夜小猫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://runindark.com/2020/07/26/2020%E7%A7%8B%E6%8B%9B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://runindark.com/2020/07/26/2020秋招/操作系统/</id>
    <published>2020-07-26T09:32:55.712Z</published>
    <updated>2020-07-26T09:32:55.712Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://runindark.com/2020/07/21/2020%E7%A7%8B%E6%8B%9B/%E6%88%90%E5%93%A5%E7%9A%84redis/"/>
    <id>http://runindark.com/2020/07/21/2020秋招/成哥的redis/</id>
    <published>2020-07-21T07:21:24.857Z</published>
    <updated>2020-07-21T07:21:29.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a><strong>redis</strong></h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><pre><code>Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，内部为当前字 符串实际分配的空间 capacity 一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，为了避免加倍后的冗余空间过大而导致浪费，所以扩容时一次只会多扩1M的空间。需要注意的是 字符串最大长度为 512M。</code></pre><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><pre><code>Redis的列表相当于Java语言里面的LinkedList，注意它是链表而不是数组。这意味着list的插入和删除操作非常快，时间复杂度为O(1)，但是索引定位很慢，时间复杂度为 O(n）。当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进Redis 的列表，另一个线程从这个列表中轮询数据进行处理。Redis底层存储的还不是一个简单的linkedlist，而是称之为快速链表quicklist的一个结构。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如当列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。所以Redis将双端链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</code></pre><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><pre><code>Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞 时，就会将碰撞的元素使用链表串接起来。不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。渐进式 rehash ，会在rehash的同时，创建一个索引计数器并把它设置为0，保留新旧两个hash结构，查、删、改的时候会同时查询两个hash结构，增加的话只会增加到新的hash结构中，这样也是为了去保证旧的hash结构只减不增。然后在后续的定时任务中以及hash的子指令中，循序渐进地将旧 hash 的内容 一点点迁移到新的 hash 结构中，每次rehash完成后都会将计数器+1。当 hash 移除了最后一个元素之后，计数器设置为-1，该数据结构自动被删除，内存被回收。</code></pre><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><pre><code>Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的 内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。 set结构可以用来存储活动中奖的用户ID，因为有去重功能，可以保证同一个用户不会中奖两次。</code></pre><h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><pre><code>Redis的有序集合它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个score，代表这个value的排序权重。它的内部实现用的是一种叫着「跳跃列表」的数据结构。zset中最后一个value被移除后，数据结构自动删除，内存被回收。</code></pre><h4 id="通用规则"><a href="#通用规则" class="headerlink" title="通用规则"></a>通用规则</h4><pre><code>list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则:    1、create if not exists    2、drop if no elements</code></pre><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="sds"><a href="#sds" class="headerlink" title="sds"></a>sds</h4><pre><code>Redis 的字符串叫 sds，也就是 Simple Dynamic String。它的结构是一个带长度信息的字节数组。    struct SDS&lt;T&gt; {        T capacity; // 数组容量        T len; // 数组长度        byte flags; // 特殊标识位，不理睬它         byte[] content; // 数组内容    }content里面存储了真正的字符串的内容，capacity是分配的数组长度，len是字符串实际的长度Redis 的字符串有两种存储方式，在长度特别短时，使用 emb 形式存储 (embeded)，当 长度超过 44 时，使用 raw 形式存储。embstr 存储形式是这样一种存储形式，它将 RedisObject对象头和SDS对象连续存在一起，使用malloc方法一次分配。而raw存储形式不一样，它需要两次malloc，两个对象头在内存地址上一般是不连续的。而内存分配器 jemalloc/tcmalloc 等分配内存大小的单位都是 2、4、8、16、32、64 等 等，为了能容纳一个完整的 embstr 对象，jemalloc 最少会分配 32 字节的空间，如果字符 串再稍微长一点，那就是 64 字节的空间。如果总体超出了 64 字节，Redis 认为它是一个 大字符串，不再使用 emdstr 形式存储，而该用 raw 形式。44=64-16-3-1       64字节是规定embeded最大的占用内存，16是redis对象头的长度，3是sds头的长度，1是最后的&apos;\0&apos;。</code></pre><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><pre><code>dict 是 Redis 服务器中出现最为频繁的复合型数据结构，除了 hash 结构的数据会用到字典外，整个 Redis 数据库的所有 key 和 value 也组成了一个全局字典，还有带过期时间的 key 集合也是一个字典。zset 集合中存储 value 和 score 值的映射关系也是通过 dict 结构实现的。dict 结构内部包含两个 hashtable，通常情况下只有一个 hashtable 是有值的。但是在dict 扩容缩容时，需要分配新的 hashtable，然后进行渐进式搬迁，这时候两个 hashtable 存储的分别是旧的 hashtable 和新的 hashtable。待搬迁结束后，旧的 hashtable 被删除，新的hashtable 取而代之。hashtable 的结构和 Java 的HashMap 几乎是一样的，都是通过分桶的方式解决 hash 冲突。第一维是数组，第二维是链表。数组中存储的是第二维链表的第一个元素的指针。扩容    正常情况下，当 hash 表中元素的个数等于第一维数组的长度时，就会开始扩容，扩容 的新数组是原数组大小的 2 倍。但是当 Redis 正在做 bgsave，为了减少内存页的过多分离 (Copy On Write)，Redis 尽量不去扩容 (dict_can_resize)，但是如果 hash 表已经非常满 了，元素的个数已经达到了一维数组长度的 5 倍 (dict_force_resize_ratio)，说明 hash 表 已经过于拥挤了，这个时候就会强制扩容。缩容    当 hash 表因为元素的逐渐删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少。hash 表的第一维数组空间占用。缩容的条件是元素个数低于数组长度的 10%。缩容不会考 虑 Redis 是否正在做 bgsave。</code></pre><h4 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h4><pre><code>Redis 为了节约内存空间使用，zset和hash容器对象在元素个数较少的时候，采用压缩列表进行存储。压缩列表是一块连续的内存空间，元素之间紧挨着存储，没有任何冗余空隙。因为 ziplist 都是紧凑存储，没有冗余空间 。意味着插入一个新的元素就需要调用 realloc 扩展内存。取决于内存分配器算法和当前的 ziplist 内存 大小，realloc 可能会重新分配新的内存空间，并将之前的内容一次性拷贝到新的地址，也可能在原有的地址上进行扩展，这时就不需要进行旧内容的内存拷贝。如果 ziplist 占据内存太大，重新分配内存和拷贝内存就会有很大的消耗。所以 ziplist 不适合存储大型字符串，存储的元素也不宜过多。</code></pre><h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h4><pre><code>在Redis早期的时候存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表linkedlist，也就是元素少时用 ziplist，元素多时用 linkedlist。但是链表的附加成本相对比较高，prev与next指针就需要16字节，而且每个节点的内存都是单独分配，会让内存产生碎片化，从而影响内存管理的效率，在后面就加入了quicklist。它相当于ziplist与linkedlist的结合体，将linkedlist按段划分，然后每一段用ziplist紧凑存储，多个ziplist采用双向指针连接而且ziplist是可以深度压缩quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数 list- compress-depth决定。为了支持快速的 push/pop 操作，quicklist 的首尾两个 ziplist 不压 缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二 个 ziplist 都不压缩。</code></pre><h4 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h4><pre><code>Redis 的 zset 是一个复合结构，一方面它需要一个 hash 结构来存储 value 和 score 的 对应关系，另一方面需要提供按照 score 来排序的功能，还需要能够指定 score 的范围来获 取 value 列表的功能，这就需要另外一个结构跳跃列表。Redis 的跳跃表共有 64 层，意味着最多可以容纳 2^64 次方个元素。每一个 kv 块对应的结构如下面的代码中的 zslnode 结构，kvheader 也是这个结构，只不过 value 字段是 null 值——无效的，score 是Double.MIN_VALUE，用来垫底的。kv 之间使用指针串起来形成了双向链表结构，它们是有序 排列的，从小到大。不同的 kv 层高可能不一样，层数越高的 kv 越少。同一层的 kv会使用指针串起来。每一个层元素的遍历都是从 kv header 出发。struct zslnode {    string value;    double score;     zslnode*[] forwards; //多层连接指针    zslnode* backward; //回溯指针}    struct zsl {    zslnode* header; //跳跃列表头指针    int maxLevel; //跳跃列表当前的最高层    map&lt;string, zslnode*&gt; ht; // hash 结构的所有键值对}查找：我们要定位到那个某个kv，需要从header的最高层开始遍历找到第一个节点（最后一个比「我」小的元素），然后从这个节点开始降一层再遍历找到第二个节点 (最 后一个比「我」小的元素)，然后一直降到最底层进行遍历就找到了期望的节点 (最底层的最 后一个比我「小」的元素)。我们将中间经过的一系列节点称之为「搜索路径」，它是从最高层一直到最底层的每一层最后一个比「我」小的元素节点列表。有了这个搜索路径，我们就可以插入这个新节点了。不过这个插入过程也不是特别简单。因为新插入的节点到底有多少层，得有个算法来分配一下，跳跃列表使用的是随机算法。插入：对于每一个新插入的节点，都需要调用一个随机算法给它分配一个合理的层数。直观上期望的目标是 50% 的 Level1，25% 的 Level2，12.5% 的 Level3，一直到最顶层 2^-63，因为这里每一层的晋升概率是 50%。首先我们在搜索合适插入点的过程中将「搜索路径」摸出来了，然后就可以开始创建新节点了，创建的时候需要给这个节点随机分配一个层数，再将搜索路径上的节点和这个新节点通过前向后向指针串起来。如果分配的新节点的高度高于当前跳跃列表的最大高度，就需要更新一下跳跃列表的最大高度。删除：删除过程和插入过程类似，都需先把这个「搜索路径」找出来。然后对于每个层的相关 节点都重排一下前向后向指针就可以了。同时还要注意更新一下最高层数 maxLevel。更新：当我们调用 zadd 方法时，如果对应的 value 不存在，那就是插入过程。如果这个value 已经存在了，只是调整一下 score的值，那就需要走一个更新的流程。假设这个新的score值不会带来排序位置上的改变，那么就不需要调整位置，直接修改元素的score值就可以了。但是如果排序位置改变了，那就要调整位置。一个简单的策略就是先删除这个元素，再插入这个元素，需要经过两次路径搜索。Redis就是这么干的。 不过 Redis 遇到 score 值改变了就直接删除再插入，不会去判断位置是否需要调整    如果 score 值都一样呢?        在一个极端的情况下，zset 中所有的 score 值都是一样的，zset 的查找性能会退化为 O(n) 么?Redis 作者自然考虑到了这一点，所以 zset 的排序元素不只看 score 值，如果 score 值相同还需要再比较 value 值 (字符串比较)。</code></pre><h4 id="Rax"><a href="#Rax" class="headerlink" title="Rax"></a>Rax</h4><pre><code>Rax 是 Redis 内部比较特殊的一个数据结构，它是一个有序字典树 (基数树 Radix Tree)，按照 key 的字典序排列，支持快速地定位、插入和删除操作。Redis 五大基础数据结 构里面，能作为字典使用的有 hash 和 zset。hash 不具备排序功能，zset 则是按照 score 进 行排序的。rax 跟 zset 的不同在于它是按照 key 进行排序的。你也可以将公安局的人员档案信息看成一棵radixtree，它的key是每个人的身份证号，value是这个人的履历。因为身份证号的编码的前缀是按照地区进行一级一级划分的， 这点和单词非常类似。有了这棵树，你就可以快速地定位出人员档案，还可以快速查询出某个小片区都有哪些人。Rax被用在RedisStream结构里面用于存储消息队列，在Stream里面消息ID的前缀是时间戳+序号，这样的消息可以理解为时间序列消息。使用Rax结构进行存储就可以快 速地根据消息 ID 定位到具体的消息，然后继续遍历指定消息之后的所有消息。Rax 是一棵比较特殊的radixtree，它在结构上不是标准的radixtree。如果一个中间节点有多个子节点，那么路由键就只是一个字符。如果只有一个子节点，那么路由键就是一个字 符串。后者就是所谓的「压缩」形式，多个字符压在一起的字符串。</code></pre><h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><pre><code>概念    redis的数据结构之一，是一个byte数组，会自动扩容，当偏移量超过现有的内容范围，就会自动将数组进行零扩充()。如果要存hello的话，就需要将这个字符串的ASCII码找到，然后再不停地去存。位数组的存储字符的的位顺序是相反的。setbit s 1 1  setbit s 2 1  setbit s 5 1 后面的1就是为1，前面的数字是第几位，如果需要获取的话就只需要 get s 就可以了特性    零存整取、零存零取、整存零取。零存：就是用setbit挨个设置，整存就是使用字符串去填充所有的位数组，零取就是获取这个对象的第n位是0/1,整取就是获取这个对象的整体。    节省空间：因为是位图，每次存储0或者1，在一些特定情况下可以减少很多存储空间    为布隆过滤器打基础。</code></pre><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><pre><code>HyperLogLog 提供不精确的去重计数方案，虽然不精确但是也不是非常不精确，标准误差是 0.81%，这样就适用于一些知道大概的形式，而不需要具体的数据的场景。提供了两个指令 pfadd 和 pfcount，根据字面意义很好理解，一个是增加 计数，一个是获取计数。pfadd 用法和 set 集合的 sadd 是一样的，来一个用户 ID，就将用 户 ID 塞进去就是。pfcount 和 scard 用法是一样的，直接获取计数值。HyperLogLog 除了前面说的 pfadd 和 pfcount 之外，还提供了第三个指令 pfmerge，用于 将多个 pf 计数值累加在一起形成一个新的 pf 值。HyperLogLog 这个数据结构不是免费的，不是说使用这个数据结构要花钱，它需要占据一定12k 的存储空间，所以它不适合存储单个用户的信息，适合存储上千万上亿的用户信息。它的存储空间采用稀疏矩阵存储，空间占用很小，仅仅在计数慢慢变大，稀疏矩阵占 用空间渐渐超过了阈值时才会一次性转变成稠密矩阵，才会占用 12k 的空间。</code></pre><h3 id="布隆过滤器："><a href="#布隆过滤器：" class="headerlink" title="布隆过滤器："></a>布隆过滤器：</h3><pre><code>在Redis4之后出现的插件，为RedisServer服务。如果需要自定义参数的布隆过滤器，就得要在bf.add之前显示调用bf.reserve，它有三个参数key, error_rate 和 initial_size。错误率越低，需要的空间越大。initial_size 参数表示预计放 入的元素数量，当实际数量超出这个数值时，误判率会上升。所以需要提前设置一个较大的数值避免超出导致误判率升高。如果不使用 bf.reserve，默 认的 error_rate 是 0.01，默认的 initial_size 是 100。布隆过滤器的 initial_size 估计的过大，会浪费存储空间，估计的过小，就会影响准确 率，用户在使用之前一定要尽可能地精确估计好元素数量，还需要加上一定的冗余空间以避 免实际元素可能会意外高出估计值很多。布隆过滤器的 error_rate 越小，需要的存储空间就越大，对于不需要过于精确的场合， error_rate 设置稍大一点也无伤大雅。比如在新闻去重上而言，误判率高一点只会让小部分文 章不能让合适的人看到，文章的整体阅读量不会因为这点误判率就带来巨大的改变。当我们在往里面插入key的时候，尽量不要让实际元素数&gt;初始化的数，如果超过了初始化的数，就得要对这个布隆过滤器进行重载，然后分配一个更大的内存。</code></pre><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><pre><code>其实就是多个hash函数，当我们向布隆过滤器添加一个元素的时候，会用多个hash函数对key算出一个整数的索引，然后再将相应的位置变为1，每一个hash函数会算出不同的位置。所以当我们在判断一个key在不在的时候，就会通过对这个key多个hash时的索引，看这几个索引在的位置是不是都为1，如果都为1就说明存在，如果没有1说明不存在。所以对布隆过滤器而言是有一定的误差的，但是当我们在判断某个元素不存在的时候，这个key肯定不存在，但是在判断存在的时候，就有可能出现问题，因为可能会有其他key的hash函数将这个位置变为1，虽然概率比较小，但是还是存在这种情况下的。所以在判断存在的时候就只是极可能存在而不是一定存在错误率计算公式：    k=0.7*(l/n) # 约等于    f=0.6185^(l/n) </code></pre><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><pre><code>1、位数组相对越长 (l/n)，错误率 f 越低，这个和直观上理解是一致的 2、位数组相对越长 (l/n)，hash 函数需要的最佳数量也越多，影响计算效率3、当一个元素平均需要 1 个字节 (8bit) 的指纹空间时 (l/n=8)，错误率大约为 2%4、错误率为 10%，一个元素需要的平均指纹空间为 4.792 个 bit，大约为 5bit5、错误率为 1%，一个元素需要的平均指纹空间为 9.585 个 bit，大约为 10bit6、错误率为 0.1%，一个元素需要的平均指纹空间为 14.377 个 bit，大约为 15bit</code></pre><h4 id="用处："><a href="#用处：" class="headerlink" title="用处："></a>用处：</h4><pre><code>布隆过滤器可以显著降低数据库的 IO 请求数量。当用户来查询某个 row 时，可以先通过内存中的布隆过滤器过滤掉大量不存在的 row 请求，然后再去磁盘进行查询。在爬虫的时候，我们就得需要对URL进行去重，已经爬过的页面那就不需要再爬了，如果用set去装的话就会非常浪费空间，如果使用布隆过滤器的话可以大幅降低去重存储消耗，只不过也会使得爬虫系统 错过少量的页面。邮箱系统的垃圾邮件过滤功能也普遍用到了布隆过滤器，因为用了这个过滤器，所以平时也会遇到某些正常的邮件被放进了垃圾邮件目录中，这个就是误判所致，概率很低。</code></pre><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="rdb"><a href="#rdb" class="headerlink" title="rdb"></a>rdb</h4><pre><code>RDB其实也就是我们常说的快照，备份的是全量数据，以二进制文件的形式存放在内存中，存储的非常紧凑。因为redis是一个单线程的程序，这个线程同时负责多个客户端的并发读写操作和内存结构的逻辑读写，在快照过程中，Redis必须进行文件IO操作，但是文件IO操作不能用多路复用，所以就会导致文件IO操作会大幅度的拖累服务器的性能。所以，redis采用的是COW机制来作为快照持久化。在持久化的过程中，并不是这个主线程去进行持久化操作而是先fork出一个子进程，这个子进程才是处理快照操作的进程，主进程还是继续接收客户端的请求。这个时候子进程在做持久化操作，所以不会修改内存结构，但是主进程还在接收客户端的请求，这时候肯定会去修改内存结构。所以就有了COW的用武之处，COW会将某一个瞬间的数据快照，生成某个时间点的数据快照，然后去操作这个快照。</code></pre><h4 id="aof"><a href="#aof" class="headerlink" title="aof"></a>aof</h4><pre><code>连续的增量备份，与MySQL的binlog比较类似。AOF记录的是数据修改的指令记录文本，随着时间的增长，这个文本会变得越来越大。为此，redis有了AOF重写的功能，将一些没有用的命令给删掉，只保留最后一次有效修改的命令，bgrewriteaof命令。重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常 使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实 例很大的情况下，启动需要花费很长的时间。Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。将 rdb 文 件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自 持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可 以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到 升。</code></pre><p>####优缺点<br>    RDB存在哪些优势呢？</p><pre><code>    1). 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。    2). 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。    3). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。    4). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。RDB又存在哪些劣势呢？    1). 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。    2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。AOF的优势有哪些呢？    1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。    2). 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题    3). 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。    4). AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。AOF的劣势有哪些呢？    1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。    2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。    </code></pre><h3 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h3><pre><code>我们可以用redis的setnx去实现一个分布式锁，如果仅仅用setnx的话是有很大的问题的。如果一个线程获取了这个锁之后，在执行过程中还没来得及del的时候，程序出现了异常，就会陷入到一种死锁状态。为了防止这种情况的出现，可以加一个expire，这样有了过期时间后，就会减少一部分问题。但是还会有一些问题，就比如说setnx之后expir之前的这个时间段出现异常也会导致死锁状态。所以为了防止这种情况出现，可以把nx与ex同时作为set的参数，这样就可以达到一种原子性的状态。不支持可重入锁，所以如果分布式要使用可重入的话就得在逻辑层上修改，redis并不支持。所以，我们应该避免用redis的setnx做可重入锁的逻辑。</code></pre><h3 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h3><pre><code>当我们需要从海量的key中获取其中具有某些特性的key时，很多人第一个想法就是keys,举个栗子，我想要获取前缀是common的key时，很多人就会选择用这条命令去寻找符合自己预期的key。 ‘keys common*’ 但是，在我们的key非常多的时候，或者符合条件的key太多的时候，你就知道这个命令会造成多大的破坏。因为keys命令是遍历所有的key，所以说它的时间复杂度是O(n),如果我们的数据集非常大，就会导致redis服务卡顿，所有redis的读写命令都会被延后甚至超时，因为redis是单线程的程序，它需要顺序的去执行所有指令，当keys命令这里不停地运行，就会导致其他命令发生阻塞，必须等待keys命令执行完才可以执行。为了解决这种问题，redis引入了scan命令。scan命令拥有很多优点：    1、通过游标分步进行，不会阻塞线程    2、提供limit参数，可以控制返回条数，不像keys会返回所有的条数当然也会有比较多的缺点：    1、返回的结果可能有重复，需要客户端去重    2、遍历的过程中如果修改了数据，不能保证这个数据会被便利到    3、单次返回的结果是null，并不意味着遍历结束了，应该看游标的返回值。因为limit并不是说返回的结果条数，而是一次遍历的槽值，</code></pre><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><pre><code>redis中所有的数据结构都可以设置过期时间，时间一到就会自动删除。但是呢，redis是一种单线程的NOSQL型数据库，当我们在删除过期key的时候也会占用进程处理的时间，如果删除的过于繁忙可能会导致线上的指令出现卡顿，为了解决这个问题，redis将所有的设置了过期时间的key存放在一个字典中，然后通过两种方式来删除过期的key。定时集中删除：定时遍历这个字典，然后删除到期的key。默认10次/s，但是不会扫描所有的过期字典中的key，而是先在所有的key中随机挑选出20个key，删除这20个key中过期的key。如果删除的过期key比率超过1/4就继续开始的步骤，然后多次循环之后，当过期key变得比较稀散了才会停止。零散惰性删除：在client访问这个key的时候先看这个key有没有过期，如果过期了就删除。</code></pre><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><pre><code>redis是一款非常强大的基于内存的NOSQL型数据库，但是呢，当redis的内存超过了物理机的内存之后，内存的数据就会有磁盘产生频繁的交换，交换会让redis的性能急剧下降。所以在生产环境这我们是不会让redis出现这种情况的。所以就得要限制最大使用内存，redis里面有一个参数是maxmemory，来限制最大内存量。如果超过这个参数的数值的话就会出发淘汰策略。淘汰策略种类：    noeviction：不会继续服务write服务，但是delete、read服务还是正常的，这样可以保证不会丢失数据，但是会让线上的服务无法持续进行。这是默认的淘汰策略    volatile-lru：尝试着去淘汰设置了超时时间的键，优先淘汰使用最少的key，如果没有设置过期时间的key就不会被淘汰，可以保证需要序列化的数据不会丢失。因为淘汰的只是设置了过期时间并且使用最少的key    volatile-ttl：和上面一样，但是优先淘汰的不是使用最少的key，而是淘汰最少ttl(寿命)的key。ttl越小越先被淘汰。    volatile-random：和上面一样，不过是在过期key的集合中随机淘汰。    allkeys-lru：相比前面的volatile淘汰的时设置有过期时间的key，这个的范围是所有的key。它淘汰的是在所有key中，使用最少的key。    allkeys-random：在所有key中随机淘汰，风险性较高。</code></pre><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><pre><code>概念：    用户的请求后，在数据库里没有，那么自然redis里也没有。这样就会直接穿过redis，到达DB，这就是缓存穿透。解决方案：    缓存空值        如果一个数据查询时空的时候，就先将这个空值去缓存到redis中，然后第二次的时候就会有值了。而不会继续访问数据库    布隆过滤器        和缓存空值比较类似，不过它是将空值放到布隆过滤器中，第二次查询的时候，先去布隆过滤器查，如果在布隆过滤器里面有的话就会直接返回空，如果没有再去查。        优点：底层是bitmap,占据的空间比较少 。             性能比较高</code></pre><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><pre><code>概念    如果缓存在一段时间内大范围的过期，而新的缓存还没有更新出来，就会导致发生大范围的缓存穿透。所有的查询压力全部放在了数据库上，对数据库的CPU和内存造成了很大压力，甚至宕机这就是缓存雪崩解决方案    1）加锁排队        用setnx去加锁，如果成功，则把这条数据放在数据中，再load进缓存，如果失败则进行一次get操作    2）双重缓存        设置两个缓存，C1与C2，C1的过期时间可以设置的相对比较短，C2的过期时间可以设置的相对比较长。我们遇到请求可以先去查询C1，如果C1查询不到可以去查询C2。如果C2也查询不到再去数据库查询，这样减少了DB的压力，也可以预防缓存雪崩    3）数据预热        系统上线之前，先将相关的数据加载到缓存系统中。通过缓存reload机制，预先去更新缓存，在发生大的并发访问之前手动出发加载不同的key。    4）定时更新缓存        时效性要求不高的缓存，可以在容器启动时进行初始化加载，采用定时任务来更新或者删除缓存。    5）随机时间        给缓存的失效时间加一个随机值，尽量让缓存的失效时间均匀一些。</code></pre><h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><pre><code>    概念        有主节点和从节点，主节点负责接收数据然后更新自身数据，再把数据传输到从节点上，而从节点就只是对外提供查询服务，而不会去主动地写服务，只有当主节点将数据同步给从节点的时候，这时候才会去修改数据。当我们在使用redis的时候，不可能只使用单机部署，肯定是通过多台机器部署然后设置主从模式。当主节点挂掉了，我们的OP同学还可以让从节点顶替主节点，以保证服务的可用。否则只等待主节点去恢复，会导致线上服务不可用，造成很大的损失。        redis的主从同步是异步的，所以redis不满足CAP理论中的C(强一致性)，满足的是A(可用性).redis保证的一致性是最终一致性，所以为了主从节点的数据一致，从节点会有各种方法去追上主节点的数据。    方式        增量同步            主节点会将那些对自己有影响的指令记在小本本(本地的内存buffer)上。然后用异步的方式将这小本本上的数据发给从节点，从节点接收到数据后，开始执行小本本上的操作。在执行的过程中还会给主节点返回一个offset，表示自己执行到了哪里了。我们都知道，内存是很宝贵的。这里的内存buffer也是宝贵的，所以我们要去循环利用这里的内存buffer。这里的内存buffer就相当于一个环链表。如果内容满了，就会把之前的数据覆盖然后重新写，所以这里的指令并不是永远存在的。这就导致了一个问题，就是当出现网络问题之后，主从无法通信，当主接收到了很多修改的命令的时候可能会把这个环写满，然后继续写，就会导致主从通信恢复后，从节点和主节点的数据永远不一致的问题。为了解决这个尴尬的问题，就有了全量同步        全量同步            这里同步的是所有的数据，先在主节点上执行一次bgsave，将所有的数据写到磁盘文件中，然后再把这个文件丢给从节点。从节点接收后，先将自己的数据清空，然后把这份数据copy一份到自己的内存里。这个同步过程并不是阻塞的，这时候主节点还在对外提供服务，所以这时候可能会有修改指令进来，buffer也得继续写。线程模型    概念        Redis有了自己实现的网络事件处理器，它是基于Reactor模式开发的，叫做文件事件处理器。它总共分为四个部分：IO多路复用、多个套接字、文件事件分派器、事件处理器。        如果这时有一个Redis客户端向Redis服务器发起连接，那么监听套接字将产生AE_READABLE事件， 触发连接应答处理器执行：处理器会对客户端的连接请求进行应答， 然后创建客户端套接字，以及客户端状态，并将客户端套接字的 AE_READABLE 事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。之后，客户端向Redis服务器发送一个命令请求，那么客户端套接字将产生 AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容， 然后传给相关程序去执行。执行命令将产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的AE_WRITABLE事件与命令回复处理器进行关联：当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITABLE事件， 触发命令回复处理器执行， 当命令回复处理器将命令回复全部写入到套接字之后， 服务器就会解除客户端套接字的AE_WRITABLE事件与命令回复处理器之间的关联。        https://juejin.im/post/5dabdb1ee51d45216d7b166a哨兵模式：    概念：它是Redis的一种高可用架构，为了改进主从模式下主节点故障必须得要人工的去将从节点改为主节点，并且还要通知改变了主节点地址.里面包含了Sentinel节点和数据节点。Sentinel节点不会去存储数据，它只会监控数据节点和除了他之外的其他Sentinel节点。如果发现节点没有消息传过来之后就会下线这个节点，如果这个节点是主节点就会与其他的Sentinel节点进行协商，如果大部分的Sentinel节点觉得这个主节点不可达之后就会下线这个节点，然后推选出一个Sentinel节点作为大哨兵去完成故障自动迁移的操作，然后将这个变化通知给应用放。Sentinel节点必须是奇数，而且数量&gt;2.    哨兵是通过什么来获得各个节点的信息的呢？它这里有三种定时任务：        1. 每隔10s，哨兵会向数据节点发送info指令，从而获取拓扑结构。        2. 每隔2s，哨兵会向_sentinel_的hello频道发送 当前哨兵节点的信息还有对主节点的判断。这样是为了可以让新的哨兵节点加入进来。        3. 每隔1s，当前哨兵节点会向其他的哨兵节点和数据节点发送ping命令，看是否得到回复.这样也是为了监控每个节点.    主观下线：再哨兵向其他的节点发送ping命令之后，如果有节点没在规定的时间内获取到回复的话，哨兵节点就会认为这些节点已经下线.默认时间为30s    客观下线：如果哨兵下线的是主节点的话，就会和其他的哨兵去发送对主节点的判断，如果有一半以上的哨兵觉得这个主节点是有问题的话，就会认为这个主节点是客观下线。所以说，客观下线是针对于主节点的。    哨兵选举：如果哨兵对这个主节点认为客观下线的话，就会进行哨兵选举，最后选举出一个哨兵队长去进行一个故障转移的操作。Redis的选举算法是根据Paxos算法改进的一个名叫Raft的选举算法，如果想要了解这个算法的内容的话就去下面的这个网址里看看，这里不做详细介绍。    https://www.infoq.cn/article/raft-paper        流程：        1.会向其他的哨兵节点发送sentinel is-master-down-by-addr命令，要将自己设置为队长。        2.收到命令的哨兵节点如果没有同意其他的哨兵节点的请求的话就会同意这个，简单地说就是谁先来我就先同意谁，其他的统统拒绝。        3.如果有哨兵的票数&gt;=1/2哨兵数+1的话，就会成为队长        4.如果这次没选出来就重新选举，回到1    故障迁移：先过滤掉被主观下线的从节点,如果有从节点优先级的话就选最先的，如果没有的话就选偏移量最大的(偏移量越大，复制的约完整)如果还没选举出就选择runid(每个redis启动都会获得一个随机的id)最小的。集群：    Redis的集群没有采用节点取余分区、也没有采用常用的一致性Hash分区，它使用的是Hash槽分区。槽是数据管理和迁移的基本单位，为了去方便数据拆分和集群扩展。它的Hash函数是CRC16(key)%16383。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;redis&quot;&gt;&lt;a href=&quot;#redis&quot; class=&quot;headerlink&quot; title=&quot;redis&quot;&gt;&lt;/a&gt;&lt;strong&gt;redis&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IO复习总结</title>
    <link href="http://runindark.com/2020/07/18/2020%E7%A7%8B%E6%8B%9B/IO/"/>
    <id>http://runindark.com/2020/07/18/2020秋招/IO/</id>
    <published>2020-07-18T04:16:27.310Z</published>
    <updated>2020-07-24T18:06:07.918Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Linux的五种IO模型"><a href="#Linux的五种IO模型" class="headerlink" title="Linux的五种IO模型"></a>Linux的五种IO模型</h2><ol><li>阻塞IO<blockquote><p>进程或线程等待某个条件，如果不满足则一直等待，进入阻塞</p></blockquote></li><li>非阻塞IO<blockquote><p>如果不满足条件则直接返回，然后轮询全部的请求，如果满足条件则读取</p></blockquote></li><li>信号驱动IO模型<blockquote><p>由于轮询的效率还是不够高，那么则采用信号机制，也就是说采用报警器，如果满足条件则内核让进程去读取</p></blockquote></li><li>IO复用模型<blockquote><p>添加select函数去监听所有的请求，如果哪个成功则直接进行IO读取</p></blockquote></li><li>异步IO模型<blockquote><p>IO读取由内核自己完成，如果读取完则直接告诉进程读取完成</p></blockquote></li></ol><h2 id="Java中的IO"><a href="#Java中的IO" class="headerlink" title="Java中的IO"></a>Java中的IO</h2><ul><li>BIO</li><li>NIO<ul><li>原理图<br>  <img src="https://i.loli.net/2020/07/25/PXLD8Msaf7IoAZ1.jpg" alt="nio基础模型.jpg"><ul><li>channel<br>  数据通过channel到达buffer，之后从buffer再读取到线程</li><li>buffer<br>  作为nio的重要实现，数据不需要像javaIO阻塞读取，而是可以一直被读取，而不影响线程的其它操作</li><li>总结分析<br>  NIO是<strong>同步非阻塞IO</strong>，由于buffer的实现，那么假如有数据需要读取到线程中，那么可以先读取到channel，再读取到buffer，但是如果数据没有完全读取完，<strong>线程在buffer还在不停的被读入数据的同时做其它的操作</strong></li></ul></li><li>selector<br>  <img src="https://i.loli.net/2020/07/25/ybOaCHgf5QPic36.jpg" alt="nio_selector.jpg"><br>  进一步的非阻塞，线程不会只是一个channel写入数据，单个线程可以利用selector控制多个channel写入数据</li></ul></li><li>AIO<blockquote><p>NIO的进化版本，同步的io需要线程本身的资源去读取，而非阻塞异步io，数据的读取过程由内核自己完成，当成功读取到线程中后，会有操作系统来提示线程数据读取完成。</p></blockquote></li></ul><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><blockquote><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p></blockquote><ul><li>select<ul><li>维护了三个状态数组，分别是<ul><li>fd_set* writefds</li><li>fd_set* readfds</li><li>fd_set* exceptfds</li></ul></li><li>通过遍历这三个数组则可以获取到状态</li><li><strong>问题：</strong> 单个进程可以监控的文件描述符有限，linux上是1024个</li></ul></li><li><p>poll</p><ul><li><p>select的进化，三个数组变成一个pollfd链表</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>问题：</strong> 虽然说取消了1024的限制，但是如果变长，效率还是很差</p></li></ul></li><li><p>epoll</p><ul><li>将改进转移到内核中，将<strong>用户关系的文件描述符的事件</strong>存放到<strong>内核的一个事件表</strong>中</li><li><p>epoll的操作过程</p><ul><li>int epoll_create(int size);、<br>  初始化<strong>内核中</strong>事件表的大小，size参数则是指定的大小，但是并不做限制，只是建议</li><li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</p><ul><li>epfd 是 epoll_create()的返回值</li><li>op 是 add，mod，del （增删改查的操作）</li><li>fd 监听的文件描述符</li><li>epoll_event 表示监听的具体什么事件的数组  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event &#123;</span><br><span class="line">    __uint32_t events;  /* Epoll events */</span><br><span class="line">    epoll_data_t data;  /* User data variable */</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //events可以是以下几个宏的集合：</span><br><span class="line">    EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">    EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">    EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">    EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">    EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">    EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">    EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure></li></ul></li><li><p>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);<br>  epoll_create（）返回的<strong>内核处理的事件结果</strong></p><ul><li>epfd 是 epoll_wait的结果</li><li>events 是内核上处理的事件的集合</li><li>maxevent就是告诉内核这些事件有多大，小于创建时的size</li><li>事件的超时事件</li></ul></li></ul></li><li><p>epoll的工作方式</p><ul><li>LT : 可以暂时不处理，等下次再来处理</li><li>ET ：需要立刻处理</li></ul></li><li><p>epoll的全流程总结</p><blockquote><p>epoll首先需要利用epoll_create()去创建一个句柄，方便直接联系到内核<br>之后利用epoll_ctl()去为epoll_create()在内核中空间创建的时间表中，添加文件描述符，或为文件描述符添加，删除或者是修改事件<br>注意一个文件描述符可以添加很多的描述的事件<br>之后，由于内核中存在事件表，如果事件表发生某种变化，可以利用一种callback的方式回调到epoll中<br>这个时候如果调用epoll_wait则可以获取这些状态 （减少了轮询，而是直接通知到epoll）</p></blockquote></li></ul></li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="IO" scheme="http://runindark.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习总结</title>
    <link href="http://runindark.com/2020/07/16/2020%E7%A7%8B%E6%8B%9B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://runindark.com/2020/07/16/2020秋招/计算机网络/</id>
    <published>2020-07-16T12:50:16.525Z</published>
    <updated>2020-07-18T04:49:03.303Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="五层体系网络结构"><a href="#五层体系网络结构" class="headerlink" title="五层体系网络结构"></a>五层体系网络结构</h2><ul><li>应用层<ul><li>http协议</li><li>dns协议</li><li>smtp电子邮件协议</li></ul></li><li>运输层<ul><li>tcp</li><li>udp</li></ul></li><li>网络层<ul><li>网络路由之间的数据传输</li></ul></li><li>数据链路层<ul><li>主机之间的数据传输</li></ul></li><li>物理层<ul><li>数据到主机之间的最低级传输</li></ul></li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h3><p><img src="https://i.loli.net/2020/07/18/Riza942VOKIYfbh.jpg" alt="三次握手.jpg"></p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><p><img src="https://i.loli.net/2020/07/18/cNTwbkAiP9FeD4z.jpg" alt="四次挥手.jpg"></p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li></ul><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p><img src="https://i.loli.net/2020/07/18/PwaJHm2gliRZAdk.jpg" alt="TCP和UDP.jpg"></p><h3 id="TCP如何保证可靠传送"><a href="#TCP如何保证可靠传送" class="headerlink" title="TCP如何保证可靠传送"></a>TCP如何保证可靠传送</h3><ul><li>TCP会自动把数据拆分成合适大小的数据块</li><li>TCP会把切割好的数据块进行编号</li><li>TCP会自动丢弃重复的数据</li><li><strong>超时重传</strong></li><li><strong>窗口滑动</strong></li><li><strong>ARQ协议</strong></li><li><strong>拥塞控制</strong>:TCP在网络拥塞的时候减少数据发送</li><li>校验和: TCP保持它的首部和数据的校验和</li></ul><h4 id="窗口滑动"><a href="#窗口滑动" class="headerlink" title="窗口滑动"></a>窗口滑动</h4><blockquote><p>TCP维护了<strong>发送端缓存窗口</strong>以及<strong>接收方缓存窗口</strong>，滑动窗口也可以理解为动态窗口，接受的时候接收端只能从<strong>接受缓存窗口中的数据</strong>去接受，发送方只能把数据发送到<strong>发送缓存窗口</strong>，<br>在带宽比较好的时候则窗口变大，速度也变大，太短较慢的时候窗口变小，这样子不会造成拥堵</p></blockquote><h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><ul><li><p>停止等待ARQ协议</p><blockquote><p>每当发送一段数据，那么要等对方确认这段数据被接收，才会发送下一段数据;如果发送失败，则会触发<strong>超时重传</strong></p></blockquote></li><li><p>连续ARQ协议</p><blockquote><p>发送数据的时候维护一个发送窗口，只要是处于发送窗口，就可以<strong>一直发送数据，不需要等接收方确认</strong>，每当接收到一个ACK则把窗口移动即可。<br>但是会存在回退的问题，如果发送5个分组，第3个丢失了，那么后面的全部都会丢失，只能把后三个重新传输一次</p></blockquote></li></ul><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul><li>慢开始<blockquote><p>由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，拥塞窗口cwnd加倍</p></blockquote></li><li>拥塞避免<blockquote><p>拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1</p></blockquote></li><li>快重传<blockquote><p>当接收方收到不是按照TCP编号排序的分组，则应当发送重新确认，一旦重新确认次数为3次，则立即重新传输丢失的分组</p></blockquote></li><li><p>快恢复</p><blockquote><p>当收到三个重复确认，确认丢失的时候则将ssthresh门限减半，将cwnd设置为ssthresh的大小，并开始使用拥塞避免算法（因为能连续收到3个确认，则没必要再慢开始）</p></blockquote></li><li><p>算法使用条件</p><ul><li>当cwnd&lt;ssthresh时，使用慢开始算法。</li><li>当cwnd&gt;ssthresh时，改用拥塞避免算法。</li><li>当cwnd=ssthresh时，慢开始与拥塞避免算法任意</li></ul></li></ul><h2 id="从输入Url到底发生了什么"><a href="#从输入Url到底发生了什么" class="headerlink" title="从输入Url到底发生了什么"></a>从输入Url到底发生了什么</h2><p><img src="https://i.loli.net/2020/07/18/ILC5lzpTGd9KE6F.jpg" alt="url到前端.jpg"></p><p>url -&gt; 浏览器缓存 -&gt; dns -&gt; tcp -&gt; 服务端 -&gt; 返回请求 -&gt; 浏览器渲染</p><h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><h3 id="http1-0-和-http1-1"><a href="#http1-0-和-http1-1" class="headerlink" title="http1.0 和 http1.1"></a>http1.0 和 http1.1</h3><ul><li>http1.1把http1.0默认的短连接改为长连接</li><li>http1.1新增状态码，比如410表示资源从服务器上删除</li><li>http1.1头部引入range，http1.0一旦发送请求会把所有的内容都请求过来，通过range可以请求到自己需要的数据就好</li><li>缓存处理，引入了更多的缓存策略</li></ul><h3 id="http-和-https"><a href="#http-和-https" class="headerlink" title="http 和 https"></a>http 和 https</h3><ul><li>http默认使用80，https则默认使用443</li><li>HTTPS协议需要到CA申请证书</li><li><p>https运行再ssl之上<br><img src="http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribXL5PwzkqQdmyY9egu2hpzzMCgz2F5HhhkdSNc5eYJ9UGMDBGjeCGiag/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="https和http"></p></li><li><p>所有传输的内容都经过加密，<strong>加密采用对称加密</strong>，但对称加密的密钥用服务器方的<strong>证书进行了非对称加密</strong>。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p><ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等</li></ul></li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://runindark.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java集合复习总结</title>
    <link href="http://runindark.com/2020/07/16/2020%E7%A7%8B%E6%8B%9B/%E9%9B%86%E5%90%88/"/>
    <id>http://runindark.com/2020/07/16/2020秋招/集合/</id>
    <published>2020-07-16T06:41:31.145Z</published>
    <updated>2020-07-18T04:57:39.182Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul><li>Vector<ul><li>线程安全</li></ul></li><li>ArrayList<ul><li>基于数组实现</li><li>适合读，不适合改</li><li>线程不安全</li></ul></li><li>LinkedList<ul><li>基于链表实现</li><li>适合修改，但不适合读</li><li>线程不安全</li></ul></li><li>CopyOnWriteArrayList<ul><li>读写分离</li><li>在执行修改操作的时候会复制一块新的空间</li><li>写操作会出现进程阻塞，但是读操作不会</li></ul></li><li>Collectionbs.synchronizedlist<ul><li>线程安全所有方法都加了synchronized关键字</li></ul></li></ul><h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><ul><li>扩容机制以及初始化<ul><li>JDK1.7之前默认大小为10，JDk1.8之后，之后开始使用list集合才会分配10的空间</li><li>1.5倍扩容</li></ul></li><li>读写操作分析<ul><li>扩容<br>扩容利用Arrays.copyOf() (在原来的数组中重新创建数组) 进行扩容</li><li>插入或修改<br>利用System.arraycopy()进行操作，如果是删除，则向前移动，如果是插入则向后移动<h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3></li></ul></li><li>删除插入都比较容易双向链表的插入</li><li><p>在指定位置插入数据</p><ul><li>toArray转化成对象数组</li><li>之后遍历对象数组</li><li>之后再插入<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2></li></ul></li><li><p>hashmap</p><ul><li>线程不安全</li><li>默认大小16</li><li>可以存储值为null的key和value</li><li>双倍扩容</li></ul></li><li>hashtable<ul><li>线程安全</li><li>默认大小11</li><li>不可以存储值为null的key和value</li><li>2n+1倍扩容</li></ul></li><li>concurrentHashmap<ul><li>线程安全</li><li>读取用cas，更改用synchronized</li><li>发生hash冲突，会用cas写入</li></ul></li></ul><h3 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h3><ul><li>参阅原帖<br>  <a href="https://blog.csdn.net/v123411739/article/details/78996181" target="_blank" rel="noopener">hashmap</a></li><li>扩容机制和默认大小<br>  默认大小为16，扩容为双倍扩容</li><li>链表转红黑树<br>  当链表节点超过8时，转为红黑树</li><li>红黑树转链表<br>  6个节点红黑树转回链表</li><li><p>定位哈希桶数组的位置<br>  <img src="https://i.loli.net/2020/07/18/O5SaVqh9uyYC7Q4.jpg" alt="hash桶.jpg"></p><ol><li>获取map中 key的hash值</li><li>将 hashCode 的高位参与运算，重新计算 hash 值（当table比较小的时候，让高位也参与运算）<ul><li>hashcode 异或 hashcode高16位 以此获取hash值</li><li>如果没有这一步，table长度为16，直接进行 与 运算，那么高28位的运算结果都是0，那么hash桶则只在15的区间内分布，那么hash冲突的概率就会上升。<br><img src="https://i.loli.net/2020/07/18/w2FxO7p1GjvJySU.jpg" alt="hashmap1.8优化.jpg"></li></ul></li><li>计算出来的 hash 值与 (table.length - 1) 进行 &amp; 运算</li></ol></li><li><p>jdk1.7为头插法，jdk1.8改为尾插法</p></li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="集合" scheme="http://runindark.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>框架复习总结</title>
    <link href="http://runindark.com/2020/07/12/2020%E7%A7%8B%E6%8B%9B/%E6%A1%86%E6%9E%B6/"/>
    <id>http://runindark.com/2020/07/12/2020秋招/框架/</id>
    <published>2020-07-12T15:12:55.051Z</published>
    <updated>2020-07-25T03:40:22.131Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="IOC控制翻转和DI"><a href="#IOC控制翻转和DI" class="headerlink" title="IOC控制翻转和DI"></a>IOC控制翻转和DI</h2><p><img src="https://i.loli.net/2020/07/12/PtGuHK12XoI9Qf5.jpg" alt="控制反转-依赖注入.jpg"></p><blockquote><p>控制反转和依赖注入其实说的是一个东西，为了解耦，将创建对象的任务交付给Spring的容器来创建，而不是用new来创建。</p></blockquote><h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><h3 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h3><ul><li>Singleton : 单例，在IOC容器中只存在一个，会在容器内缓存</li><li>prototype : 多例，利用getBean()频繁创建，同时也会频繁的销毁</li><li>Web<ul><li>request : 每一次 HTTP 请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效</li><li>session : session 作用域表示该针对每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效</li><li>global session</li></ul></li></ul><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p><img src="https://i.loli.net/2020/07/17/gtXnOM6Geyv4h1i.jpg" alt="bean生命周期.jpg"></p><h2 id="静态代理和动态代理"><a href="#静态代理和动态代理" class="headerlink" title="静态代理和动态代理"></a>静态代理和动态代理</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>A方法需要C方法来修饰，那么需要创建B实现A+C，之后调用B来实现<br><img src="https://i.loli.net/2020/07/12/in1JIsCrfOvyj8d.jpg" alt="静态代理.jpg"></p></blockquote><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/49790288.jpg" alt=""></p><p><img src="https://i.loli.net/2020/07/18/viBtdYRCmyUFW9O.jpg" alt="springmvc执行流程.jpg"></p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul><li>Proxy + InvocationHandler<br>被代理对象接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>被代理类接口实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add user into database."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        System.out.println(<span class="string">"getUser from database."</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代理（中间）类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtil</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;    <span class="comment">// 被代理的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do sth before...."</span>);</span><br><span class="line">        Object result =  method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"do sth after...."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ProxyUtil(Object target)&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object proxyedObject = <span class="keyword">new</span> UserServiceImpl();    <span class="comment">// 被代理的对象</span></span><br><span class="line">        ProxyUtil proxyUtils = <span class="keyword">new</span> ProxyUtil(proxyedObject);</span><br><span class="line">        <span class="comment">// 生成代理对象，对被代理对象的这些接口进行代理：UserServiceImpl.class.getInterfaces()</span></span><br><span class="line">        UserService proxyObject = (UserService) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), </span><br><span class="line">                    UserServiceImpl.class.getInterfaces(), proxyUtils);</span><br><span class="line">        proxyObject.getUser(<span class="number">1</span>);</span><br><span class="line">        proxyObject.addUser(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>核心则在于被代理的对象必须要有含有自己方法的接口，才可以使用Proxy+InvocationHandler，同时，代理类中主要是通过调用被重写的invoke（）方法。</p></blockquote><ul><li>CGlib + MethodInterceptor</li></ul><p>Cglib代理的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;    <span class="comment">// 被代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method arg1, Object[] arg2, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do sth before...."</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(arg0, arg2);</span><br><span class="line">        System.out.println(<span class="string">"do sth after...."</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());    <span class="comment">// 设置父类</span></span><br><span class="line">        <span class="comment">// 设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);    <span class="comment">// 在调用父类方法时，回调 this.intercept()</span></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object proxyedObject = <span class="keyword">new</span> UserServiceImpl();    <span class="comment">// 被代理的对象</span></span><br><span class="line">        CGProxy cgProxy = <span class="keyword">new</span> CGProxy(proxyedObject);</span><br><span class="line">        UserService proxyObject = (UserService) cgProxy.getProxyObject();</span><br><span class="line">        proxyObject.getUser(<span class="number">1</span>);</span><br><span class="line">        proxyObject.addUser(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>与Proxy+InvocationHandler不同，Cglib是利用enhancer.create创造了一个代理对象，而这个大力对象的父类就是被代理类，利用enhancer.setSuperclass()指定，同时利用enhancer.setCallback()回调被重写的intercept，完成对方法的包裹</p></blockquote><h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><blockquote><p>事务是<strong>一组</strong>操作，要么全部成功，要么全部失败</p><ul><li>事务特性 ACID<ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul></li></ul></blockquote><h3 id="事务分类"><a href="#事务分类" class="headerlink" title="事务分类"></a>事务分类</h3><ul><li>声明式事务（推荐，@Transactional）</li><li>编程式事务 （TransactionManager）<h3 id="事务隔离级别（和mysql一直）"><a href="#事务隔离级别（和mysql一直）" class="headerlink" title="事务隔离级别（和mysql一直）"></a>事务隔离级别（和mysql一直）</h3></li></ul><ul><li>未提交读</li><li>提交读</li><li>可重复读</li><li>串行化<h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3></li></ul><ul><li>PROPAGATION_REQUIRED（默认开启）<ul><li>如果外部没有开启事务，则内部自己开启子事务</li><li>如果外部开启事务，则内部和外部属于同一个事务</li></ul></li><li>PROPAGATION_REQUIRES_NEW<ul><li>不论外部有没有开启事务，则内部自己都开启子事务</li><li>如果当前已存在事务，则直接挂起</li></ul></li><li>PROPAGATION_NESTED<ul><li>外部未开启事务，和require一样</li><li>外部开启事务，则内部方法变成子事务，可以一起会滚，内部的子事务可以独立回滚</li></ul></li><li>PROPAGATION_MANDATORY<ul><li>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li></ul></li></ul><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p><img src="https://i.loli.net/2020/07/12/CMxHmBaleUA7d8V.jpg" alt="JDBC.jpg"></p><blockquote><p>一般来说多使用PreparedStatement在执行之前会进行预编译<br>效率高于Statement,且能够有效防止SQL注入<br>PreparedStatement支持?占位符而不是直接拼接，提高可读性</p></blockquote><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul><li>Mybatis工作流程<br><img src="https://i.loli.net/2020/07/13/N2x4z1bkUsB8uCW.jpg" alt="Mybatis.jpg"></li><li>Myabtis多级缓存<br><img src="https://i.loli.net/2020/07/13/lEtTkvVJLHZcXB5.jpg" alt="Mybatis缓存.jpg"></li></ul><blockquote><p>当一级缓存和耳机缓存同时打开的时候，先到二级缓存再到一级缓存</p></blockquote><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><h3 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h3><p>自动装配原理主要集中在@SpringbootApplication注解中</p><ul><li>@EnableAutoConfiguration<br>  启用 SpringBoot 的自动配置机制</li><li>@Configuration<br>  启用 SpringBoot 的自动配置机制</li><li>@ComponentScan<br>  扫描被@Component (@Service,@Controller)注解的bean，注解默认会扫描该类所在的包下所有的类</li></ul><p><img src="https://i.loli.net/2020/07/25/aXsUJvcjWm9nx3e.jpg" alt="Springboot自动装配原理.jpg"></p><ol><li>进入@SpringbootApplication</li><li>利用@EnableAutoConfiguration注解开启自动装配</li><li>在EnableAutoConfiguration接口的实现中利用@Import主节导入了 EnableAutoConfigurationImportSelector.class</li><li>EnableAutoConfigurationImportSelector 的父类AutoConfigurationImportSelector利用List集合存储了配置信息</li><li>具体是利用getCandidateConfigurations获取集合信息</li><li>其中getcandidateConfiguration中是利用SpringFactoriesloader获取了配置对象</li></ol></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="框架" scheme="http://runindark.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis复习总结</title>
    <link href="http://runindark.com/2020/07/12/2020%E7%A7%8B%E6%8B%9B/Redis/"/>
    <id>http://runindark.com/2020/07/12/2020秋招/Redis/</id>
    <published>2020-07-12T02:36:30.624Z</published>
    <updated>2020-07-26T16:53:27.934Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Redis内存模型"><a href="#Redis内存模型" class="headerlink" title="Redis内存模型"></a>Redis内存模型</h2><h3 id="Redis内存分配"><a href="#Redis内存分配" class="headerlink" title="Redis内存分配"></a>Redis内存分配</h3><ul><li>数据 ：Redis存储的数据对象 字符串、哈希、列表、集合、有序集合 </li><li>进程本身所需内存 ： Redis进程自己运行所需要的内存，比如代码，占用内存，常量池等</li><li>缓存内存： <ul><li>客户端缓冲区 ： 连接客户端输入输出的缓存</li><li>复制积压缓冲区： 在主从同步时，非全量复制时，所需要的缓存区</li><li>复制积压缓冲区： AOF写入时的缓存</li></ul></li><li>内存碎片：内存碎片是Redis在分配、回收物理内存过程中产生的</li></ul><h3 id="Redis内存分配器-（jemalloc）"><a href="#Redis内存分配器-（jemalloc）" class="headerlink" title="Redis内存分配器 （jemalloc）"></a>Redis内存分配器 （jemalloc）</h3><ul><li>jemalloc 将空间分为 小（Small）、大（Large）、巨大（Huge）三种<br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001126509-2023165562.png" alt="jemalloc"></li></ul><h3 id="Redis内存统计"><a href="#Redis内存统计" class="headerlink" title="Redis内存统计"></a>Redis内存统计</h3><ul><li>used_memory （Redis内存分配器分配的内存）<blockquote><p>存储的数据的内存</p></blockquote></li><li>used_memory_rss （Redis占操作系统的内存）<blockquote><p>包括存储的数据内存还有内存碎片以及Redis本身占用内存</p></blockquote></li></ul><h3 id="Redis数据的存储过程"><a href="#Redis数据的存储过程" class="headerlink" title="Redis数据的存储过程"></a>Redis数据的存储过程</h3><ul><li><p>RedisObject<br><img src="https://i.loli.net/2020/07/12/xQOXjFEvNzgoaf8.jpg" alt="RedisObject"></p></li><li><p>数据类型</p><ul><li><p>SDS<br>  <img src="https://i.loli.net/2020/07/12/hpUmPNkzaR9e4n1.jpg" alt="SDS.jpg"></p><ul><li>空间预分配<br>  sdscat =》给字符串后面再拼接一个字符串<br>  当sdscat 之后内存小于 1M，字符串长度*2+1 （’\0’）<br>  当sdscat 之后内存大于 1M, 字符串长度 + 1M + 1（’\0’）</li><li>空间懒分配<br>  如果sdstrim（减少字符串），则不急着回收空间，下次如果需要添加长度，直接使用多余的空间。</li></ul></li><li><p>List<br>  <img src="https://i.loli.net/2020/07/12/AcZDGyX5IJnYl6h.jpg" alt="List.jpg"></p></li><li>Hash<br>  <img src="https://i.loli.net/2020/07/12/Di1vVNXMo83Zfsb.jpg" alt="hash.jpg"><br>  在字典中存在dictht数组，表明是两个hash表<br>  ht[1]的容量是ht[0]的两倍<br>  把ht[0]中的元素rehash复制到ht[1]中</li><li>set</li><li>zset</li></ul></li><li><p>数据存储过程</p><blockquote><p>RedisObject -&gt; 具体的数据类型</p></blockquote></li></ul><h3 id="Redis内存回收策略"><a href="#Redis内存回收策略" class="headerlink" title="Redis内存回收策略"></a>Redis内存回收策略</h3><ul><li>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令(大部分的写入指令，但DEL和几个例外)</li><li>allkeys-lru:尝试回收最少使用的键(LRU) ，使得新添加的数据有空间存放。</li><li>volatile-lru:尝试回收最少使用的键(LRU) ，但仅限于在过期集合的键,使得新添加的数据有空间存放。</li><li>allkeys-random:回收随机的键使得新添加的数据有空间存放。</li><li>volatile-random:回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</li><li>volatile-ttl:回收在过期集合的键，并且优先回收存活时间(TTL) 较短的键，使得新添加的数据有空间存放。</li></ul><h2 id="Redis的原子性保证"><a href="#Redis的原子性保证" class="headerlink" title="Redis的原子性保证"></a>Redis的原子性保证</h2><ul><li>单指令原子性<blockquote><p>Redis是单线程的，一个线程只能执行一个指令，因此具有原子性</p></blockquote></li><li>Lua原子性<blockquote><p>官方解释来看，Lua脚本和Redis的事务一样，被exec/mutl包裹，redis保证每次只能执行一个lua脚本，别的lua脚本不会被执行，由此保证了原子性。</p></blockquote></li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h3><ul><li>setnx 不存在key才可以操作</li><li>set 与set相反<h3 id="锁续期"><a href="#锁续期" class="headerlink" title="锁续期"></a>锁续期</h3><blockquote><p>利用<strong>Redission</strong>，当成功获取一个锁的时候，产生看门狗（watch dog）进行锁续期，一般来说是10s检查一次<br>核心在于Redission使用了Lua脚本</p></blockquote><h3 id="分布式锁的极端情况"><a href="#分布式锁的极端情况" class="headerlink" title="分布式锁的极端情况"></a>分布式锁的极端情况</h3><blockquote><p>当服务A从Master中获取锁，A获取锁成功后，还没来得及同步到从节点，master挂了，从节点<br>重新成为master，服务B过来后，发现该锁还未被获取，于是锁被重复获取</p></blockquote></li></ul><h2 id="Redis的冷备和热备"><a href="#Redis的冷备和热备" class="headerlink" title="Redis的冷备和热备"></a>Redis的冷备和热备</h2><ul><li>热备 - AOF<ul><li>数据文件比RDB更大</li><li>每秒都去持久化，数据丢失少</li><li>存储的文件是每条的指令</li><li>先执行命令，之后才存储到磁盘（由于redis不是完全维护，只有执行以后才知道结果，单纯的语法监测是无用的）</li><li>bgrewriteaof 可以对aof的日志文件进行瘦身，也就是fork一个子进程把原来的日志全部转化成redis命令存到一个新的日志中执行</li></ul></li><li>冷备 - RDB<ul><li>需要fork子进程，数据量大的话会导致几秒的延迟，对于秒杀场景危险</li><li>是段时间保存数据，一旦发生宕机，数据丢失较多</li><li>RDB恢复的更快</li></ul></li></ul><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="哨兵监控"><a href="#哨兵监控" class="headerlink" title="哨兵监控"></a>哨兵监控</h3><ul><li>主观下线<blockquote><p>从节点无法ping通master，则主观认为master挂了</p></blockquote></li><li>客观下线（主节点的下线）<blockquote><p>多个从节点都无法ping通master，则从节点们客观认为master挂了，<strong>需要重新选举</strong></p></blockquote></li><li>定时任务</li><li>错误转移<ul><li>过滤不健康的节点</li><li>选举出新的节点</li><li>让从节点成为主节点</li><li>让原来的master成为从节点</li></ul></li><li>哨兵选举<blockquote><p>Raft : 谁先申请成为主节点，谁就是主节点</p></blockquote></li></ul><h2 id="主从同步的过程"><a href="#主从同步的过程" class="headerlink" title="主从同步的过程"></a>主从同步的过程</h2><ol><li>从节点向master发送slaveof获取主节点的信息<ul><li>定时任务获取主节点信息</li><li>从节点去ping主节点，主节点则返回pang和runid等信息</li></ul></li><li>从节点根据保存的Master runid判断是不是第一次同步复制</li><li>如果是第一次psync?-1，则进行全量复制<ul><li>全量复制址启用用RDB生成快照<ul><li>启动RDB会fork子进程，则子进程运行期间，新命令进入到缓存区</li></ul></li><li>RDB生成到磁盘，之后在读取到内存，再进行数据同步<ul><li>快照内容同步完以后，再将缓存的命令缓存到从节点</li></ul></li></ul></li><li>如果不是第一次，则进行部分复制，从节点向master发送Psync runid offset</li><li>Master收到命令后会查看，runid是否一致，之后查看偏移量offset是否超过复制积压缓存区<ul><li>如果偏移量超过复制积压缓存区，则err，进行全量复制</li><li>如果未超过，则offset+偏移量+命令长度进行部分复制 </li></ul></li></ol><h3 id="复制积压缓存区"><a href="#复制积压缓存区" class="headerlink" title="复制积压缓存区"></a>复制积压缓存区</h3><blockquote><p>在主从同步的期间，仍然会有写命令在执行，这时命令在写入主节点的同时还会写入<strong>复制积压缓存区</strong>,同时记录偏移量，如果这期间缓存的命令过多，则没必要再进行部分复制，直接进行全量复制即可</p></blockquote><h2 id="缓存的常见问题"><a href="#缓存的常见问题" class="headerlink" title="缓存的常见问题"></a>缓存的常见问题</h2><ol><li>缓存穿透<ul><li>恶意访问不存在的数据，导致打入数据库</li><li>增加认证（接口访问功能）</li></ul></li><li>缓存击穿<ul><li>某热点数据突然失效，打入数据库</li><li>设置null值</li></ul></li><li>缓存雪崩<ul><li>大量数据同时失效</li><li>设置随机时间种子</li></ul></li></ol><h2 id="redis中的-HyperLogLog"><a href="#redis中的-HyperLogLog" class="headerlink" title="redis中的  HyperLogLog"></a>redis中的  HyperLogLog</h2><h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><blockquote><p>访问网站的独立访客UV，例如每个访客访问某网站，访问多次，其实只能算作一次。<br>那么带来的直接问题是，如果每个用户都占用一个key，那么就会产生数据量巨大的问题</p></blockquote><h3 id="解决方案拆分"><a href="#解决方案拆分" class="headerlink" title="解决方案拆分"></a>解决方案拆分</h3><ul><li>借鉴数据库的b+树<blockquote><p>解决了插入和查找的问题，但是解决不了数据量大，占用内存的问题</p></blockquote></li><li>bitmap<blockquote><p>如果是一亿个数据，那么100_000_000(数据量)/ 8（字节）/ 1024（KB）/ 1024（MB） ≈ 12 M</p></blockquote></li></ul><h3 id="概率统计"><a href="#概率统计" class="headerlink" title="概率统计"></a>概率统计</h3><blockquote><p>可以看到bitmap已经是属于极致的优化了，但是还是不够，不管怎么说，为了一个统计功能，单一个对象就是12M,但是再多一些还是会很多<br>则使用 “估计的方法可能会好一些”，则使用 <strong>概率统计</strong></p></blockquote><h4 id="redis的实现"><a href="#redis的实现" class="headerlink" title="redis的实现"></a>redis的实现</h4><p>HLL中实际存储的是一个长度为mm的大数组SS，将待统计的数据集合划分成mm组，每组根据算法记录一个统计值存入数组中。数组的大小mm由算法实现方自己确定，redis中这个数组的大小是16834（2的14次方），m越大，基数统计的误差越小，但需要的内存空间也越大<br><img src="https://i.loli.net/2020/07/27/Sctp8ygmNfFUJ5K.jpg" alt="hll的redis过程.jpg"></p><h4 id="hll的实现原理-伯努利试验"><a href="#hll的实现原理-伯努利试验" class="headerlink" title="hll的实现原理 - 伯努利试验"></a>hll的实现原理 - 伯努利试验</h4><ul><li>伯努利实现也就是掷硬币实现，那么我们说假设存在第一次掷出正面所用的最多的次数为kmax，则可以提出假设</li><li><p>假设：</p><ul><li>掷出n次正面所用的次数一定少于n*kmax</li><li>掷出n次正面所用的次数一定有那么一次是等于kmax的（其实正好是1减去上面的概率）<br><img src="https://i.loli.net/2020/07/23/1YSsrdghimzlXK8.jpg" alt="伯努利假设.jpg"></li></ul></li><li><p>推断：</p><ul><li>那么当n远大于kmax的时候，那么第一个不成立</li><li>那么当n远小于kmax的时候，那么第二个不成立</li></ul></li><li><p>继续推断</p><ul><li>那么用kmax推断n的次数貌似是最好的情况<br>则 n = 2^kmax</li></ul></li><li><p>继续思考</p><ul><li>如果很大的一段二进制，只用一个kmax误差比较大</li><li>那么把一段很大的分开估计就好了，因此有<strong>分桶原理</strong>，也就是redis过程中对应的数组S的m</li></ul></li></ul><h3 id="稀疏存储和密集存储"><a href="#稀疏存储和密集存储" class="headerlink" title="稀疏存储和密集存储"></a>稀疏存储和密集存储</h3><ol><li>密集存储就是按照原来16834来存储</li><li>稀疏存储就是连续两个0作为统计接下来的 6bit 整数值加 1 <h3 id="hll对象头"><a href="#hll对象头" class="headerlink" title="hll对象头"></a>hll对象头</h3><pre><code class="c"><span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> {</span> <span class="keyword">char</span> magic[<span class="number">4</span>];      <span class="comment">/* 魔术字符串"HYLL" */</span> <span class="keyword">uint8_t</span> encoding;   <span class="comment">/* 存储类型 HLL_DENSE or HLL_SPARSE. */</span> <span class="keyword">uint8_t</span> notused[<span class="number">3</span>]; <span class="comment">/* 保留三个字节未来可能会使用 */</span> <span class="keyword">uint8_t</span> card[<span class="number">8</span>];    <span class="comment">/* 总计数缓存 */</span> <span class="keyword">uint8_t</span> registers[]; <span class="comment">/* 所有桶的计数器 */</span>};</code></pre></li></ol><h2 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h2><h3 id="PubSub"><a href="#PubSub" class="headerlink" title="PubSub"></a>PubSub</h3><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>没有ack确认信息，不能保证数据连续</li><li><p>不持久化消息</p><h4 id="PubSub-1"><a href="#PubSub-1" class="headerlink" title="PubSub"></a>PubSub</h4><p><img src="https://i.loli.net/2020/07/24/6jHO7DIZMxAkvGL.jpg" alt="redis_PubSub订阅模式.jpg"></p></li><li><p>精确匹配</p><blockquote><p>订阅某个精确频道，则需要精确的知道这个频道的key值，才可以订阅，比如client订阅redis频道<br><img src="https://i.loli.net/2020/07/24/MtX9ZLSxukBohrY.jpg" alt="redis_发布订阅_channel.jpg"></p></blockquote></li><li>前缀多匹配<blockquote><p>订阅某种类型的全部频道，也就是说知道某频道类型的前缀，则可以订阅该类型下的全部频道，例如<strong>client订阅redis.*的频道</strong>,<br>则会<strong>订阅redis.log,redis.rdb等一系列符合redis.*的一系列前缀频道</strong><br><img src="https://i.loli.net/2020/07/24/CSMaz6mKxd3svFq.jpg" alt="redis_patten_多匹配原理.jpg"></p></blockquote></li></ul><h4 id="steam"><a href="#steam" class="headerlink" title="steam"></a>steam</h4><p><img src="https://i.loli.net/2020/07/24/ZM5drvlSyHApVOF.jpg" alt="redis_steam.jpg"></p><ul><li>Consumer Group：消费者组<blockquote><p>多个consumer需要某消息的一个群组</p></blockquote></li><li>last_delivered_id：消息游标<blockquote><p>群组需要哪个消息，则指向这个消息的id,消息 ID 如果是由 XADD 命令返回自动创建的话，那么它的格式会像这样：timestampInMillis-sequence (毫秒时间戳-序列号)，例如 1527846880585-5，它表示当前的消息是在毫秒时间戳 1527846880585 时产生的，并且是该毫秒内产生的第 5 条消息。</p></blockquote></li><li>pending_ids：状态数组<blockquote><p>记录未确认ack的消息的数组，如果客户端发送ack则数组中的内容减少，如果不发送则会一直增加</p></blockquote></li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Redis" scheme="http://runindark.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Jvm复习总结</title>
    <link href="http://runindark.com/2020/06/28/2020%E7%A7%8B%E6%8B%9B/jvm/"/>
    <id>http://runindark.com/2020/06/28/2020秋招/jvm/</id>
    <published>2020-06-28T15:54:20.982Z</published>
    <updated>2020-07-18T09:47:17.074Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="Jvm数据区"><a href="#Jvm数据区" class="headerlink" title="Jvm数据区"></a>Jvm数据区</h3><p><img src="https://i.loli.net/2020/07/14/nPEm8sD7v6dMLXQ.png" alt="jvm_数据区.png"></p><ul><li>线程共享区<ul><li>方法区（运行常量池）<br>  主要用于存放堆内存中的一些执行逻辑和变量，类的加载信息，常量，静态变量等一系列信息，和堆不同，方法去不需要频繁gc等操作，又叫<strong>永久代</strong></li><li>堆<br>  Java中的类<strong>实例，数组</strong>都将存放在堆中，gc发生也是在堆中，堆是Jvm内存中最大的一块内存地址</li></ul></li><li>线程私有区<ul><li>虚拟机栈<br>  虚拟机栈就是线程所私有Java方法的内存区域，包括方法所引用的基本数据类型和引用。<br>  Java方法的使用就是压栈过程，基本数据类型和引用则是存在栈帧中，当方法抛出异常或结束则是出栈的操作。</li><li>本地方法区<br>  native修饰的非Java方法<br>  本地方法栈也有自己的栈帧等，栈帧里面也相应的有局部变量表，操作数栈，动态链接，出口信息等</li><li>程序计数器<br>  Jvm的本质是多线程交替的，但是如何保证每一个线程拿到cpu资源的时候可以从结束的地方接着开始，就需要程序技术器来保证</li></ul></li></ul><h4 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h4><ul><li>Eden</li><li>Survivor0</li><li>Survivor1 </li><li>老年代</li></ul><blockquote><p>首先分配内存到Eden区，当发生Gc之后转移到s0或者s1中（如果s0先被使用，那么下一次则使用s1，总之是为了保留新生代的内容），每一次gc都会给新生代数据记录次数，一般来说超过15次则进入老年代</p></blockquote><h4 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h4><ul><li>字符串内容</li><li>final修饰的关键字</li><li>基本数据类型的值</li><li>符号引用<ul><li>类和结构完全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul></li></ul><h3 id="Java对象的创建过程"><a href="#Java对象的创建过程" class="headerlink" title="Java对象的创建过程"></a>Java对象的创建过程</h3><ol><li>类加载</li><li>分配内存</li><li>初始化零值</li><li>设置对象头</li><li>执行init</li></ol><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p><img src="https://img-blog.csdnimg.cn/2019062014564165.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9jdWl0,size_16,color_FFFFFF,t_70" alt="类加载过程图"></p><ol><li><p>加载 （所需类的加载过程）</p><ul><li>通过类的全限定名获取该类的二进制流（通过class全限定名从本地，网络，专有数据库中的jar或者zip中获取.class文件）</li><li>生成java.lang.class对象作为<strong>方法区</strong>进入该对象的入口</li><li>将字节流的存储结构转化到jvm方法区中运行时的数据结构</li></ul></li><li><p>验证 （了解Class字节文件是否符合当前虚拟机要求）</p><ul><li>文件格式验证: 字节流是否符合class文件规范</li><li>元数据验证: 是否符合java的语法规范，例如继承接口，是否实现了接口中的方法</li><li>字节码验证: 数据和控制流验证，保证方法中的类型转换有效</li><li>符号引用验证: 验证是否可以通过符号引用找到相应的对象和变量</li></ul></li><li><p>准备 （为类的变量分配内存和设置类的初始值（即<strong>方法区</strong>分配这些变量空间））</p><ul><li>为变量分配空间</li><li>为变量初始化赋值的过程，例如int 赋值为 0 ，对象赋值为 null 等</li><li><strong>特殊</strong> private static final a = 1<br>正常来说，应该是初始化阶段赋值，但是这个情况下直接在方法去中替换a = 1 ，则在<strong>准备阶段就完成赋值</strong></li></ul></li><li>解析 （虚拟机将常量池中的符号引用转为直接引用的过程）<ul><li>什么是符号引用？<br>用一串不会有歧义的符号来标识引用的对象或者是变量</li><li>什么是直接引用？<br>正式用指针去引用符号和变量</li></ul></li><li>初始化<blockquote><p>真正按照程序员的意愿去初始化值</p></blockquote></li></ol><h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><h5 id="分配方法"><a href="#分配方法" class="headerlink" title="分配方法"></a>分配方法</h5><ol><li>指针碰撞<br>内存空间比较<strong>整洁</strong>，直接移动指针分配空间</li><li>空闲链表<br>“见缝插针”，空间不连续，则找到空闲的地方插入数据</li></ol><h5 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h5><ol><li>利用CAS不都安的尝试获取内存空间直到成功（目前虚拟机的解决方案）</li><li>TLAB： 为每个线程独自分配一部分空间，且独有，分配的时候优先分配到该空间中</li></ol><h4 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h4><p>例如Synchronized关键字需要Mark Word中的monitor对象（MonitorExit，MonitorEnter）</p><h3 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h3><ol><li>句柄访问<br><img src="https://i.loli.net/2020/07/14/xNo3TZC4ir98tDL.jpg" alt="句柄.jpg"><br>reference -&gt; 句柄池中指针 -&gt; 实例数据</li><li><p>直接访问<br><img src="https://i.loli.net/2020/07/14/hvbVfx1298l6QUP.jpg" alt="直接访问.jpg"><br>reference -&gt; 实例数据</p></li><li><p>句柄和直接访问的优缺点分析</p><blockquote><p>论访问速度直接访问最快，但是如果需要删除的话需要直接删除数据<br>句柄中则可以直接把句柄值赋null，效率更快</p></blockquote></li></ol><h3 id="对象死亡的分析方法"><a href="#对象死亡的分析方法" class="headerlink" title="对象死亡的分析方法"></a>对象死亡的分析方法</h3><ol><li>程序计数法 ： 清零以后则可以判断死亡</li><li>可达性分析法 ： 以Gc root为起点 看看各个对象是否可以连接起来，如果连接不起来，被独立则可以判断回收</li></ol><ul><li>什么是Gc root（GC Roots一般在JVM的栈区域里产生）<ul><li>处于激活状态的线程</li><li>栈中的对象</li><li>JNI中的变量</li><li>JNI的全局引用</li><li>对象头的Monitor对象</li></ul></li></ul><h3 id="引用的类型"><a href="#引用的类型" class="headerlink" title="引用的类型"></a>引用的类型</h3><ul><li>强引用 （大部分是强引用，虚拟机就算oom，也不会回收引用）</li><li>软引用 （当内存不足的时候，会回收软引用）</li><li>弱引用 （只要被回收器判定为垃圾，则直接回收，可以用于判断是否被gc回收）</li><li>虚引用 （虚引用不在乎引用了什么对象，可以说是一种gc标志，必须配合引用队列，可以在对象被回收之前做一些操作）</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul><li>标记清除算法（标记为垃圾后，直接删除）</li><li>复制算法 （开辟两块空间，直接将为被回收的部分复制到另一部分的空间内）</li><li>标记整理算法 （先标记，之后移动，使得内存空间干净）</li><li>分代收集算法 （分为年轻代和老年代，分别使用不同的算法，新生代用复制算法， 老年代用标记整理算法）</li></ul><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><ul><li>Serial （单线程）<blockquote><p>单线程回收垃圾，回收的时候需要暂停其它的一切线程</p></blockquote></li><li>Parnew （多线程）<blockquote><p>对Serial的升级，其它不变，就是变成多线程</p></blockquote></li><li>Parallel Scavenge （多线程）<blockquote><p>提升吞吐量（程序运行时间/CPU使用时间），<strong>提高回收次数，减少回收时间</strong></p></blockquote></li><li>CMS （真正意义上的多线程）<ul><li>标记清除算法</li><li>过程<ol><li>初始标记 （暂停所有线程，标记Gc Root相连的对象）</li><li>并发标记 （进行可达性分析，标记一系列回收对象）</li><li>重新标记 （修正并发标记期间用户的修改）</li><li>并发清除 （开始清理）</li></ol></li><li>缺点<ul><li>对CPU资源敏感</li><li>无法清理浮动垃圾</li><li>有太多的空间碎片</li></ul></li></ul></li><li>G1 （多线程，不区分新生代和老年代）<ul><li>预览图<br><img src="https://c1.staticflickr.com/5/4678/40093686972_25da5b859f_z.jpg" alt="region"></li><li>分区 Region （G1对内存的使用以分区(Region)为单位，而对对象的分配则以卡片(Card)为单位。）<blockquote><p>不区分老年代和年轻代都会直接被划分成Region，每个Region还会被细分为若干个大小为512 Byte的Card，卡片还会记录在全局卡片表(Global Card Table)中.<br>不同卡中的对象可能会互相引用，还可能是跨域Region引用，如果存在的话会直接<strong>写屏障（并发标记阶段）</strong></p></blockquote></li><li>分区模型<ul><li>预览图<br>  <img src="https://c1.staticflickr.com/5/4619/40093686872_ce639c1121_z.jpg" alt=""></li><li>巨型对象 Humongous Region<br>  由于太大会导致分区出现问题，因此直接在老年代中分配空间</li><li>已记忆集合 Remember Set (RSet)  （存在于Region中）<ul><li>记录引用分区内对象的卡片索引</li><li>内部使用Per Region Table (PRT) 记录使用引用的情况（稀少，细粒度，粗粒度）<ul><li>稀少 （记录到卡）</li><li>细粒度 （记录到region）</li><li>粗粒度 （记录到引用的数目）</li></ul></li></ul></li><li>过程<ol><li>初始标记 （GC Root的标记）</li><li>并发标记 （三色标记法开始）</li><li>最终标记 （三色标记的最终标记）</li><li>筛选回收 （复制清除算法）</li></ol></li><li>三色标记<ul><li>white （不可达回收）</li><li>grey （子对象还未扫描完）</li><li>black （gc root）</li></ul></li><li>STAB<blockquote><p>本质是上对对象的一次快照，快照的内容就是查看对象的颜色（三色标记）以维持并发的效率。</p></blockquote></li></ul></li></ul></li></ul><h3 id="Jvm什么时候发生full-gc"><a href="#Jvm什么时候发生full-gc" class="headerlink" title="Jvm什么时候发生full gc"></a>Jvm什么时候发生full gc</h3><ol><li>永久代满的时候</li><li>老年代空间不足</li></ol><h3 id="双清委派模型"><a href="#双清委派模型" class="headerlink" title="双清委派模型"></a>双清委派模型</h3><p><img src="https://i.loli.net/2020/07/14/TGzqAd9XPJBQ1xN.jpg" alt="双亲委派模型.jpg"></p><blockquote><p>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。<br>而有了双亲委派模型，黑客自定义的java.lang.String类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的java.lang.String类，最终自定义的类加载器无法加载java.lang.String类</p></blockquote><h4 id="双亲委派模型的破坏-借鉴CSDN博主的文章说的很完整了"><a href="#双亲委派模型的破坏-借鉴CSDN博主的文章说的很完整了" class="headerlink" title="双亲委派模型的破坏 (借鉴CSDN博主的文章说的很完整了)"></a>双亲委派模型的破坏 (借鉴CSDN博主的文章说的很完整了)</h4><blockquote><p>原生的JDBC中Driver驱动本身只是一个接口，并没有具体的实现，具体的实现是由不同数据库类型去实现的。例如，MySQL的mysql-connector-.jar中的Driver类具体实现的。 原生的JDBC中的类是放在rt.jar包的，是由启动类加载器进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而mysql-connector-.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由应用程序启动类去进行类加载。于是乎，这个时候就引入线程上下文件类加载器(Thread Context ClassLoader)。有了这个东西之后，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了。<br>————————————————<br>版权声明：本文为CSDN博主「Jack老师」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/luoyang_java/article/details/92598142" target="_blank" rel="noopener">https://blog.csdn.net/luoyang_java/article/details/92598142</a></p></blockquote><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://blog.csdn.net/zhaocuit/article/details/93038538" target="_blank" rel="noopener">https://blog.csdn.net/zhaocuit/article/details/93038538</a></li><li><a href="https://blog.csdn.net/qq_34402394/article/details/72793119" target="_blank" rel="noopener">https://blog.csdn.net/qq_34402394/article/details/72793119</a></li><li><a href="https://www.cnblogs.com/bigbaby/p/12348973.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigbaby/p/12348973.html</a></li><li><a href="https://blog.csdn.net/fedorafrog/article/details/104503829/" target="_blank" rel="noopener">https://blog.csdn.net/fedorafrog/article/details/104503829/</a></li><li><a href="https://blog.csdn.net/luoyang_java/article/details/92598142" target="_blank" rel="noopener">https://blog.csdn.net/luoyang_java/article/details/92598142</a></li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="jvm" scheme="http://runindark.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Mysql复习总结</title>
    <link href="http://runindark.com/2020/06/28/2020%E7%A7%8B%E6%8B%9B/mysql/"/>
    <id>http://runindark.com/2020/06/28/2020秋招/mysql/</id>
    <published>2020-06-28T01:50:52.410Z</published>
    <updated>2020-07-14T10:06:54.514Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="数据库特性"><a href="#数据库特性" class="headerlink" title="数据库特性"></a>数据库特性</h3><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote><p>所谓原子性就是事务的执行，要么全部成功，要么全部失败。</p></blockquote><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><blockquote><p>事务操作的完整性约束不会破坏，是原子性的一种表现，例如A向B转账，不会发生A金额发生变化，但是B金额不会发生变化的情况</p></blockquote><h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><blockquote><p>事务之间的操作是互相隔离的，且不受彼此的影响</p></blockquote><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><blockquote><p>事务完成后，所有数据保存在数据库中，持久存在，且不能回滚。</p></blockquote></li></ul><h3 id="Mysql事务所存在的问题"><a href="#Mysql事务所存在的问题" class="headerlink" title="Mysql事务所存在的问题"></a>Mysql事务所存在的问题</h3><ul><li>脏读 （Select没有规矩）<blockquote><p>事务A插入了一条数据，但是还没有提交，结果事务B去读取数据表，发现了数据A要插入的数据，就是脏读</p></blockquote></li><li>不可重复读 （Update没有规矩）<blockquote><p>事务A首次读某条数据为a，但是事务b此时更新了该条数据为b，结果A再次读取这条数据的时候就变成了b，就是不可重复读</p></blockquote></li><li>幻读 （insert，delete没有规矩）<blockquote><p>事务A读取了数据表，事务B又插入了几条数据，当事务A再次读取数据表的时候，发现数据多了几条，就是幻读</p></blockquote></li></ul><h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><ul><li>未提交读<blockquote><p>事务之间可以读取到事务未提交的数据 （完美的符合了上面出现的所有问题）</p></blockquote></li><li>提交读<blockquote><p>事务必须提交之后，提交的数据才可以被其它的事务所看到。</p></blockquote></li><li>可重复读<blockquote><p>悲观锁读，若一个事务A读取该条数据，那么不管其它的事务如何去更改这条数据，那么事务A依然读取到的是第一次读取到的数据。</p></blockquote></li><li>串行化<blockquote><p>事务操作一个一个按照顺序来，慢是最大的问题</p></blockquote></li></ul><h3 id="Mysql中的log"><a href="#Mysql中的log" class="headerlink" title="Mysql中的log"></a>Mysql中的log</h3><ul><li>bin log<blockquote><p>记录数据库的变更操作，例如delete，insert，update等操作，不会记录select，用于数据的恢复和复制，<br>记录形式为 一些sql语句还有一些事务id等内容</p></blockquote></li><li>redo log<br><img src="https://i.loli.net/2020/07/14/cwz8epYn4Q2gxTu.jpg" alt="redolog.jpg"><blockquote><p>数据的读取或者说是修改操作，是先找到页，再读到内存，如果发生修改，读到内存后，还没来得及刷到磁盘，数据库gg了，那么数据容易丢失，但是redo log会记录页的变更内容，那么恢复数据库的话，就不会丢失数据了。</p></blockquote></li><li>undo log<blockquote><p>和redo log相反，在读到内存的时候，undo log还会记录相反的内容，比如redo是insert那么undo就是要记录delete的操作，记录的和binlog一样，属于逻辑变化</p></blockquote></li></ul><h4 id="bin-log-VS-redo-log"><a href="#bin-log-VS-redo-log" class="headerlink" title="bin log VS redo log"></a>bin log VS redo log</h4><ul><li>binlog记录的是sql的语句等内容，redolog记录的则是XX页在XX行改了XX数据</li><li>binlog存在于所有的数据库系统，redo则是innodb的独家内容</li><li>redolog 和 binlog 必须数据都一致才算是正常，要不然都会回滚</li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><blockquote><p>多版本并发控制，其实就是为每一条数据都填设一个版本号，因此提交读和重复读所读取的数据都是其中的快照读的一种</p></blockquote><h3 id="ACID如何被保证的"><a href="#ACID如何被保证的" class="headerlink" title="ACID如何被保证的"></a>ACID如何被保证的</h3><ul><li>原子性如何保证<blockquote><p>如果事务失败则使用undolog进行会滚</p></blockquote></li><li>隔离性如何保证<blockquote><p>MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据。 =&gt; 也就是快照读</p></blockquote></li><li>持久性如何保证<blockquote><p>redolog用于保证其持久性</p></blockquote><h3 id="存储引擎-（Innodb-和-MyISAM）"><a href="#存储引擎-（Innodb-和-MyISAM）" class="headerlink" title="存储引擎 （Innodb 和 MyISAM）"></a>存储引擎 （Innodb 和 MyISAM）</h3></li><li>InnoDB支持事务，但是MyISAM不支持事务</li><li>InnoDB支持外键，但是MyISAM不支持外键</li><li>InnoDB是行级锁，但是MyISAM是表级锁</li><li>InnoDB是聚集索引（数据文件和索引是绑定的，也就是说，先查到索引，之后才可以查到数据），但是MyISAM是非聚集索引（也就是说数据和索引是相互分开的，索引直接链接着数据的地址）<br>(换句话说：InnoDB下，索引就真的是索引，辅助索引则是数据的指针;但是MyISAM的主索引和辅助索引则都是数据指针)</li><li>InnoDB不支持全文搜索，但是MyISAM则支持全文搜索 （！mysql5.7之后innoDB也是可以支持全文搜索的）</li><li>面试考的比较少了，但是可以看看<ul><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描，而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可</li><li>MyISAM表格可以被压缩后进行查询操作</li></ul></li></ul><h3 id="InnoDB的自适应hash算法-Adaptive-Hash-Index-AHI"><a href="#InnoDB的自适应hash算法-Adaptive-Hash-Index-AHI" class="headerlink" title="InnoDB的自适应hash算法((Adaptive Hash Index, AHI))"></a>InnoDB的自适应hash算法((Adaptive Hash Index, AHI))</h3><blockquote><p>InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引<br>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引</p></blockquote><h4 id="InnoDB为什么推荐使用自增ID作为主键？"><a href="#InnoDB为什么推荐使用自增ID作为主键？" class="headerlink" title="InnoDB为什么推荐使用自增ID作为主键？"></a>InnoDB为什么推荐使用自增ID作为主键？</h4><blockquote><p>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p></blockquote><h3 id="数据结构-查找树，红黑树，b树和b-树"><a href="#数据结构-查找树，红黑树，b树和b-树" class="headerlink" title="数据结构 - 查找树，红黑树，b树和b+树"></a>数据结构 - 查找树，红黑树，b树和b+树</h3><blockquote><p>查找树是不平衡的，举个例子来说，如果是插入（1，2，3，4，5），那么数据查找在查找树中会全部在一边，构成一个链表<br>红黑树是平衡的，但是红黑树是一颗二叉树，深度问题还是没有解决<br>b树在一定程度上其实已经解决了前两个的问题，简单的说就是：多叉的平衡树;但是b+树需要指定叶子节点的最大值，因此是无法也不能更好的始应数据库的需求<br>b+树是b树的升级版，b+树的<strong>非叶子节点只存储数据索引</strong>，且从左向右也是从小到大的排列，这样就可以更多的让索引存储，之后在<strong>叶子节点才是真正的数据部分</strong>，且每个叶子节点的最后会是指针指向旁边的叶子节点<br><img src="https://pic2.zhimg.com/80/v2-9644d1a1f83d3e45da779f2e63c35d55_1440w.jpg" alt=""></p></blockquote><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul><li>普通索引<blockquote><p>就是最基本的添加一个索引，用于加速查找</p></blockquote></li><li>唯一索引<blockquote><p>列值必须唯一，可以为空值，加速查找</p></blockquote></li><li>主键索引<blockquote><p>利用主键作为索引，而且不可以为空，加速查找</p></blockquote></li><li>覆盖索引<blockquote><p>就是查查找的数据也是索引值</p></blockquote></li><li>组合索引<blockquote><p>几列合并成一个索引，但是遵循最左原则</p></blockquote></li><li>全文索引<blockquote><p>全文分词查找，innoDB是做不到的，需要第三方，比如es等</p></blockquote><h4 id="索引带来的问题"><a href="#索引带来的问题" class="headerlink" title="索引带来的问题"></a>索引带来的问题</h4><blockquote><p>使用索引的时候不可以随便使用，过度的使用索引会导致消耗大量的资源，热点核心业务的数据应该多使用索引<br>索引会浪费磁盘空间，不要创建非必要的索引,插入、更新、删除需要维护索引，带来额外的开销,索引过多，修改表的时候重构索引性能差<br>但是索引使用的时候可以减少查询次数，提高效率</p></blockquote></li></ul><h3 id="查询的顺序"><a href="#查询的顺序" class="headerlink" title="查询的顺序"></a>查询的顺序</h3><ol><li>from 从哪个表查询</li><li>where 初步过滤条件</li><li>group by 过滤后进行分组[重点]</li><li>having 对分组后的数据进行二次过滤[重点]</li><li>select 查看哪些结果字段</li><li>order by 按照怎样的顺序进行排序返回[重点]</li></ol><h3 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式"></a>数据库设计三范式</h3><ol><li>1NF : 原子性 字段不可再分,否则就不是关系数据库</li><li>2NF : 唯一性 每一个主键是唯一的</li><li>3NF : 要求一个数据库表中不包含已在其他表中已包含的非主关键字信息， 例如 存在一个课程表，课程表中有课程号(Cno),课程名(Cname),学分(Ccredit)，那么在学生信息表中就没必要再把课程名，学分再存储到学生表中，这样会造成数据的冗余</li></ol><h3 id="参考文章链接"><a href="#参考文章链接" class="headerlink" title="参考文章链接"></a>参考文章链接</h3><ul><li>InnoDB与MyISAM  <a href="https://blog.csdn.net/qq_35642036/article/details/82820178" target="_blank" rel="noopener">https://blog.csdn.net/qq_35642036/article/details/82820178</a></li><li>敖丙  <a href="https://mp.weixin.qq.com/s/Lx4TNPLQzYaknR7D3gmOmQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Lx4TNPLQzYaknR7D3gmOmQ</a></li><li>三范式 <a href="https://blog.csdn.net/qq_43079376/article/details/93647335" target="_blank" rel="noopener">https://blog.csdn.net/qq_43079376/article/details/93647335</a></li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="秋招面试" scheme="http://runindark.com/categories/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://runindark.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="mysql" scheme="http://runindark.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《天净沙·我·二面知识点总结》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/22/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-%E4%BA%8C%E9%9D%A2%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://runindark.com/2020/03/22/2020春招/我为阿里-二面知识点/</id>
    <published>2020-03-22T03:12:52.385Z</published>
    <updated>2020-06-28T01:43:26.137Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><blockquote><p>布隆过滤器主要是针对大量数据的一个预判，可以给出两种结果，1.一定不存在 2. 可能存在的<br>布隆过滤器使用多个映射的hash函数将一个数据直接映射到一个bit数组上，当进行插入的时候，n个映射函数的值会直接到达布隆过滤器的索引位置，并且设置树脂为1，因此如果发生hash碰撞会发生，某个数组的位置多次为1，情况，因此会得出可能存在的结论，但是如果查找的时候，n个hash函数有任意一位过滤的数组值为不为1，那么则一定不存在。</p></blockquote><h2 id="秒杀系统中为什么会产生超卖的现象？"><a href="#秒杀系统中为什么会产生超卖的现象？" class="headerlink" title="秒杀系统中为什么会产生超卖的现象？"></a>秒杀系统中为什么会产生超卖的现象？</h2><blockquote><p>由于使用mysql的时候数据库本身的存储引擎innodb是改操作是排他锁，但是读的操作是不上锁的，当到达最后一个的时候，如果都查到还剩下一个，那么其它的请求过来都会同时的更改数据库，那么就会造成超卖，也是快照读的一个弊病。</p></blockquote><h3 id="怎么解决超卖现象？"><a href="#怎么解决超卖现象？" class="headerlink" title="怎么解决超卖现象？"></a>怎么解决超卖现象？</h3><blockquote><p>最简单的思路，就是每次在sql语句中，更改的时候，在where的时候设条件大于0，但是这样子一旦超过数据库的承受能力，还是会超读<br>每次的读操作都上排他锁，这样子可以避免这个现象，但是会导致性能大幅度降低<br>使用redis是最好的方法，可以把要秒杀的内容放到redis的队列中，使用一次则删除一次</p></blockquote><h4 id="细致深入：Redis实现秒杀系统"><a href="#细致深入：Redis实现秒杀系统" class="headerlink" title="细致深入：Redis实现秒杀系统"></a>细致深入：Redis实现秒杀系统</h4><blockquote><p>核心redis的操作命令，sextnx（细粒度上锁） + expire（强制锁释放）</p><ol><li>首先需要将秒杀的数据放到一个redis中，然后在操作redis的时候可以用setnx去操作数据，所谓细粒度锁是一个抽象概念，sexnx就是具体实现（其实更加直白的理解一些，普通的get/put是一个原子操作,但是一系列操作就不再是原子性的了，setnx是一个原子操作，所以可以作为一个细粒度锁）</li><li>更加直接的来，就是将数据都加入到redis的list中，然后使用Lpop命令不断获取就ok（移除并返回列表的第一个元素）</li></ol></blockquote><h2 id="Redis深入"><a href="#Redis深入" class="headerlink" title="Redis深入"></a>Redis深入</h2><h3 id="redis能用的的加锁命令分表是INCR、SETNX、SET"><a href="#redis能用的的加锁命令分表是INCR、SETNX、SET" class="headerlink" title="redis能用的的加锁命令分表是INCR、SETNX、SET"></a>redis能用的的加锁命令分表是INCR、SETNX、SET</h3><blockquote><p>redis所有的单独的命令都是原子的</p></blockquote><h4 id="INCR"><a href="#INCR" class="headerlink" title="INCR"></a>INCR</h4><blockquote><p>这种加锁的思路是， key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作进行加一。然后其它用户在执行 INCR 操作进行加一时，如果返回的数大于 1 ，说明这个锁正在被使用当中。</p></blockquote><h4 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h4><blockquote><p>这种加锁的思路是，如果 key 不存在，将 key 设置为 value如果 key 已存在，则 SETNX 不做任何动作</p></blockquote><h4 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h4><blockquote><p>借助 Expire 来设置就不是原子性操作了。所以还可以通过事务来确保原子性，但是还是有些问题，所以官方就引用了另外一个，使用 SET 命令本身已经从版本 2.6.12 开始包含了设置过期时间的功能</p></blockquote><h4 id="上锁可能出现的问题"><a href="#上锁可能出现的问题" class="headerlink" title="上锁可能出现的问题"></a>上锁可能出现的问题</h4><h5 id="1、-redis发现锁失败了要怎么办？中断请求还是循环请求？"><a href="#1、-redis发现锁失败了要怎么办？中断请求还是循环请求？" class="headerlink" title="1、 redis发现锁失败了要怎么办？中断请求还是循环请求？"></a>1、 redis发现锁失败了要怎么办？中断请求还是循环请求？</h5><blockquote><p>可以利用循环进行重复请求</p></blockquote><h5 id="2、-循环请求的话，如果有一个获取了锁，其它的在去获取锁的时候，是不是容易发生抢锁的可能？"><a href="#2、-循环请求的话，如果有一个获取了锁，其它的在去获取锁的时候，是不是容易发生抢锁的可能？" class="headerlink" title="2、 循环请求的话，如果有一个获取了锁，其它的在去获取锁的时候，是不是容易发生抢锁的可能？"></a>2、 循环请求的话，如果有一个获取了锁，其它的在去获取锁的时候，是不是容易发生抢锁的可能？</h5><blockquote><p>循环的时候可以sleep一下</p></blockquote><h5 id="3、-锁提前过期后，客户端A还没执行完，然后客户端B获取到了锁，这时候客户端A执行完了，会不会在删锁的时候把B的锁给删掉？"><a href="#3、-锁提前过期后，客户端A还没执行完，然后客户端B获取到了锁，这时候客户端A执行完了，会不会在删锁的时候把B的锁给删掉？" class="headerlink" title="3、 锁提前过期后，客户端A还没执行完，然后客户端B获取到了锁，这时候客户端A执行完了，会不会在删锁的时候把B的锁给删掉？"></a>3、 锁提前过期后，客户端A还没执行完，然后客户端B获取到了锁，这时候客户端A执行完了，会不会在删锁的时候把B的锁给删掉？</h5><blockquote><p>不一定，可以借助key-value的value进行判断</p></blockquote><h5 id="锁续约问题"><a href="#锁续约问题" class="headerlink" title="锁续约问题"></a>锁续约问题</h5><blockquote><p><strong>Redission</strong><br>当成功的获取一个锁的时候，就会产生一个 watch dog 进行锁续期，每10秒去检查一次，然后重置成设定的过期时间<br>加锁机制是lua脚本<br>解锁过程就比较简单了，如果是程序计数器则继续进行-1，直到等于0，然后删除该key即可（unlock操作）</p></blockquote><h5 id="Lua原子性"><a href="#Lua原子性" class="headerlink" title="Lua原子性"></a>Lua原子性</h5><blockquote><p>Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行： 当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 这和使用 MULTI / EXEC 包围的事务很类似。 在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed)</p></blockquote><h2 id="了解java内存模型吗，JVM整体和并发的一些关系"><a href="#了解java内存模型吗，JVM整体和并发的一些关系" class="headerlink" title="了解java内存模型吗，JVM整体和并发的一些关系"></a>了解java内存模型吗，JVM整体和并发的一些关系</h2><blockquote><p>Java内存模型就是定义程序中变量（静态变量、数组对象元素等，不包括局部变量、方法参数）的访问规则</p></blockquote><h3 id="内存模型操作的八个指令"><a href="#内存模型操作的八个指令" class="headerlink" title="内存模型操作的八个指令"></a>内存模型操作的八个指令</h3><p><a href="https://www.cnblogs.com/zzq6032010/p/10328399.html" target="_blank" rel="noopener">博客原文</a></p><ul><li><p>lock：作用于主内存变量，将该变量标识为一个线程独占的状态</p></li><li><p>unlock：作用于主内存变量，将独占状态释放</p></li><li><p>read：作用于主内存变量，将值拷贝到工作内存中</p></li><li><p>load：作用于工作内存中的变量，将值放到工作内存中的变量副本中</p></li><li><p>use：作用于工作内存中的变量，将值传给执行引擎</p></li><li><p>asign：作用于工作内存中的变量，将执行引擎中的值赋给工作内存中的变量</p></li><li><p>store：作用于工作内存中的变量，将值传给主内存</p></li><li><p>write：作用于主内存中的变量，将工作内存中返回的值放到主内存变量中</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><blockquote><p>保证load与use必须相邻调用，即要use这个变量，必定先执行read/load，这样每次都能获取到最新的变量值；它又保证asign与store必须相邻调用，即在工作内存中将该变量改了之后，必定会先同步到主内存中</p></blockquote></li></ul><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><blockquote><p>是一个双向的链表，概念上的队列，但不是真正的实现也是队列</p></blockquote><h3 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h3><blockquote><p>是根据condition创建出来的队列，上锁后可以负责对线程的监视，比synchronized的监视器更加灵活，是一个单向的链表，当唤醒界节点的时候会直接添加到阻塞队列中</p></blockquote><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><h4 id="1-waitstatus"><a href="#1-waitstatus" class="headerlink" title="1. waitstatus"></a>1. waitstatus</h4><ol><li><p>CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</p></li><li><p>SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。</p></li><li><p>CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</p></li><li><p>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态</p><h4 id="2-prev"><a href="#2-prev" class="headerlink" title="2. prev"></a>2. prev</h4><blockquote><p>前驱节点</p></blockquote><h4 id="3-next"><a href="#3-next" class="headerlink" title="3. next"></a>3. next</h4><blockquote><p>后继节点</p></blockquote><h4 id="4-thread"><a href="#4-thread" class="headerlink" title="4. thread"></a>4. thread</h4><blockquote><p>thread 同步线程队列主要存储的线程信息。</p></blockquote><h4 id="5-nextwaiter"><a href="#5-nextwaiter" class="headerlink" title="5. nextwaiter"></a>5. nextwaiter</h4><p>AQS中阻塞队列采用的是用双向链表保存，用prve和next相互链接。而AQS中条件队列是使用单向列表保存的，用<br>nextWaiter来连接。阻塞队列和条件队列并不是使用的相同的数据结构</p></li></ol><p><a href="https://segmentfault.com/a/1190000015804888" target="_blank" rel="noopener">精髓原帖</a></p><p>在Node节点的源码中有两个常量属性</p><pre><code class="java"><span class="comment">// 共享模式</span><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();<span class="comment">// 独占模式</span><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;<span class="comment">// 其他模式</span><span class="comment">// 其他非空值：条件等待节点（调用Condition的await方法的时候）</span></code></pre><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><blockquote><p>Channel(通道)，Buffer(缓冲区), Selector</p></blockquote><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><blockquote><p>通道是双向的，通过一个Channel既可以进行读，也可以进行写</p></blockquote><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><ul><li><p>capacity:缓冲区数组的总长度</p></li><li><p>position:下一个要操作的数据元素的位置</p></li><li><p>limit:缓冲区数组中不可操作的下一个元素的位置：limit&lt;=capacity</p></li><li><p>mark:用于记录当前position的前一个位置或者默认是-1</p></li></ul><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><blockquote><p>Selector类是NIO的核心类，Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理</p></blockquote><h2 id="http-和-https"><a href="#http-和-https" class="headerlink" title="http 和 https"></a>http 和 https</h2><p>HTTPS和HTTP的主要区别</p><ul><li><p>https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</p></li><li><p>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。</p></li><li><p>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p></li><li><p>http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</p></li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·蘑菇街总结》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/18/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-%E8%98%91%E8%8F%87%E8%A1%97%E6%80%BB%E7%BB%93/"/>
    <id>http://runindark.com/2020/03/18/2020春招/我为阿里-蘑菇街总结/</id>
    <published>2020-03-18T14:23:17.382Z</published>
    <updated>2020-06-28T01:43:26.137Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>2020-03-18 蘑菇街一面 是凉凉了 但是很高兴的是面试官真的很耐心 自己也发现了很多的问题和不足<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h4 id="动态代理的两种方法"><a href="#动态代理的两种方法" class="headerlink" title="动态代理的两种方法"></a>动态代理的两种方法</h4><h5 id="Proxy-InvocationHandler"><a href="#Proxy-InvocationHandler" class="headerlink" title="Proxy + InvocationHandler"></a>Proxy + InvocationHandler</h5><p>被代理对象接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被代理类接口实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add user into database."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        System.out.println(<span class="string">"getUser from database."</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代理（中间）类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtil</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;    <span class="comment">// 被代理的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do sth before...."</span>);</span><br><span class="line">        Object result =  method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"do sth after...."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ProxyUtil(Object target)&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object proxyedObject = <span class="keyword">new</span> UserServiceImpl();    <span class="comment">// 被代理的对象</span></span><br><span class="line">        ProxyUtil proxyUtils = <span class="keyword">new</span> ProxyUtil(proxyedObject);</span><br><span class="line">        <span class="comment">// 生成代理对象，对被代理对象的这些接口进行代理：UserServiceImpl.class.getInterfaces()</span></span><br><span class="line">        UserService proxyObject = (UserService) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), </span><br><span class="line">                    UserServiceImpl.class.getInterfaces(), proxyUtils);</span><br><span class="line">        proxyObject.getUser(<span class="number">1</span>);</span><br><span class="line">        proxyObject.addUser(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>核心则在于被代理的对象必须要有含有自己方法的接口，才可以使用Proxy+InvocationHandler，同时，代理类中主要是通过调用被重写的invoke（）方法。</p></blockquote><h5 id="CGlib"><a href="#CGlib" class="headerlink" title="CGlib"></a>CGlib</h5><p>Cglib代理的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;    <span class="comment">// 被代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method arg1, Object[] arg2, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do sth before...."</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(arg0, arg2);</span><br><span class="line">        System.out.println(<span class="string">"do sth after...."</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());    <span class="comment">// 设置父类</span></span><br><span class="line">        <span class="comment">// 设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);    <span class="comment">// 在调用父类方法时，回调 this.intercept()</span></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object proxyedObject = <span class="keyword">new</span> UserServiceImpl();    <span class="comment">// 被代理的对象</span></span><br><span class="line">        CGProxy cgProxy = <span class="keyword">new</span> CGProxy(proxyedObject);</span><br><span class="line">        UserService proxyObject = (UserService) cgProxy.getProxyObject();</span><br><span class="line">        proxyObject.getUser(<span class="number">1</span>);</span><br><span class="line">        proxyObject.addUser(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>与Proxy+InvocationHandler不同，Cglib是利用enhancer.create创造了一个代理对象，而这个大力对象的父类就是被代理类，利用enhancer.setSuperclass()指定，同时利用enhancer.setCallback()回调被重写的intercept，完成对方法的包裹</p></blockquote><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><h3 id="聚合索引-和-非聚合索引"><a href="#聚合索引-和-非聚合索引" class="headerlink" title="聚合索引 和 非聚合索引"></a>聚合索引 和 非聚合索引</h3><blockquote><p>聚合索引是 数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。<br>非聚合索引是 该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引<br>言外之意，索引是有序的，如果存储数据和索引一样有序就是聚合索引，非聚合索引就是数据不是和索引本身一样有序</p></blockquote><h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><blockquote><p>数据和索引放在一起就是聚簇索引<br>地址和索引在一起，数据是通过地址再关联在一起是非聚簇索引</p></blockquote><h3 id="主索引，辅助索引"><a href="#主索引，辅助索引" class="headerlink" title="主索引，辅助索引"></a>主索引，辅助索引</h3><h3 id="聚合索引状态下"><a href="#聚合索引状态下" class="headerlink" title="聚合索引状态下"></a>聚合索引状态下</h3><blockquote><p>就是根据主键值建立的索引就是主索引<br>辅助索引又叫二级索引，他的索引存主键的值</p></blockquote><h3 id="非聚合索引状态下"><a href="#非聚合索引状态下" class="headerlink" title="非聚合索引状态下"></a>非聚合索引状态下</h3><blockquote><p>非聚簇索引的主索引和辅助索引的叶子节点的data都是存储的数据的物理地址，也就是说索引和数据并不是存储在一起的，数据的顺序和索引的顺序并没有任何关系，也就是索引顺序与数据物理排列顺序无关。</p></blockquote><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><h4 id="插入缓存"><a href="#插入缓存" class="headerlink" title="插入缓存"></a>插入缓存</h4><ol><li>正常情况下正常的插入速度很快</li><li>但是如果使用UUID的话，需要离散的先访问非聚集索引索引页，判断非索引也是否在缓冲池中，若在，则直接插入，若没在则放入Insert Buffer中，在Insert Buffer 中合并后插入到索引页，提高了插入性能<h3 id="索引失效问题"><a href="#索引失效问题" class="headerlink" title="索引失效问题"></a>索引失效问题</h3></li></ol><h4 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4><blockquote><p>如果组合索引是abc那么用where a或者where a，b 或者where abc都可以，但是如果用 where b这样子的跳跃会导致索引失效</p></blockquote><h4 id="前导模糊系列"><a href="#前导模糊系列" class="headerlink" title="前导模糊系列"></a>前导模糊系列</h4><blockquote><p>例：(like ‘%XX’或者like ‘%XX%’)</p></blockquote><h4 id="or失效"><a href="#or失效" class="headerlink" title="or失效"></a>or失效</h4><blockquote><p>使用 or 的时候会导致索引失效，可以改用union</p></blockquote><h4 id="判断null"><a href="#判断null" class="headerlink" title="判断null"></a>判断null</h4><blockquote><p>索引是b+树的排序结构，如果是null的话，导致节点不知道应该放在哪里</p></blockquote><h4 id="where-子句中使用-或-lt-gt-操作符"><a href="#where-子句中使用-或-lt-gt-操作符" class="headerlink" title="where 子句中使用!=或&lt;&gt;操作符"></a>where 子句中使用!=或&lt;&gt;操作符</h4><h4 id="in-和-not-in-也要慎用，"><a href="#in-和-not-in-也要慎用，" class="headerlink" title="in 和 not in 也要慎用，"></a>in 和 not in 也要慎用，</h4><blockquote><p>select id from t where num in(1,2,3)</p></blockquote><h3 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h3><p><a href="https://blog.csdn.net/qq_43079376/article/details/93647335" target="_blank" rel="noopener">原文博客</a></p><h4 id="属性原子性"><a href="#属性原子性" class="headerlink" title="属性原子性"></a>属性原子性</h4><h4 id="行可以唯一识别性"><a href="#行可以唯一识别性" class="headerlink" title="行可以唯一识别性"></a>行可以唯一识别性</h4><h4 id="数据信息不冲突"><a href="#数据信息不冲突" class="headerlink" title="数据信息不冲突"></a>数据信息不冲突</h4><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><ol><li>非主属性依赖主属性</li><li>主属性也要依赖其它的非主属性</li><li>非主属性不能被依赖<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="HashMap根据hashcode查找到对应位置的方法"><a href="#HashMap根据hashcode查找到对应位置的方法" class="headerlink" title="HashMap根据hashcode查找到对应位置的方法"></a>HashMap根据hashcode查找到对应位置的方法</h3><a href="https://blog.csdn.net/v123411739/article/details/78996181" target="_blank" rel="noopener">原帖地址</a></li><li>拿到 key 的 hashCode 值</li><li>将 hashCode 的高位参与运算，重新计算 hash 值</li><li>将计算出来的 hash 值与 (table.length - 1) 进行 &amp; 运算<h3 id="原因解释如下"><a href="#原因解释如下" class="headerlink" title="原因解释如下"></a>原因解释如下</h3><blockquote><p>首先拿到key的hashcode值，如果是并利用  hashcode ^ table.length  (table.length是2次幂)得到hash值，如果是与运算的话，假如table是初始化的16位，那么高位是无法进行运算的，结果值也就是被hashcode值的后四位所决定<br>之后用hash值 进行 hash &amp; (table.length)</p></blockquote><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3>满了以后用调用线程池的线程去执行他<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3>直接拒绝，啥也不干<h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3>报个错，然后直接拒绝，啥也不干<h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3>抛出最先加入使用的线程</li></ol></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;2020-03-18 蘑菇街一面 是凉凉了 但是很高兴的是面试官真的很耐心 自己也发现了很多的问题和不足&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·被字节血洗篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/16/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-%E5%AD%97%E8%8A%82%E8%A1%80%E6%B4%97/"/>
    <id>http://runindark.com/2020/03/16/2020春招/我为阿里-字节血洗/</id>
    <published>2020-03-16T13:15:03.321Z</published>
    <updated>2020-06-28T01:43:26.137Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br>总结了3.15日字节面试的一些问题，鲜血淋漓篇<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="高并发-为什么Synchronized可以保证线程的安全？"><a href="#高并发-为什么Synchronized可以保证线程的安全？" class="headerlink" title="高并发 - 为什么Synchronized可以保证线程的安全？"></a>高并发 - 为什么Synchronized可以保证线程的安全？</h2><p><a href="https://www.jianshu.com/p/7ddb0956590c" target="_blank" rel="noopener">博客参考</a></p><blockquote><p>JVM中对于同步方法和同步代码块是不一样的，本质上都有monitor对象，但是同步方法使用了monitorentre/monitorexit，而同步代码块则使用了ACC_SYNCHRONIZED标志（隐式）</p></blockquote><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><blockquote><p>Java中在JVM的处理上，每一个对象都会有一个对象头，monitor 存在于对象头的Mark Word 中(存储monitor引用指针)</p></blockquote><h3 id="Jvm对同步方法的处理（monitorenter-monitorexit）"><a href="#Jvm对同步方法的处理（monitorenter-monitorexit）" class="headerlink" title="Jvm对同步方法的处理（monitorenter/monitorexit）"></a>Jvm对同步方法的处理（monitorenter/monitorexit）</h3><h4 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h4><blockquote><ol><li>首先一个对象要有自己的monitor，当对象的monitor被占用的时候，则monitor被锁定，之后当一个线程需要获取该对象的时候，则需要调用monitorexit指令，首先要判断monitor的进入数，如果进入数为0，那么monitorenter进入成功，线程进入monitor，然后将进入数设为1，该线程则成为monitor的所有者。</li><li>如果线程已经占有了monitor，只是重新进入，那么monitor的进入数+1</li><li>如果其它线程在monitor被占领的时候来获取monitor那么，该线程则自动进入到阻塞状态，知道monitor的进入数为0，再重新尝试获取monitor的权限</li></ol></blockquote><h3 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h3><blockquote><ol><li>执行monitorexit必须是该对象monitor的所有者</li><li>monitorexit执行成功的时候，则monitor的进入数-1</li></ol></blockquote><h3 id="Jvm对同步代码块的处理（ACC-SYNCHRONIZED）"><a href="#Jvm对同步代码块的处理（ACC-SYNCHRONIZED）" class="headerlink" title="Jvm对同步代码块的处理（ACC_SYNCHRONIZED）"></a>Jvm对同步代码块的处理（ACC_SYNCHRONIZED）</h3><blockquote><ol><li>对于同步代码块，其常量池多了ACC_SYNCHRONIZED标志，也是flag的地方多了ACC_SYNCHRONIZED</li><li>同步代码块被调用的时候，JVM会调用指令去检查ACC_SYNCHRONIZED是否被设置，如果设置了则获取monitor，获取成功后则执行代码块中的内容，执行期间其它的线程将无法再获得monitor</li></ol></blockquote><h3 id="wait-notify-notifyall"><a href="#wait-notify-notifyall" class="headerlink" title="wait/notify/notifyall"></a>wait/notify/notifyall</h3><blockquote><ol><li>wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因</li><li>要特别理解的一点是，与sleep方法不同的是wait方法调用完成后，线程将被暂停，但wait方法将会释放当前持有的监视器锁(monitor)，直到有线程调用notify/notifyAll方法后方能继续执行，而sleep方法只让线程休眠并不释放锁。同时notify/notifyAll方法调用后，并不会马上释放监视器锁，而是在相应的synchronized(){}/synchronized方法执行结束后才自动释放锁</li></ol></blockquote><h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><ol><li>//中断线程（实例方法）<br>public void Thread.interrupt();</li><li>//判断线程是否被中断（实例方法）<br>public boolean Thread.isInterrupted();</li><li>//判断是否被中断并清除当前中断状态（静态方法）<br>public static boolean Thread.interrupted();</li></ol><h3 id="Interrupt的作用"><a href="#Interrupt的作用" class="headerlink" title="Interrupt的作用"></a>Interrupt的作用</h3><blockquote><p>可以直接中断阻塞的线程，但是<strong>无法阻塞获取锁或者拿到锁的线程</strong></p></blockquote><h2 id="JVM-private-final-a-1-请问他的创建的过程？"><a href="#JVM-private-final-a-1-请问他的创建的过程？" class="headerlink" title="JVM - private final a = 1; 请问他的创建的过程？"></a>JVM - private final a = 1; 请问他的创建的过程？</h2><h3 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h3><ol><li>加载</li><li>验证</li><li>准备<blockquote><p>在准备阶段就直接将将值进行替换，不占用内存空间</p></blockquote></li><li>解析</li><li>初始化</li></ol><h3 id="深入："><a href="#深入：" class="headerlink" title="深入："></a>深入：</h3><blockquote><p>static 静态变量在正常情况下是 在准备阶段在方法区分配空间，但是直到最后的初始化阶段才正确的赋值<br>例： public static int value = 5<br>在准备阶段  value 已在方法区获得空间,但是值为0<br>在最后的初始化阶段才真正的编程 5 </p></blockquote><h3 id="加载，验证阶段的内容补充"><a href="#加载，验证阶段的内容补充" class="headerlink" title="加载，验证阶段的内容补充"></a>加载，验证阶段的内容补充</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><blockquote><p>在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下3件事情： </p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）； </li></ol></blockquote><blockquote><ol start="2"><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； </li></ol></blockquote><blockquote><ol start="3"><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口； </li></ol></blockquote><blockquote><p>加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。 </p></blockquote><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><blockquote><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br>验证阶段大致会完成4个阶段的检验动作： </p></blockquote><blockquote><ol><li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 </li></ol></blockquote><blockquote><ol start="2"><li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 </li></ol></blockquote><blockquote><ol start="3"><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 </li></ol></blockquote><blockquote><ol start="4"><li>符号引用验证：确保解析动作能正确执行。 </li></ol></blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</p><h2 id="JVM-GC回收的时候那些垃圾是怎么被标识的？"><a href="#JVM-GC回收的时候那些垃圾是怎么被标识的？" class="headerlink" title="JVM - GC回收的时候那些垃圾是怎么被标识的？"></a>JVM - GC回收的时候那些垃圾是怎么被标识的？</h2><h3 id="语义双关注意"><a href="#语义双关注意" class="headerlink" title="语义双关注意"></a>语义双关注意</h3><blockquote><p>可能面试官想问的是标记垃圾的方法（可达性分析和程序计数器法）<br>还可能是想问具体是怎么标记的？</p></blockquote><h3 id="相关的内容补充"><a href="#相关的内容补充" class="headerlink" title="相关的内容补充"></a>相关的内容补充</h3><h4 id="OopMap"><a href="#OopMap" class="headerlink" title="OopMap"></a>OopMap</h4><blockquote><p>垃圾回收的时候需要对栈上的内存进行扫描，判断哪些位置存在Reference类型，但是如果是直接查找的话，会产生遍历的问题，这样是慢的。<br>所以HotSpot用OopMap对Reference进行存储，这样子就可以用空间换时间，避免了全栈的扫描</p></blockquote><h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p><strong>并发标记</strong></p><ol><li>黑色：根对象，或者该对象与它的子对象都被扫描过（对象被标记了，且它的所有field也被标记完了）。</li><li>灰色：对象本身被扫描，但还没扫描完该对象中的子对象（它的field还没有被标记或标记完）。</li><li>白色：未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，既垃圾对象（对象没有被标记到）。<h4 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h4>(RememberSet)[<a href="https://img-blog.csdn.net/20170705174843116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGZ6MDMzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center]" target="_blank" rel="noopener">https://img-blog.csdn.net/20170705174843116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGZ6MDMzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center]</a></li></ol><blockquote><p>以G1收集器为例，G1由于将内存空间分配成了Region，因此如果每个Region都去记录自己的对象引用了什么其它的对象，会造成很多不必要的开销，那么如果换个思维只记录自己的新生代被谁的老年代引用了就可以减小开销（因为新生代无论如何都是要被全部扫描的，记录不同Region新生代与新生代之间的引用是没有意义的，同时老年代很少，因此扫描老年代是不是引用其它新生代会更快），如果被记录的话，则直接假如到GcRoot中这样就可以避免一些不必要的扫描。<br>开始说卡表，每个Region被分成了若干个<strong>卡（Card）</strong>，这些<strong>Card</strong>都会记录在全局卡表中，<strong>Card</strong>中每个元素对应着内存区域中一个特定大小的内存块，这个内存块则被称之为<strong>卡页</strong>，一个卡页一般里面不只一个对象，所以卡页存在着跨Region引用，那么这样的元素的值标识为1。<br>这样在Minor GC时，只需要将变脏的Region(写屏障,这个事情是并发标记的时候完成的，直接加入到GcRoot可以提升效率)中的那个卡页加入GC Roots一并扫描即可。比起扫描老年代的所有对象，大大减少了扫描的数据量，提升了效率</p></blockquote><h2 id="TCP-的连接过程（从网络层去分析）"><a href="#TCP-的连接过程（从网络层去分析）" class="headerlink" title="TCP 的连接过程（从网络层去分析）"></a>TCP 的连接过程（从网络层去分析）</h2><blockquote><p>TCP三次握手 四次招手</p></blockquote><h2 id="口述TCP是如何保证数据传输的？"><a href="#口述TCP是如何保证数据传输的？" class="headerlink" title="口述TCP是如何保证数据传输的？"></a>口述TCP是如何保证数据传输的？</h2><h2 id="线程共享的部分"><a href="#线程共享的部分" class="headerlink" title="线程共享的部分"></a>线程共享的部分</h2><ul><li><p>堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）</p></li><li><p>全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的</p></li><li><p>静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的</p></li><li><p>文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。</p></li></ul><h2 id="深入到操作系统线程之间什么什么是独享的资源"><a href="#深入到操作系统线程之间什么什么是独享的资源" class="headerlink" title="深入到操作系统线程之间什么什么是独享的资源"></a>深入到操作系统线程之间什么什么是独享的资源</h2><ul><li>栈 栈是独享的</li><li>寄存器<h2 id="请问只要是加了Synchronized就安全了吗？"><a href="#请问只要是加了Synchronized就安全了吗？" class="headerlink" title="请问只要是加了Synchronized就安全了吗？"></a>请问只要是加了Synchronized就安全了吗？</h2><blockquote><p>静态方法 和 实例方法  的区别</p></blockquote><h2 id="有关List集合的删改功能知道吗？"><a href="#有关List集合的删改功能知道吗？" class="headerlink" title="有关List集合的删改功能知道吗？"></a>有关List集合的删改功能知道吗？</h2><blockquote><p>就是利用System.copy的功能往前或者往后移动一位<br>扩容机制就是利用调用EnsureCapacityInternal()方法去调用grow函数，再使用Arrays.copyOf进行扩容</p></blockquote></li></ul><h2 id="Java-线程池的实现"><a href="#Java-线程池的实现" class="headerlink" title="Java 线程池的实现"></a>Java 线程池的实现</h2><h3 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h3><p><a href="https://baijiahao.baidu.com/s?id=1641469444994560637&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">原帖</a><br>线程池能够对线程进行统一分配，调优和监控：</p><ul><li>降低资源消耗（线程无限制地创建，然后使用完毕后销毁）</li><li>提高响应速度（无须创建线程）</li><li>提高线程的可管理性</li></ul><h3 id="线程的执行过程"><a href="#线程的执行过程" class="headerlink" title="线程的执行过程"></a>线程的执行过程</h3><ol><li>首先添加到核心线程池</li><li>核心线程池满以后，直接进入阻塞队列</li><li>阻塞队列满了以后判断最大核心数</li><li>如果未达到核心线程数目，则线程池进行扩容创建一个Worker执行提交任务，新建的Worker会被添加到线程集合workers中</li><li>如果超过maximumPoolSize会执行拒绝策略<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4></li><li>调用线程执行 ： 就是调用其它的线程</li><li>终止执行： 直接抛出RejectExecutionException异常</li><li>丢弃任务： 直接丢弃，不会抛异常</li><li>丢失老任务： 删除等待队列中最老的任务，然后重新执行</li></ol><h2 id="Mybatis缓存"><a href="#Mybatis缓存" class="headerlink" title="Mybatis缓存"></a>Mybatis缓存</h2></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;总结了3.15日字节面试的一些问题，鲜血淋漓篇&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·Redis篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/14/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-Redis/"/>
    <id>http://runindark.com/2020/03/14/2020春招/我为阿里-Redis/</id>
    <published>2020-03-14T09:58:51.001Z</published>
    <updated>2020-06-28T01:43:26.138Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="来来来，讲一讲为什么Redis这么快？"><a href="#来来来，讲一讲为什么Redis这么快？" class="headerlink" title="来来来，讲一讲为什么Redis这么快？"></a>来来来，讲一讲为什么Redis这么快？</h2><blockquote><p>首先，采用了多路复用io阻塞机制<br>然后，数据结构简单，操作节省时间<br>最后，运行在内存中，自然速度快</p></blockquote><h3 id="Redis为什么是单线程的？"><a href="#Redis为什么是单线程的？" class="headerlink" title="Redis为什么是单线程的？"></a>Redis为什么是单线程的？</h3><blockquote><p>Redis的瓶颈不是cpu的运行速度，而往往是网络带宽和机器的内存大小。再说了，单线程切换开销小，容易实现既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了</p></blockquote><h3 id="如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办"><a href="#如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办" class="headerlink" title="如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办"></a>如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办</h3><blockquote><p>多起几个Redis进程就好了。Redis是keyvalue数据库，又不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。redis-cluster可以帮你做的更好</p></blockquote><h3 id="我们使用单线程的方式是无法发挥多核CPU-性能，有什么办法发挥多核CPU的性能嘛？"><a href="#我们使用单线程的方式是无法发挥多核CPU-性能，有什么办法发挥多核CPU的性能嘛？" class="headerlink" title="我们使用单线程的方式是无法发挥多核CPU 性能，有什么办法发挥多核CPU的性能嘛？"></a>我们使用单线程的方式是无法发挥多核CPU 性能，有什么办法发挥多核CPU的性能嘛？</h3><blockquote><p>我们可以通过在单机开多个Redis</p></blockquote><h2 id="简述一下Redis值的五种类型"><a href="#简述一下Redis值的五种类型" class="headerlink" title="简述一下Redis值的五种类型"></a>简述一下Redis值的五种类型</h2><ul><li>String 整数，浮点数或者字符串</li><li>Set 集合</li><li>Zset 有序集合</li><li>Hash 散列表</li><li>List 列表</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>数据结构 =&gt; SDS<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">//记录当前字节数组的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">//记录了当前字节数组总共分配的内存大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">//记录了当前字节数组的属性、用来标识到底是sdshdr8还是sdshdr16等</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">//保存了字符串真正的值以及末尾的一个\0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><blockquote><ol><li>记录数组的长度，把复杂度从o(n)变成了0(1)</li><li>SDS预分配存储空间的方式来减少内存的频繁分配</li><li>redis不同长度的字符串用不同的数据结构，因此用flag标记当前是什么类型的数据结构</li></ol></blockquote><h4 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h4><p>（sdscat =》给字符串后面再拼接一个字符串）</p><ul><li>当sdscat 之后内存小于 1M，字符串长度*2+1 （’\0’）</li><li>当sdscat 之后内存大于 1M, 字符串长度 + 1M + 1（’\0’） <h4 id="空间懒惰回收"><a href="#空间懒惰回收" class="headerlink" title="空间懒惰回收"></a>空间懒惰回收</h4>如果sdstrim（减少字符串），则不急着回收空间，下次如果需要添加长度，直接使用多余的空间。</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><blockquote><p>结构是双向链表<br>由于数据结构的设计，可以更方便的获取链表长度</p></blockquote><p>链表的数据结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">     <span class="comment">//表头节点</span></span><br><span class="line">     listNode *head;</span><br><span class="line">     <span class="comment">//表尾节点</span></span><br><span class="line">     listNode *tail;</span><br><span class="line">     <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">     <span class="comment">//节点值复制函数</span></span><br><span class="line">     <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值释放函数</span></span><br><span class="line">     <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值对比函数</span></span><br><span class="line">     <span class="keyword">int</span> (*match) (<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></p><p>ListNode节点数据结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">       <span class="comment">//前置节点</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">       <span class="comment">//后置节点</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">       <span class="comment">//节点的值</span></span><br><span class="line">       <span class="keyword">void</span> *value;  </span><br><span class="line">&#125;listNode</span><br></pre></td></tr></table></figure></p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>哈希表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure></p><p>哈希表节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">// 单链表结构</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>字典<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><blockquote><p>在字典中存在dictht数组，表明是两个hash表<br>ht[1]的容量是ht[0]的两倍<br>把ht[0]中的元素rehash复制到ht[1]中</p></blockquote><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p><a href="https://blog.csdn.net/wangmaohong0717/article/details/84611426" target="_blank" rel="noopener">原帖地址</a></p><blockquote><p>进行读操作：会先去ht[0]中找，找不到再去ht[1]中找。<br>进行写操作：直接写在ht[1]中。<br>进行删除操作：与读类似。</p></blockquote><p>但是每一次的增删改查的操作都会把数据从ht[0]转移到ht[1],是为了避免数据迁移导致的cpu负载问题</p><h3 id="有序集合的实现方式是哪种数据结构？"><a href="#有序集合的实现方式是哪种数据结构？" class="headerlink" title="有序集合的实现方式是哪种数据结构？"></a>有序集合的实现方式是哪种数据结构？</h3><blockquote><p>跳跃表</p></blockquote><h2 id="Redis怎样防止异常数据不丢失？"><a href="#Redis怎样防止异常数据不丢失？" class="headerlink" title="Redis怎样防止异常数据不丢失？"></a>Redis怎样防止异常数据不丢失？</h2><h3 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h3><blockquote><p>将某个时间点的所有数据都存放到硬盘上。<br>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。<br>如果系统发生故障，将会丢失最后一次创建快照之后的数据。<br>如果数据量很大，保存快照的时间会很长。</p></blockquote><h3 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h3><blockquote><p>将写命令添加到 AOF 文件（Append Only File）的末尾。<br>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：<br>选项同步频率always每个写命令都同步everysec每秒同步一次no让操作系统来决定何时同步<br>always 选项会严重减低服务器的性能；<br>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；<br>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量<br>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p></blockquote><h2 id="讲一讲缓存穿透，缓存雪崩以及缓存击穿吧"><a href="#讲一讲缓存穿透，缓存雪崩以及缓存击穿吧" class="headerlink" title="讲一讲缓存穿透，缓存雪崩以及缓存击穿吧"></a>讲一讲缓存穿透，缓存雪崩以及缓存击穿吧</h2><ul><li>缓存穿透：就是客户持续向服务器发起对不存在服务器中数据的请求。客户先在Redis中查询，查询不到后去数据库中查询。</li><li>缓存击穿：就是一个很热门的数据，突然失效，大量请求到服务器数据库中</li><li>缓存雪崩：就是大量数据同一时间失效。</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>缓存穿透：<br>1.接口层增加校验，对传参进行个校验，比如说我们的id是从1开始的，那么id&lt;=0的直接拦截；<br>2.缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户反复用同一个id暴力攻击</li><li>缓存击穿：<br>最好的办法就是设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员</li><li>缓存雪崩：<br>1.缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。<br>2.如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="主从同步过程"><a href="#主从同步过程" class="headerlink" title="主从同步过程"></a>主从同步过程</h3><blockquote><ol><li>master启动线程生成RDB                                 </li><li>同时master把新增的请求放到内存中          </li><li>slaver先将RDB文件写入磁盘                      </li><li>slaver把RDB写入磁盘后再加载到内存中</li><li>最后master将缓存的请求再发送给slaver</li></ol></blockquote><h4 id="同步过程细述"><a href="#同步过程细述" class="headerlink" title="同步过程细述"></a>同步过程细述</h4><ol><li>客户端向服务器发送SLAVEOF命令，让当前服务器成为Slave；<blockquote><p>从节点执行slaveof保存主节点信息<br>从节点通过定时任务发现主节点信息，并建立连接<br>从节点发送ping命令，主节点则返回pong命令<br>成功建立连接</p></blockquote></li><li>从节点根据自己是否保存Master runid来判断是否是第一次复制,</li><li>如果是第一次复制，则进行全量复制，从节点向Master发送PSYNC ? -1 命令来进行完整同步；</li><li>如果不是第一次复制，从节点向Master发送PSYNC runid offset；</li><li>Master接收到PSYNC 命令后首先判断runid是否和本机的id一致，如果一致则会再次判断offset偏移量和本机的偏移量相差有没有超过 大小，如果没有那么就给Slave发送CONTINUE，此时Slave只需要等待Master传回失去连接期间丢失的命令；如果runid和本机id不一致或者双方offset差距超过了复制积压缓冲区大小，那么就会返回FULLRESYNC runid offset，Slave将runid保存起来，并进行完整同步。<blockquote><p>上述涉及三个信号<br>FullReSync -&gt; 全量复制信号<br>Continue -&gt; 部分复制信号<br>Err -&gt; psync进行部分复制的时候发现，offset偏移量和主节点的偏移量超过了复制积压缓存区，返回错误信号，进行全量复制FullResync</p></blockquote></li></ol><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p><a href="https://mp.weixin.qq.com/s/nDqNYC0wYFH2Y21acAGNiw?from=groupmessage&amp;scene=1&amp;subscene=10000&amp;clicktime=1585109654&amp;enterid=1585109654" target="_blank" rel="noopener">原帖地址</a></p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><h5 id="1-定时任务"><a href="#1-定时任务" class="headerlink" title="1. 定时任务"></a>1. 定时任务</h5><ul><li>通过向主从节点发送info命令获取最新的主从结构；</li><li>通过发布订阅功能获取其他哨兵节点的信息；</li><li>通过向其他节点发送ping命令进行心跳检测，判断是否下线<h5 id="2-主观下线"><a href="#2-主观下线" class="headerlink" title="2. 主观下线"></a>2. 主观下线</h5><blockquote><p>心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线</p></blockquote><h5 id="3-客观下线"><a href="#3-客观下线" class="headerlink" title="3. 客观下线"></a>3. 客观下线</h5><blockquote><p>哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。<br><strong>客观下线是主节点才有的概念；如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作</strong></p></blockquote><h5 id="4-选举领导者哨兵节点"><a href="#4-选举领导者哨兵节点" class="headerlink" title="4. 选举领导者哨兵节点"></a>4. 选举领导者哨兵节点</h5><blockquote><p>Raft算法 ： 哪个节点先发出申请成为主节点，哪个节点就当master</p></blockquote><h5 id="5-故障转移"><a href="#5-故障转移" class="headerlink" title="5. 故障转移"></a>5. 故障转移</h5></li></ul><ol><li>先过滤不健康的节点</li><li>根据优先级推荐出节点</li><li>选出来的节点成为主节点</li><li>原来的主节点变成新的主节点的从节点</li></ol><h2 id="Redis-和-Memcached-有啥区别，为啥选择用Redis作为你们的缓存中间件？"><a href="#Redis-和-Memcached-有啥区别，为啥选择用Redis作为你们的缓存中间件？" class="headerlink" title="Redis 和 Memcached 有啥区别，为啥选择用Redis作为你们的缓存中间件？"></a>Redis 和 Memcached 有啥区别，为啥选择用Redis作为你们的缓存中间件？</h2><ol><li>Redis 相比 Memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。</li><li>在 redis3.x 版本中，便能支持 Cluster 模式，而 Memcached 没有原生的集群模式</li><li>Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Remcached，还是稍有逊色</li><li>memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小 </li></ol><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><blockquote><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>Redis的事务本质上就是一串命令的执行，已经不可被打断</p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·网络协议篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/13/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>http://runindark.com/2020/03/13/2020春招/我为阿里-网络协议/</id>
    <published>2020-03-13T03:52:12.673Z</published>
    <updated>2020-06-28T01:43:26.138Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="五层协议体系结构"><a href="#五层协议体系结构" class="headerlink" title="五层协议体系结构"></a>五层协议体系结构</h2><ol start="5"><li>应用层<blockquote><p>顾名思义就是上层的网络应用 域名，Http协议等</p></blockquote></li><li>运输层<blockquote><p>两台主机之间提供统用的数据传输服务</p></blockquote></li><li>网络层<blockquote><p>选择合适的路由进行数据交换</p></blockquote></li><li>数据链路层<blockquote><p>一段一段的将数据发送</p></blockquote></li><li>物理层<blockquote><p>物理主机之间的比特流交换</p></blockquote></li></ol><h2 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://upload-images.jianshu.io/upload_images/7368936-abf0a9b7fc6c8eb3.png?imageMogr2/auto-orient/strip|imageView2/2/w/470/format/webp" alt=""></p><ol><li>第一次握手： 客户端（client）向接收端（server）发送标志SYN/ACK，但是 <strong>客户端什么都不知道（接收端直到了自己接收正常，也知道客户端发送正常）</strong> </li><li>第二次握手： 接收端（server）向客户端（client）发送标志SYN/ACK数据包，现在<strong>客户端知道自己接收正常，自己发送正常，但是服务端不知道自己是不是发送正常</strong></li><li>第三次握手， 客户端（client）向接收端（server）发送标志ACK数据包，现在<strong>客户端知道自己发送接收正常，服务端也直到自己发送接收正常</strong></li></ol><blockquote><p>总结：三次握手的原因就是因为数据传输时单向的，对方接收后，发送方属于不知情着，所以才有了三次握手</p></blockquote><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="https://img-blog.csdn.net/20170606084851272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><ol><li>客户端向接收端发送Fin请求，告诉接收端说我这边没什么要发送的了</li><li>接收端向客户端发送一个ACK，告诉客户端说我知道你这边没啥要发送的了</li><li>接收端向客户端发送一个Fin，也告诉客户端说我也没什么要发送的了</li><li>客户端也发送一个ACK给接收端，确认知道了接收端没什么要发送的了</li></ol><h2 id="TCP-VS-UDP"><a href="#TCP-VS-UDP" class="headerlink" title="TCP VS UDP"></a>TCP VS UDP</h2><blockquote><p>TCP保证可靠的连接，UDP只负责交付数据，因此UDP占用的资源少，发送的数据多，TCP占用资源多，发送的数据较少，但是保证了数据传输的绝对稳定</p></blockquote><h3 id="TCP为啥稳定"><a href="#TCP为啥稳定" class="headerlink" title="TCP为啥稳定"></a>TCP为啥稳定</h3><ul><li>TCP会把数据自动分成合适有序有编号的数据包</li><li>TCP发送的时候会对头部和数据进行校验</li><li>TCP会有流量控制，会设立缓冲区，每次发送的时候也是从缓冲区中读取发送</li><li>发送超时会重新进行发送</li></ul></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·Spring》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/12/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-Spring/"/>
    <id>http://runindark.com/2020/03/12/2020春招/我为阿里-Spring/</id>
    <published>2020-03-12T15:02:23.758Z</published>
    <updated>2020-06-28T01:43:26.634Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br>[文章都是搬运艿艿的]<br>[<a href="http://svip.iocoder.cn/Java/Core/Interview/]" target="_blank" rel="noopener">http://svip.iocoder.cn/Java/Core/Interview/]</a></excerpt></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Spring-核心组件-（8大模块）"><a href="#Spring-核心组件-（8大模块）" class="headerlink" title="Spring 核心组件 （8大模块）"></a>Spring 核心组件 （8大模块）</h2><h3 id="Spring-Core"><a href="#Spring-Core" class="headerlink" title="Spring Core"></a>Spring Core</h3><blockquote><p>核心容易，主要是提供Ioc的依赖注入功能</p></blockquote><h3 id="Spring-Aspects"><a href="#Spring-Aspects" class="headerlink" title="Spring Aspects"></a>Spring Aspects</h3><blockquote><p>为了让Spring可以更好的融合AspectJ，实际上也是切面</p></blockquote><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><blockquote><p>提供了面向切面编程的实现</p></blockquote><h3 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h3><blockquote><p>数据库连接驱动</p></blockquote><h3 id="Spring-JMS"><a href="#Spring-JMS" class="headerlink" title="Spring JMS"></a>Spring JMS</h3><blockquote><p>Java 消息服务（ Java Message Service  ， JMS ）</p></blockquote><h3 id="Spring-ORM"><a href="#Spring-ORM" class="headerlink" title="Spring ORM"></a>Spring ORM</h3><blockquote><p>ORM的全称是Object Relational Mapping，即对象关系映射 ==&gt; 为Mybatis，Hibernate提供支持</p></blockquote><h3 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h3><blockquote><p>为Web应用提供支持</p></blockquote><h3 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h3><blockquote><p>顾名思义就是为了测试 Junit等</p></blockquote><h2 id="RestController-vs-Controller"><a href="#RestController-vs-Controller" class="headerlink" title="@RestController  vs @Controller"></a>@RestController  vs @Controller</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><blockquote><p>如果是@Controler，Return的值将直接指向一个页面，或者用转发和重定向的方式<br>如果加上@ResponseBody 那么就是@Controller</p></blockquote><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><blockquote><p>也就是 前后分离 模式下最常用的解决方式</p></blockquote><h3 id="Request-Response-的过程"><a href="#Request-Response-的过程" class="headerlink" title="Request / Response 的过程"></a>Request / Response 的过程</h3><blockquote><p>DispatcherServlet -&gt; Handler Mapping -&gt; Controller/RestController<br>如果是 @Controller则是继续到View层 ，如果是@RestController 直接返回Client</p></blockquote><h2 id="谈谈自己对IOC的理解"><a href="#谈谈自己对IOC的理解" class="headerlink" title="谈谈自己对IOC的理解"></a>谈谈自己对IOC的理解</h2><blockquote><p>谈到Ioc就是一种托付的关系，最传统的应用所创建的对象等全部都托付给系统本身之间的<br>依赖,无论耦合度，都是在不断的变大，Ioc控制反转，也就是责任托付从系统本身变成了<br>由Ioc容器管理，我们只需要明白自己需要什么，不用去想怎么管理怎么创建，如果需要的话可以直接使用xml，注解等方式直接配置引用</p></blockquote><h2 id="Ioc初始化机制"><a href="#Ioc初始化机制" class="headerlink" title="Ioc初始化机制"></a>Ioc初始化机制</h2><blockquote><p>XML &gt;读取&gt; Resource &gt;解析&gt; BeanDefinition &gt;注册&gt; BeanFactory</p></blockquote><blockquote><p>xml 是程序员的配置 ，并根据反射机制可以通过BeanDefinition映射，在BeanFactory中创建出对象</p></blockquote><h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP 面向切面编程"></a>AOP 面向切面编程</h2><blockquote><p>Aop就是一种想要把自己构造出来的方法切入到某个已经写好的类指定的方法之中</p></blockquote><h3 id="1-通知（Advice）"><a href="#1-通知（Advice）" class="headerlink" title="1.通知（Advice）"></a>1.通知（Advice）</h3><blockquote><p>自己需要在某类的指定方法上实现的功能，日志，事务，安全等功能</p></blockquote><h3 id="2-连接点（JoinPoint）"><a href="#2-连接点（JoinPoint）" class="headerlink" title="2.连接点（JoinPoint）"></a>2.连接点（JoinPoint）</h3><blockquote><p>就是Spring中可以插入通知的地方</p></blockquote><h3 id="3-切入点（Pointcut）"><a href="#3-切入点（Pointcut）" class="headerlink" title="3.切入点（Pointcut）"></a>3.切入点（Pointcut）</h3><blockquote><p>就是在需要插入通知的方法重新实现一下，可以说是作为一个标记</p></blockquote><h3 id="4-切面（Aspect）"><a href="#4-切面（Aspect）" class="headerlink" title="4.切面（Aspect）"></a>4.切面（Aspect）</h3><blockquote><p>就是切入点和通知放在一起，同时构成的一个类的某个位置</p></blockquote><h3 id="5-引入（introduction）"><a href="#5-引入（introduction）" class="headerlink" title="5.引入（introduction）"></a>5.引入（introduction）</h3><blockquote><p>就是把切面的功能正式融入到类中使用</p></blockquote><h3 id="6-目标（target）"><a href="#6-目标（target）" class="headerlink" title="6.目标（target）"></a>6.目标（target）</h3><blockquote><p>别切入的类</p></blockquote><h3 id="7-代理-proxy"><a href="#7-代理-proxy" class="headerlink" title="7.代理(proxy)"></a>7.代理(proxy)</h3><blockquote><p>Java的动态代理机制　　</p></blockquote><h3 id="8-织入-weaving"><a href="#8-织入-weaving" class="headerlink" title="8.织入(weaving)"></a>8.织入(weaving)</h3><blockquote><p>引入到类中后，开始正式的调用</p></blockquote><h3 id="串读理解"><a href="#串读理解" class="headerlink" title="串读理解"></a>串读理解</h3><h4 id="Java的动态代理机制"><a href="#Java的动态代理机制" class="headerlink" title="Java的动态代理机制"></a>Java的动态代理机制</h4><h5 id="Proxy-InvocationHandler"><a href="#Proxy-InvocationHandler" class="headerlink" title="Proxy + InvocationHandler"></a>Proxy + InvocationHandler</h5><blockquote><p>让目标类implemet InvocationHandler<br>再调用的时候，利用Proxy的静态方法newProxyInstance() ，通过反射机制，调用目标类的方法等</p></blockquote><h5 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h5><blockquote><p>生成目标类的一个子类</p></blockquote><h4 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h4><blockquote><p>在理解切面之后，深入到方法本身，如何去插入一个另外写好的类，就是在程序运行时<br>利用动态代理的特点，在调用某个方法的时候，再调用proxy将另一个方法调用进去，<br>Before/After等，所以与其说是切入了方法，不如说是切入到了动态代理的执行过程中</p></blockquote><h2 id="SpringBean"><a href="#SpringBean" class="headerlink" title="SpringBean"></a>SpringBean</h2><h3 id="SpringBean-的作用域"><a href="#SpringBean-的作用域" class="headerlink" title="SpringBean 的作用域"></a>SpringBean 的作用域</h3><blockquote><p>Request :每次HTTP请求都会创建一个新的Bean<br>Session :同一个HTTP Session共享一个Bean，不同Session使用不同Bean<br>singleton : 唯一的bean实例<br>prototype : 每次请求都会创建一个新的bean实例</p></blockquote><blockquote><p>SpringBean没有解决线程安全问题<br>可以用ThreadLocal成员变量</p></blockquote><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/05/java0-1558500658.jpg" alt="Bean生命周期"></p><ol><li>创建调用构造函数</li><li>set方法注入属性</li><li>BeanNameAware</li><li>BeanFactoryAware</li><li>ApplicationContextAware</li><li>BeanPostProcessor的before方法</li><li>initializingBean</li><li>自定义init方法</li><li>BeanPostProcessor的after方法</li><li>使用</li><li>容器的销毁</li><li>DisposableBean的destry</li><li>自定义的销毁方法</li></ol><ul><li><p>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</p></li><li><p>Bean实例化后对将Bean的引入和值注入到Bean的属性中</p></li><li><p>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</p></li><li><p>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</p></li><li><p>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</p></li><li><p>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</p></li><li><p>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</p></li><li><p>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</p></li><li><p>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</p></li><li><p>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</p><h3 id="Bean-和-Component"><a href="#Bean-和-Component" class="headerlink" title="@Bean 和  @Component"></a>@Bean 和  @Component</h3><h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><blockquote><p>修饰方法级  可以用Autowired装配</p></blockquote><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><blockquote><p>用于修饰类级别 可以用@CompontScan装配</p></blockquote></li></ul><h2 id="SpringMVC-工作流程"><a href="#SpringMVC-工作流程" class="headerlink" title="SpringMVC 工作流程"></a>SpringMVC 工作流程</h2><ol><li>client 向 DispatcherServlet 发送请求</li><li>DispatcherServlet根据请求信息调用HandlerMapping ，解析请求到handle</li><li>解析到handle以后开始用HandlerAdapter适配器处理</li><li>HandlerAdapter会根据Haddler调用真正的处理器处理请求和逻辑</li><li>之后返回一个ModelAndView对象</li><li>ViewResolver会把逻辑View查询具体的视图</li><li>DispatcherServlet会把返回的Model给view 或者 Client</li></ol><h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><ol><li>编程式事务：在代码中用</li><li>声明式事务（xml，注解）：在配置文件中用</li></ol><blockquote><p>隔离等问题跟数据库一致</p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;[文章都是搬运艿艿的]&lt;br&gt;[&lt;a href=&quot;http://svip.iocoder.cn/Java/Core/Interview/]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://svip.iocoder.cn/Java/Core/Interview/]&lt;/a&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·jvm篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/11/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-Jvm/"/>
    <id>http://runindark.com/2020/03/11/2020春招/我为阿里-Jvm/</id>
    <published>2020-03-11T07:41:05.384Z</published>
    <updated>2020-06-28T01:43:26.430Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Java的内存区域（运行时数据区）"><a href="#Java的内存区域（运行时数据区）" class="headerlink" title="Java的内存区域（运行时数据区）"></a>Java的内存区域（运行时数据区）</h2><h3 id="线程共享区"><a href="#线程共享区" class="headerlink" title="线程共享区"></a>线程共享区</h3><ol><li>堆</li><li>方法区 （方法区中包含运行时常量池）</li></ol><h3 id="线程私有区"><a href="#线程私有区" class="headerlink" title="线程私有区"></a>线程私有区</h3><ol><li>虚拟机栈</li><li>本地方法栈</li><li>程序计数器<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h3 id="Java1-8之后的变化"><a href="#Java1-8之后的变化" class="headerlink" title="Java1.8之后的变化"></a>Java1.8之后的变化</h3><blockquote><p>线程共享的方法区糅合到了直接内存中的元空间</p></blockquote></li></ol><h2 id="为什么每一个线程需要一个程序计数器"><a href="#为什么每一个线程需要一个程序计数器" class="headerlink" title="为什么每一个线程需要一个程序计数器"></a>为什么每一个线程需要一个程序计数器</h2><h3 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h3><blockquote><p>是一块比较小的线程空间，可以当作字节码指令的指示器，字节码解释器通过程序计数器<br>来控制字节码指令，比如循环，跳转，分支，异常处理等</p></blockquote><h3 id="为啥线程需要程序计数器？"><a href="#为啥线程需要程序计数器？" class="headerlink" title="为啥线程需要程序计数器？"></a>为啥线程需要程序计数器？</h3><blockquote><p>由于线程是不断切换的，所以线程在切换后，如何进行哪一步的继续操作，是需要程序计的<br>同时程序计数器是唯一一个不会出现OutOfMemoryError的内存区域</p></blockquote><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><blockquote><p>虚拟栈其实更通俗的讲也就是线程私有化的方法栈，用于执行线程中Java方法调用的内存模型，每次调用都是通过栈来传递的<br>其实Java内存中可以区分成栈空间，和堆空间，栈空间就是现在的虚拟机栈等，同共享<br>区的方法区一样，栈空间的栈帧依然包含局部变量表（各种基本数据类型和引用）<br>同程序计数器不同的是，虚拟机栈会出现超过栈数目的 StackOutOfFlow 以及超过内存<br>内存空间的OutOfMemoryError</p></blockquote><h3 id="Java的两种返回方式"><a href="#Java的两种返回方式" class="headerlink" title="Java的两种返回方式"></a>Java的两种返回方式</h3><ol><li>return</li><li>异常抛出</li></ol><blockquote><p>方法每一次的调用都会压栈，同时每一次返回都会出栈，上面两个方法的调用都会导致<br>出栈</p></blockquote><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><h2 id="本地方法栈是做什么的？"><a href="#本地方法栈是做什么的？" class="headerlink" title="本地方法栈是做什么的？"></a>本地方法栈是做什么的？</h2><blockquote><p>本地方法栈和虚拟机栈不同，本地方法栈是用来执行Native修饰的方法，但是虚拟机栈<br>是用来执行Java的方法，但是对于HotSpot虚拟机来说，虚拟机栈和本地方法栈合并了<br>所以一样的可以推出，本地方法栈也有自己的栈帧等，栈帧里面也相应的有局部变量表<br>操作数栈，动态链接，出口信息等</p></blockquote><h2 id="堆-（GC堆）"><a href="#堆-（GC堆）" class="headerlink" title="堆 （GC堆）"></a>堆 （GC堆）</h2><blockquote><p>堆是线程共享区的，也是Jvm管理的最大的内存空间，没有之一，几乎所有的对象实例和<br>都在这里分配内存，当然了线程中的类的实例等，都通过reference进行引用<br>由于垃圾大多数也都是由堆产生，因此也被称作为 GC堆</p></blockquote><h2 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h2><blockquote><p>堆中可以粗略的说有 新生代和老年代 ，新生代用完以后可能就不会再引用，所以要更多的被释放掉<br>老年代则趋于稳定，长久的存在或被使用</p></blockquote><p>更加细致的划分</p><blockquote><p>被分为Eden区和From Survivor，To Survivor<br>大部分情况下，首先会再Eden区进行空间分配，在一次垃圾回收后，对象还存活则年龄加一<br>当年龄增加到默认的15岁，则进入到老年代，当然晋升的年龄阈值是可以调节的-XX:MaxTenuringThreshold</p></blockquote><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><blockquote><p>属于线程共享的内存区域，用于存放虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码量，主要是用于存放堆中的逻辑操作等。<br>方法区也就是永久代，永久代不用纠结就是HotSpot规定的一种规范方法区的一种实现</p></blockquote><pre><code class="java">-XX:PermSize=N <span class="comment">//⽅法区(永久代)初始⼤⼩</span>-XX:MaxPermSize=N <span class="comment">//⽅法区(永久代)最⼤⼤⼩,超过这个值将会抛出OutOfMemoryError异</span>常:java.lang.OutOfMemoryError: PermGen</code></pre><blockquote><p>不过到JDK1.8的时候已经被移除了，直接变成了元空间，也就是直接存入内存空间。</p></blockquote><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><blockquote><p>是属于方法区的一部分，Class文件中有类型，方法，接口，版本等信息外，还有一些常量（最特征的就是final修饰的）<br>但是1.7之后这部分又去到了堆中开辟了一片空间，因此</p></blockquote><h3 id="运行时常量池包含什么"><a href="#运行时常量池包含什么" class="headerlink" title="运行时常量池包含什么"></a>运行时常量池包含什么</h3><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><ol><li>文本字符串</li><li>final修饰的</li><li>基本数据类型的值<h4 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h4></li><li>类和结构完全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ol><h2 id="Java对象的创建过程"><a href="#Java对象的创建过程" class="headerlink" title="Java对象的创建过程"></a>Java对象的创建过程</h2><h3 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1. 类加载检查"></a>1. 类加载检查</h3><blockquote><p>从常量池中定位new的符号引用，看看找个类是不是被加载，解析，初始化过。如果没有再执行相应的类加载过程</p></blockquote><h3 id="2-分配内存"><a href="#2-分配内存" class="headerlink" title="2. 分配内存"></a>2. 分配内存</h3><blockquote><p>在堆中直接分配内存，在类加载后会直到该对象需要分配的大小，分配方法有两种（指针碰撞 和 空闲列表），分配方式的选择是由Java堆是否规整决定的</p></blockquote><h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><blockquote><p>就是内存如果工整，那么直接就移动指针分配空间</p></blockquote><h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><blockquote><p>内存不工整，类加载确定出空间后，进行“见缝插针”</p></blockquote><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><h5 id="CAS乐观解决"><a href="#CAS乐观解决" class="headerlink" title="CAS乐观解决"></a>CAS乐观解决</h5><blockquote><p>就是继续利用CAS算法尝试去获取内存空间，直到成功，虚拟机就是这么做的</p></blockquote><h5 id="TLAB解决"><a href="#TLAB解决" class="headerlink" title="TLAB解决"></a>TLAB解决</h5><blockquote><p>在堆中给每个线程分配一丢丢空间，让他自己独有，分配的时候就先分配给TLAB空间，<br>但是这么做的后果就是空间浪费问题</p></blockquote><h3 id="3-初始化零值"><a href="#3-初始化零值" class="headerlink" title="3. 初始化零值"></a>3. 初始化零值</h3><blockquote><p>不包括对象头 ，就是给一一些值赋0或者null</p></blockquote><h3 id="4-设置对象头"><a href="#4-设置对象头" class="headerlink" title="4. 设置对象头"></a>4. 设置对象头</h3><blockquote><p>对象的hash码，分代年龄等，同时个synchronized锁也在对象头</p></blockquote><h3 id="5-执行init（）方法"><a href="#5-执行init（）方法" class="headerlink" title="5. 执行init（）方法"></a>5. 执行init（）方法</h3><blockquote><p>可以理解为Jvm已经创建完成，但是这里才是按照程序员的意愿开始创建，有点感觉是构造方法执行</p></blockquote><h2 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h2><ol><li>句柄</li><li>直接访问</li></ol><blockquote><p>二者的区别在于对于对象实例数据的处理上，句柄是先访问实例苏话剧的指针，在访问实例数据<br>直接指针是直接去Heap中去访问实例数据，不过相应的二者访问类型数据都是先去堆中访问类型数据指针再去方法区去拿到类型数据</p></blockquote><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><blockquote><p>如果是读取的话，看上面过程也就直到，直接指针直接读取会更快一些，但是同样的如果<br>进行删除操作等，需要一个一个的更改数据，效率差，如果是句柄的话直接地址赋null值<br>就可以了，这个赋null值其实和c++的回收是一样的，直接赋null，就证明这一块空间又<br>可以被分配利用了</p></blockquote><h2 id="对象的分配策略"><a href="#对象的分配策略" class="headerlink" title="对象的分配策略"></a>对象的分配策略</h2><blockquote><p>大对象，长期存活对象分配到老年代，但是一般的对象有限分配到Eden区</p></blockquote><h3 id="Minor-GC，-Full-GC的区别"><a href="#Minor-GC，-Full-GC的区别" class="headerlink" title="Minor GC， Full GC的区别"></a>Minor GC， Full GC的区别</h3><blockquote><p>MinorGC也就是新生代的垃圾回收，很频繁，而且速度快<br>FullGC是指老年代的垃圾回收，不是很频繁</p></blockquote><h2 id="对象的死亡判断"><a href="#对象的死亡判断" class="headerlink" title="对象的死亡判断"></a>对象的死亡判断</h2><h3 id="程序计数器法"><a href="#程序计数器法" class="headerlink" title="程序计数器法"></a>程序计数器法</h3><blockquote><p>就是一个对象被引用一次那么计数器加一，如果引用失效那么计数器减一,如果为0，则<br>直接回收</p></blockquote><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><blockquote><p>形象的来说就是以GC Root作为起点，然后查看各个对象到GCRoot是否有一条路劲可以<br>连起来，如果连不起来则直接回收</p></blockquote><h4 id="补充：一般哪些可以作为GCRoot呢："><a href="#补充：一般哪些可以作为GCRoot呢：" class="headerlink" title="补充：一般哪些可以作为GCRoot呢："></a>补充：一般哪些可以作为GCRoot呢：</h4><blockquote><p>通过System Class Loader或者Boot Class Loader加载的class对象，通过自定义类加载器加载的class不一定是GC Root<br>处于激活状态的线程<br>栈中的对象<br>JNI（Java Native Interface）栈中的对象<br>JNI中的全局对象<br>正在被用于同步的各种锁对象<br>JVM自身持有的对象，比如系统类加载器等</p></blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>Java1.2之前定义引用就是reference如果指向的是内存空间的起始地址。</p></blockquote><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><blockquote><p>大多数使用的基本都是强引用，垃圾回收器则不会去回收他，及时空间不足，直接oom，也不会去回收强引用</p></blockquote><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><blockquote><p>区别于强引用，当发生内存不足的时候，才可以被垃圾回收掉。 也正是这样，可以用来<br>处理对内存比较敏感的高速缓存</p></blockquote><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><blockquote><p>区别于软引用，只要垃圾回收器扫描到这部分视作垃圾，那么就直接回收掉<br>可以配合一个引用队列，来查看是是否被GC回收</p></blockquote><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><blockquote><p>虚引用的实际用途不在乎是引用了什么对象，粗略的说可以说成一种 即将被GC回收的标<br>志，也是一种跟踪GC回收的一种方法，虚引用必须配合 引用队列来使用，即在某对象回<br>收之前，则虚引用入队，告诉Jvm该对象即将要被回收，可以在某对象被回收前做一些操作</p></blockquote><h2 id="废弃常量的判定方法"><a href="#废弃常量的判定方法" class="headerlink" title="废弃常量的判定方法"></a>废弃常量的判定方法</h2><blockquote><p>如果是在常量池，而且没用String对象引用，那么就说他是废弃常量，如果内存回收需要的话，直接清理出去</p></blockquote><h2 id="如何判定一个类的废弃"><a href="#如何判定一个类的废弃" class="headerlink" title="如何判定一个类的废弃"></a>如何判定一个类的废弃</h2><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><blockquote><p>ClassLoader是一个类加载器，它的工作是将一个类的全限名在Jvm外部进行转化成一个<br>二进制流,转成二进制流是为了Jvm读取，但是是在虚拟机外部就转化成，这样的目的是<br>让应用程序自己可以选择这个类，这也是为啥在对象回收时，Jvm Rooter可以是<br>Classroader的原因</p></blockquote><h3 id="java-lang-Class"><a href="#java-lang-Class" class="headerlink" title="java.lang.Class"></a>java.lang.Class</h3><blockquote><p>反射机制的核心，也就就是所有类自身的一个独有的镜子，在一个类被编译成.class文件的时候，在jvm中运行，会同时自动生成一个和自己创建的类想匹配的Class类</p></blockquote><h3 id="一个类废弃的判定方法"><a href="#一个类废弃的判定方法" class="headerlink" title="一个类废弃的判定方法"></a>一个类废弃的判定方法</h3><ol><li>所有的实例已经被回收掉，堆中不再有这个类的实例</li><li>该类的Classloader也已经被回收</li><li>该类对应的java.lang.class文件没有在任何地方被引用，也无法在任何地方通过反射机制来访问该类</li></ol><h2 id="垃圾回收机制的算法"><a href="#垃圾回收机制的算法" class="headerlink" title="垃圾回收机制的算法"></a>垃圾回收机制的算法</h2><h3 id="无脑清空法-–-标记清除算法"><a href="#无脑清空法-–-标记清除算法" class="headerlink" title="无脑清空法 – 标记清除算法"></a>无脑清空法 – 标记清除算法</h3><blockquote><p>标记需要回收的对象，然后标记完后，通过一轮回收直接把标记的位置回收</p><ol><li>效率差</li><li>清理完空间不连续</li></ol></blockquote><h3 id="复制填坑法-–-复制算法"><a href="#复制填坑法-–-复制算法" class="headerlink" title="复制填坑法 – 复制算法"></a>复制填坑法 – 复制算法</h3><blockquote><p>将内存空间分成两份，然后将不需要回收的内存（活着的对象）复制到另一块空间去，保证整洁</p><ol><li>需要两份一样的空间</li><li>复制的时候消耗太大</li></ol></blockquote><h3 id="洁癖整理法-–-标记整理算法"><a href="#洁癖整理法-–-标记整理算法" class="headerlink" title="洁癖整理法 – 标记整理算法"></a>洁癖整理法 – 标记整理算法</h3><blockquote><p>也是先标记，但是不同的是，标记以后直接向某一端直接移动，然后GC直接回收边界的无用的空间</p></blockquote><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><blockquote><p>分配空间的空间按照新生代和老年代区别，新生代可以用复制算法，老年代的内存大，而且多，可以使用 标记整理算法，也可以酌情标记清空算法</p></blockquote><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial-（年轻代）"><a href="#Serial-（年轻代）" class="headerlink" title="Serial （年轻代）"></a>Serial （年轻代）</h3><ol><li>单线程收集器</li><li>当进行单线程回收垃圾的时候，其它线程必须停止</li><li>但是对一个客户端的还不错，毕竟切换没那么复杂，而且单线程自然可以调用的资源更多<h3 id="ParNew-（年轻代）"><a href="#ParNew-（年轻代）" class="headerlink" title="ParNew （年轻代）"></a>ParNew （年轻代）</h3><blockquote><p>上述Serial的一个升级，其实就是升级成了多线程</p></blockquote></li><li>多线程收集</li><li>stop the world ，还是要停止所有的线程工作<h3 id="Parallel-Scavenge-（年轻代）"><a href="#Parallel-Scavenge-（年轻代）" class="headerlink" title="Parallel Scavenge （年轻代）"></a>Parallel Scavenge （年轻代）</h3><blockquote><p>为了吞吐量而减少收集时间，提高收集次数的一种收集算法，（吞吐量：程序运行时间/CPU使用时长）<br>适合执行批量处理、订单处理</p></blockquote><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3></li></ol><h3 id="CMS-（老年代）"><a href="#CMS-（老年代）" class="headerlink" title="CMS （老年代）"></a>CMS （老年代）</h3><blockquote><p>HotSpot的第一款真正意义上的并发垃圾回收机制，是用的标记清除算法</p></blockquote><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><h5 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h5><blockquote><p>暂停掉所有的线程，标记一下与GC root相连的对象（可达性分析里面的那个GC Root）</p></blockquote><h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h5><blockquote><p>继续类似可达性分析，标记一系列可达的的队形 GC Root Trancing</p></blockquote><h5 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h5><blockquote><p>并发标记是并发的，重新标记是为了修正重新标记期间的用户变动</p></blockquote><h5 id="并发清除"><a href="#并发清除" class="headerlink" title="并发清除"></a>并发清除</h5><blockquote><p>开始对标记的区域做清理</p></blockquote><ol><li>对CPU资源敏感</li><li>无法清理浮动垃圾<br>3 标记清除算法有太多的空间碎片<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><blockquote><p>面向服务器的垃圾回收器，针对配备多核处理起的cpu<br>宏观上是复制，微观上有标记整理算法<br>不区分内存块 Eden surviovor old在微观上还是被保留的</p></blockquote><h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><h5 id="初始标记-1"><a href="#初始标记-1" class="headerlink" title="初始标记"></a>初始标记</h5><h5 id="并发标记-1"><a href="#并发标记-1" class="headerlink" title="并发标记"></a>并发标记</h5><h5 id="最终标记"><a href="#最终标记" class="headerlink" title="最终标记"></a>最终标记</h5><h5 id="筛选回收"><a href="#筛选回收" class="headerlink" title="筛选回收"></a>筛选回收</h5></li></ol><blockquote><p>过程其实大同小异，相比于CMS其实更多的在于标记的时候多了Remember Set，到了最终标记还有Remeber Set Log合并到了Remeber Set因此避免了浮动垃圾问题<br>Region在宏观是其实是复制原则，但是在Region的内部其实是标记整理算法<br>Region内部除了Eden s0 s1 old 还有超大对象，面对超大对象，会选择移动老年代的<br>对象来为超大内存的对象提供内存</p></blockquote><h2 id="Jvm类加载模式"><a href="#Jvm类加载模式" class="headerlink" title="Jvm类加载模式"></a>Jvm类加载模式</h2><ol><li>加载<blockquote><p>这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口</p></blockquote></li><li>验证<blockquote><p>了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求</p></blockquote></li><li>准备<blockquote><p>是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。</p></blockquote></li><li>解析<blockquote><p>虚拟机将常量池中的符号引用替换为直接引用的过程</p></blockquote></li><li>初始化<blockquote><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。</p></blockquote></li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ol><li>启动类加载器<blockquote><p>负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被<br>虚拟机认可（按文件名识别，如 rt.jar）的类</p></blockquote></li><li>扩展类加载器<blockquote><p>负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类<br>库</p></blockquote></li><li><p>应用程序类加载器</p><blockquote><p>负责加载用户路径（classpath）上的类库<br>利用双亲委派模型进行类的加载，通过继承java.lang.classloader实现自定义类加载器</p></blockquote><pre><code>                启动类加载器（Bootstrap ClassLoader）                                /\                                ||                扩展类加载器 （Extension ClassLoader）                                /\                                ||                应用程序类加载器 （Application ClassLoader）                        /\                  /\                        ||                  ||自定义加载器（User ClassLoader）    自定义加载器（UserClassLoader）</code></pre></li></ol><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><blockquote><p>当一个类收到类加载的请求，他首先不会尝试自己去加载这个类，而是把请求委托给父类去完成，每一层的类加载器都是如此（如上图，箭头向上），因此最终所有的加载类都应该送到启动类加载器去完成，只有当父类的加载器返回自己无法加载这个请求的时候，子类加载器才会自己尝试去加载。<br>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载<br>器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载<br>器最终得到的都是同样一个 Object 对象</p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·mysql篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/10/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-mysql/"/>
    <id>http://runindark.com/2020/03/10/2020春招/我为阿里-mysql/</id>
    <published>2020-03-10T03:03:04.084Z</published>
    <updated>2020-06-28T01:43:26.639Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Mysql事务的特性-ACID"><a href="#Mysql事务的特性-ACID" class="headerlink" title="Mysql事务的特性 - ACID"></a>Mysql事务的特性 - ACID</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><blockquote><p>和线程是一样的，意思就是要么成功，要么失败 =》 事务要么执行成功，要么执行失败</p></blockquote><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><blockquote><p>从一个一致性到另一个一致性是传递的，就是一个业务流程，一个环节不是一致性，下一个环节就会失败</p></blockquote><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><blockquote><p>数据库事务和事务之间是隔离的，也就是说事务A看不到事务B，相应的事务B也不晓得事务A干啥</p></blockquote><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><blockquote><p>也就是说，只要事务存入数据库的就是永久存在的，哪怕数据库出异常了，数据也还在</p></blockquote><h2 id="Mysql事务的出现的问题"><a href="#Mysql事务的出现的问题" class="headerlink" title="Mysql事务的出现的问题"></a>Mysql事务的出现的问题</h2><h3 id="事务会发生的意外"><a href="#事务会发生的意外" class="headerlink" title="事务会发生的意外"></a>事务会发生的意外</h3><h4 id="脏读（Select-没有规矩）"><a href="#脏读（Select-没有规矩）" class="headerlink" title="脏读（Select 没有规矩）"></a>脏读（Select 没有规矩）</h4><blockquote><p>事务A插入了一个数据，但是人家事务A没有提交。结果事务B他没有规矩，他查了一下表，结果发现了事务A插入的数据。这就是脏读</p></blockquote><h4 id="不可重复读（Update-没有规矩）"><a href="#不可重复读（Update-没有规矩）" class="headerlink" title="不可重复读（Update 没有规矩）"></a>不可重复读（Update 没有规矩）</h4><blockquote><p>事务A查询一条数据是A，但是事务b他没有规矩，他更新了数据A变成了B，当事务A再查这条数据的时候，发现变成了B，这就是不可重复读</p></blockquote><h4 id="幻读-（Insert-Delete-没有规矩）"><a href="#幻读-（Insert-Delete-没有规矩）" class="headerlink" title="幻读 （Insert Delete 没有规矩）"></a>幻读 （Insert Delete 没有规矩）</h4><blockquote><p>事务A差某表，查出A条数据，事务B这时候删了几条数据，事务A此刻又去读了一下，发现数据少了，这就是不可重复读。</p></blockquote><h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><h4 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h4><blockquote><p>事务之间可以读取到事务未提交的数据 （完美的符合了上面出现的所有问题）</p></blockquote><h4 id="提交读"><a href="#提交读" class="headerlink" title="提交读"></a>提交读</h4><blockquote><p>顾名思义就是可以读取到已经提交的数据，引申一下，里面涉及到的一种“快照读”，也就是读历史确定的版本</p></blockquote><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><blockquote><p>也就是悲观锁读，当前的一个事务如果读取到该数据，那么给当前读取上锁，其它事务将无法再获取该数据，但是这个并不能限制事务继续插入数据，所以就会<br>引起幻读</p></blockquote><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><blockquote><p>顾名思义就是一个一个慢慢来，一次只能来一个，活该这么慢</p></blockquote><h2 id="Mysql的存储引擎"><a href="#Mysql的存储引擎" class="headerlink" title="Mysql的存储引擎"></a>Mysql的存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><blockquote><p>Mysql所默认的一种存储引擎，满足ACID的事务要求，他使用了“一次性非锁定性读”（也就是给数据读取等添加版本，这个里面有些和上述的快照读概念差不<br>多）</p></blockquote><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><blockquote><p>依靠逗号来分割数据的一种存储方式</p></blockquote><h4 id="InnoDB的一些优点缺点"><a href="#InnoDB的一些优点缺点" class="headerlink" title="InnoDB的一些优点缺点"></a>InnoDB的一些优点缺点</h4><ol><li>行锁粒度，粒度更小，更适合并发场景</li><li>支持事务，有外键</li><li>缺点： 缺点也很明显不支持全文搜索，可以用es搜索</li></ol><h2 id="Mysql数据库索引"><a href="#Mysql数据库索引" class="headerlink" title="Mysql数据库索引"></a>Mysql数据库索引</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><blockquote><p>可以理解成一种排序后的数据结构，通过节点存储索引，之后在查到找相应的结果，通过数据结构加速，比如用二叉树，那么就可以通过节点左右比较减少<br>遍历查找的次数，当然了如果1 2 3 4 5 6 就会变成链表，如果是红黑树则解决了这个问题，但是会导致深度过深，因此使用B+树，降低深度，添加广度</p></blockquote><h3 id="常用的功能索引"><a href="#常用的功能索引" class="headerlink" title="常用的功能索引"></a>常用的功能索引</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><blockquote><p>就是最基本的添加一个索引，用于加速查找</p></blockquote><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><blockquote><p>列值必须唯一，可以为空值，加速查找</p></blockquote><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><blockquote><p>利用主键作为索引，而且不可以为空，加速查找</p></blockquote><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><blockquote><p>就是查查找的数据也是索引值</p></blockquote><h4 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4><blockquote><p>几列合并成一个索引，但是遵循最左原则</p></blockquote><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><blockquote><p>全文分词查找，innoDB是做不到的，需要第三方，比如es等</p></blockquote><h3 id="使用索引存在的问题"><a href="#使用索引存在的问题" class="headerlink" title="使用索引存在的问题"></a>使用索引存在的问题</h3><blockquote><p>使用索引的时候不可以随便使用，过度的使用索引会导致消耗大量的资源，热点核心业务的数据应该多使用索引<br>索引会浪费磁盘空间，不要创建非必要的索引,插入、更新、删除需要维护索引，带来额外的开销,索引过多，修改表的时候重构索引性能差<br>但是索引使用的时候可以减少查询次数，提高效率</p></blockquote><h2 id="Sql-的查询顺序"><a href="#Sql-的查询顺序" class="headerlink" title="Sql 的查询顺序"></a>Sql 的查询顺序</h2><ol><li>from 从哪个表查询</li><li>where 初步过滤条件</li><li>group by 过滤后进行分组[重点]</li><li>having 对分组后的数据进行二次过滤[重点]</li><li>select 查看哪些结果字段</li><li>order by 按照怎样的顺序进行排序返回[重点]</li></ol></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·并发编程篇》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/09/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C/"/>
    <id>http://runindark.com/2020/03/09/2020春招/我为阿里/</id>
    <published>2020-03-09T12:19:18.601Z</published>
    <updated>2020-06-28T01:43:26.137Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="进程，协程，线程基础概念"><a href="#进程，协程，线程基础概念" class="headerlink" title="进程，协程，线程基础概念"></a>进程，协程，线程基础概念</h2><h3 id="能否解释进程，线程，协程的关系？"><a href="#能否解释进程，线程，协程的关系？" class="headerlink" title="能否解释进程，线程，协程的关系？"></a>能否解释进程，线程，协程的关系？</h3><blockquote><p>进程是一个程序代码运行所执行的一个程序，但是一个进程可以包含多个线程，在单核cpu下，Java默认多线程可以以一种抢占式的方式执行一种并发状态，协程是近些年走进视野的，以GO语言为代表可以操作协程，一个线程中可以包含更多的协程，可以简单的说线程包含协程。</p></blockquote><h3 id="协程对于多线程有什么优缺点吗？"><a href="#协程对于多线程有什么优缺点吗？" class="headerlink" title="协程对于多线程有什么优缺点吗？"></a>协程对于多线程有什么优缺点吗？</h3><ol><li>首先是更小的协程可以在不使用内核的前提下进行上下文切换</li><li>一个线程就可以完成高并发的任务，对高并发的支持更好</li><li>协程在一个线程下，是不用考虑数据的读写不一致问题（读写变量冲突问题）</li><li>缺点： 缺点也很明显，本质还是一个单线程，不能利用多核资源，同时也不独立，需要线程，进程配合才可以运行</li></ol><h3 id="并行和并发的区别是什么？"><a href="#并行和并发的区别是什么？" class="headerlink" title="并行和并发的区别是什么？"></a>并行和并发的区别是什么？</h3><ol><li>并行是指多个程序 同时多个一起运行</li><li>并发是指多个程序在某一个时间段内交替的快速运行，宏观是有点类似并行，但是实际上是交替运行</li><li>恶补英语之==&gt; 并发 （concurrency）  并⾏ parallellism</li></ol><h2 id="多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）"><a href="#多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）" class="headerlink" title="多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）"></a>多线程基础之实现（学了这么多年还真的第一次这么认真的去研究该怎么写）</h2><h3 id="Java线程创建的几种方式"><a href="#Java线程创建的几种方式" class="headerlink" title="Java线程创建的几种方式"></a>Java线程创建的几种方式</h3><ol><li><p>继承extends</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread by extend Thread"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadByThread threadByThread = <span class="keyword">new</span> ThreadByThread() ;</span><br><span class="line">        threadByThread.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Runnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread create by implements Runnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadByRunnable ta = <span class="keyword">new</span> ThreadByRunnable() ;</span><br><span class="line">        <span class="keyword">new</span> Thread(ta).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用CF</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByCF</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Thread create by CF"</span> +<span class="string">":"</span> +Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FutureTask&lt;Object&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> ThreadByCF()) ;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.setName(<span class="string">"Cf"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.ways;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.print.DocFlavor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            service.execute(<span class="keyword">new</span> ThreadByThread());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread());</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="线程基本原理"><a href="#线程基本原理" class="headerlink" title="线程基本原理"></a>线程基本原理</h2><h3 id="线程有哪些状态"><a href="#线程有哪些状态" class="headerlink" title="线程有哪些状态"></a>线程有哪些状态</h3><blockquote><p>创建 -&gt; 就绪 -&gt; 执行 -&gt; 消亡<br>阻塞: 分为同步组织，等待阻塞。 等待阻塞就是wait啦，sleep啦。同步阻塞就是sychronize锁被占用，另一个线程也需要占用这个锁，结果凉了，就阻塞了。</p></blockquote><h3 id="线程的基本一些方法"><a href="#线程的基本一些方法" class="headerlink" title="线程的基本一些方法"></a>线程的基本一些方法</h3><ol><li>sleep<blockquote><p>就是进入了等待阻塞队列中，根据设定的时间阻塞，而且不会释放锁，他的阻塞状态就是time_waiting</p></blockquote></li><li>yield<blockquote><p>就是让线程立马停止一下，但是不会进入阻塞，而是直接进入就绪,且不会释放锁</p></blockquote></li><li>join<blockquote><p>有点救护车让道的意思，谁调用join谁先执行，然后再执行被停用的线程</p></blockquote></li><li>wait<blockquote><p>就是进入等待状态，而且必须有人去唤醒他，没人唤醒，就被打入阻塞冷宫这辈子也就这样了，但是wait会释放锁，也可以wait（time）来通过时间唤醒</p></blockquote></li><li>notify<blockquote><p>唤醒wait打入冷宫的老铁，但是唤醒谁不能指定，唤醒全靠缘分</p></blockquote></li><li>notifyall<blockquote><p>大发慈悲，冷宫的全放出来了</p></blockquote></li></ol><h3 id="线程不安全的同步容器比如？"><a href="#线程不安全的同步容器比如？" class="headerlink" title="线程不安全的同步容器比如？"></a>线程不安全的同步容器比如？</h3><blockquote><p>HashMap、ArrayList、LinkedList</p></blockquote><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="说说volatile的与sychronize的区别"><a href="#说说volatile的与sychronize的区别" class="headerlink" title="说说volatile的与sychronize的区别"></a>说说volatile的与sychronize的区别</h3><ol><li>volatile 不是原子性的，sychronize是原子性的</li><li>volatile和sychronize都保证了可见性</li><li>volatile是禁止了指令重排的</li><li>不能写入 不能修饰写⼊操作依赖当前值的变量，⽐如num++、num=num+1</li></ol><h3 id="为啥会出现脏读的问题？"><a href="#为啥会出现脏读的问题？" class="headerlink" title="为啥会出现脏读的问题？"></a>为啥会出现脏读的问题？</h3><blockquote><p>这个是JMM（java内存模型） 导致的，java线程中不是所有的变量都是在主存的，而是每个线程都有自己的一丢丢空间，对于修改的变量的操作，先从主存拿到，再修改，再写回去，如果多线程，可能因为速度问题，写入的时间啥的有差别，所以就会导致把数据脏读了。</p></blockquote><h3 id="为啥volatile可以解决这个问题呢？"><a href="#为啥volatile可以解决这个问题呢？" class="headerlink" title="为啥volatile可以解决这个问题呢？"></a>为啥volatile可以解决这个问题呢？</h3><blockquote><p>volatile就像是一个敏感的报警灯一样，一旦有人妄图修改volatile修饰的数据，立马报警通知修改情况，所以说原子性差了点，但是可见性或者说是共享性好的鸭匹</p></blockquote><h2 id="指令重排-happens-before"><a href="#指令重排-happens-before" class="headerlink" title="指令重排/happens-before"></a>指令重排/happens-before</h2><h3 id="啥是指令重排？"><a href="#啥是指令重排？" class="headerlink" title="啥是指令重排？"></a>啥是指令重排？</h3><blockquote><p>为了提高程序的执行效率，再不改变运行结果的前提下，jvm对字节码文件的指令重新排序，以提高效率</p></blockquote><h3 id="知道-happens-before吗，能否简单解释下？"><a href="#知道-happens-before吗，能否简单解释下？" class="headerlink" title="知道 happens-before吗，能否简单解释下？"></a>知道 happens-before吗，能否简单解释下？</h3><blockquote><p>由于多线程的特殊性，对jvm的指令重排有严格的限制，所以有了happens-before的原则（先行发生原则） ==&gt;（这个解释靠谱：前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量a赋值为1，那后面一个操作肯定能知道a已经变成了1。）</p></blockquote><h3 id="划重点：这些规则一并奉上"><a href="#划重点：这些规则一并奉上" class="headerlink" title="划重点：这些规则一并奉上"></a>划重点：这些规则一并奉上</h3><ol><li><p>程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！</p></li><li><p>管程锁定规则：就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）</p></li><li><p>volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</p></li><li><p>线程启动规则：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</p></li><li><p>线程终止规则：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。</p></li><li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。</p></li><li><p>传递规则：这个简单的，就是happens-before原则具有传递性，即A happens-before B ， B happens-before C，那么A happens-before C。</p></li><li><p>对象终结规则：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</p></li></ol><h2 id="并发编程进阶"><a href="#并发编程进阶" class="headerlink" title="并发编程进阶"></a>并发编程进阶</h2><h3 id="并发编程三要素："><a href="#并发编程三要素：" class="headerlink" title="并发编程三要素："></a>并发编程三要素：</h3><h4 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h4><blockquote><p>要么全成功，要么全失败<br>例如num++ 这种操作就是非原子性的  可以用lock或者Sychronized来修饰这个操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h4><h4 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h4><h2 id="进程的执行顺序"><a href="#进程的执行顺序" class="headerlink" title="进程的执行顺序"></a>进程的执行顺序</h2><h3 id="先来先服务调度算法："><a href="#先来先服务调度算法：" class="headerlink" title="先来先服务调度算法："></a>先来先服务调度算法：</h3><blockquote><p>按照作业/进程到达的先后顺序进⾏调度 ，即：优先考虑在系统中等待时间最⻓的作业<br>排在⻓进程后的短进程的等待时间⻓，不利于短作业/进程</p></blockquote><h3 id="短作业优先调度算法："><a href="#短作业优先调度算法：" class="headerlink" title="短作业优先调度算法："></a>短作业优先调度算法：</h3><blockquote><p>短进程/作业（要求服务时间最短）在实际情况中占有很⼤⽐例，为了使得它们优先执⾏<br>对⻓作业不友好</p></blockquote><h3 id="⾼响应⽐优先调度算法"><a href="#⾼响应⽐优先调度算法" class="headerlink" title="⾼响应⽐优先调度算法:"></a>⾼响应⽐优先调度算法:</h3><blockquote><p>在每次调度时，先计算各个作业的优先权：优先权=响应⽐=（等待时间+要求服务时间）/<br>要求服务时间,<br>因为等待时间与服务时间之和就是系统对该作业的响应时间，所以 优先权=响应⽐=响应<br>时间/要求服务时间，选 择优先权⾼的进⾏服务需要计算优先权信息，增加了系统的开销</p></blockquote><h4 id="时间⽚轮转调度算法"><a href="#时间⽚轮转调度算法" class="headerlink" title="时间⽚轮转调度算法:"></a>时间⽚轮转调度算法:</h4><blockquote><p>轮流的为各个进程服务，让每个进程在⼀定时间间隔内都可以得到响应<br>由于⾼频率的进程切换，会增加了开销，且不区分任务的紧急程度</p></blockquote><h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法:"></a>优先级调度算法:</h3><blockquote><p>根据任务的紧急程度进⾏调度，⾼优先级的先处理，低优先级的慢处理<br>如果⾼优先级任务很多且持续产⽣，那低优先级的就可能很慢才被处理</p></blockquote><h2 id="线程的调度算法"><a href="#线程的调度算法" class="headerlink" title="线程的调度算法"></a>线程的调度算法</h2><h3 id="协同式线程调度-分时调度模式-："><a href="#协同式线程调度-分时调度模式-：" class="headerlink" title="协同式线程调度(分时调度模式)："></a>协同式线程调度(分时调度模式)：</h3><blockquote><p>线程执⾏时间由线程本身来控制，线程把⾃⼰的⼯作执⾏完之后，<br>要主动通知系统切换到另外⼀个线程上。最⼤好处是实现简单，且切换操作对线程⾃⼰是可知的，没<br>啥线程同步问题。坏处是线程执⾏时间不可控制，如果⼀个线程有问题，可能⼀直阻塞在那⾥</p></blockquote><blockquote><p>(佛系顺序执行，自己完事叫下一个继续)</p></blockquote><h3 id="抢占式线程调度："><a href="#抢占式线程调度：" class="headerlink" title="抢占式线程调度："></a>抢占式线程调度：</h3><blockquote><p>每个线程将由系统来分配执⾏时间，线程的切换不由线程本身来决定（Java中，<br>Thread.yield()可以让出执⾏时间，但⽆法获取执⾏时间）。线程执⾏时间系统可控，也不会有⼀<br>个线程导致整个进程阻塞</p></blockquote><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><blockquote><p>每次读写数据都是悲观的，认为可能会出现数据被其它线程读的问题，所以要上锁比如sychronized</p></blockquote><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote><p>每次读取数据都觉得是乐观的，觉得不会有其它线程更改要读取的数据</p></blockquote><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><blockquote><p>就是大家人人平等，都可以拿到锁，阻塞队列中按照顺序慢慢来=》reetrantlock（fair）</p></blockquote><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><blockquote><p>不公平的，只要你条件符合，就可以直接拿到锁=》reetrantlock（unfair）<br>reetrantlock其实底层就是一个队列，所以也是先来先服务那种，在公平锁体现的很好</p></blockquote><h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><blockquote><p>一个线程里吧，还调用另一个线程，然后这个锁对里面的这个线程也生效</p></blockquote><h3 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h3><blockquote><p>一个线程里吧，还调用另一个线程，然后吧，里面这个线程就不能用这个锁了，就只能乖巧的滚去阻塞队列了</p></blockquote><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><blockquote><p>就是想不开的锁，只要没条件获取到锁，就一直自旋，也就是一直去判断条件看看自己能不能获得锁子，while（flag）的感觉，除非获得锁才能结束，但是注意，自旋锁消耗cpu，毕竟在那转来转去的。<br>不会发⽣线程状态的切换，⼀直处于⽤户态，减少了线程上下⽂切换的消耗，缺点是循环会消耗CPU</p></blockquote><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><blockquote><p>也就是读锁，或者是S锁，就是可以让大家读取，查看，就是不能修改</p></blockquote><h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><blockquote><p>也就是霸占一把锁，只要这个线程占着，别人就不能去获取这个锁，但是只要霸占这个锁，能读能写</p></blockquote><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote><p>资源抢占矛盾循环了，无外力介入，是解不开的</p></blockquote><h3 id="关于jvm自己内部的几个锁"><a href="#关于jvm自己内部的几个锁" class="headerlink" title="关于jvm自己内部的几个锁"></a>关于jvm自己内部的几个锁</h3><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote><p>就是如果哪个线程一直用着这个锁，就一直让他先用，更少的消耗量</p></blockquote><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote><p>如果其他锁妄图获得人家那个偏向锁，那就自旋吧，等人家用完才给你</p></blockquote><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><blockquote><p>自选锁也不自旋了，直接阻塞进化成重量级锁，重量级锁会让其他申请的线程进⼊阻塞，性能也会降低</p></blockquote><h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String locka = <span class="string">"A"</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String lockb = <span class="string">"B"</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"entre the locka"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line">                System.out.println(<span class="string">"a 取 b"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"entre the lockb"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line">                System.out.println(<span class="string">"b 取 a"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">          System.out.println(i+<span class="number">1</span> + <span class="string">"次"</span>);</span><br><span class="line">          <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">              DeadLock.LockA();</span><br><span class="line">          &#125;).start();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">              DeadLock.LockB();</span><br><span class="line">          &#125;).start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解锁代码"><a href="#解锁代码" class="headerlink" title="解锁代码"></a>解锁代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String locka = <span class="string">"A"</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String lockb = <span class="string">"B"</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"entre the locka"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line">                System.out.println(<span class="string">"a 取 b"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lockb)&#123;</span><br><span class="line">            System.out.println(<span class="string">"entre the lockb"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (locka)&#123;</span><br><span class="line">            System.out.println(<span class="string">"b 取 a"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(i+<span class="number">1</span> + <span class="string">"次"</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                DeadLock.LockA();</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                DeadLock.LockB();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>改变运行策略，其实是线程A中syc获取了锁a，还要获取suob，这样子顺序执行下来是ok 的，就怕线程a获取了锁a后，线程b抢占获取了锁b，此使线程a还要锁b<br>就阻塞了，所以到了线程b又要获取锁a，那么就死锁了<br>解决方法也简单，就是让一个锁提早消失就好了，所以改变一下sychronize的次序，提早释放锁，就万事大吉了</p></blockquote><h3 id="死锁的四个条件"><a href="#死锁的四个条件" class="headerlink" title="死锁的四个条件"></a>死锁的四个条件</h3><blockquote><p>互斥条件：资源不能共享，只能由⼀个线程使⽤<br>请求与保持条件：线程已经获得⼀些资源，但因请求其他资源发⽣阻塞，对已经获得的资源保持不释放<br>不可抢占：有些资源是不可强占的，当某个线程获得这个资源后，系统不能强⾏回收，只能由线程使⽤完⾃⼰释放<br>循环等待条件：多个线程形成环形链，每个都占⽤对⽅申请的下个资源</p></blockquote><h2 id="重入锁和不可重入锁"><a href="#重入锁和不可重入锁" class="headerlink" title="重入锁和不可重入锁"></a>重入锁和不可重入锁</h2><h3 id="不可重入锁-1"><a href="#不可重入锁-1" class="headerlink" title="不可重入锁"></a>不可重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BcrLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">boolean</span> flag = <span class="keyword">false</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"进入加锁"</span>);</span><br><span class="line">            flag = <span class="keyword">true</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"进入等待状态"</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"进入解锁"</span>);</span><br><span class="line">        notify();</span><br><span class="line">        flag = <span class="keyword">false</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.Messaging.SYNC_WITH_TRANSPORT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BcrLock bcrLock = <span class="keyword">new</span> BcrLock() ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bcrLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法A加锁"</span> + bcrLock.flag);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bcrLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bcrLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法B加锁"</span> + bcrLock.flag);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bcrLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> TestMain().methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重入锁-1"><a href="#重入锁-1" class="headerlink" title="重入锁"></a>重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.ir.Block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> islock = <span class="keyword">false</span> ;</span><br><span class="line">    <span class="keyword">public</span> String currentThread = <span class="keyword">null</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentThread==<span class="keyword">null</span>) &#123;</span><br><span class="line">            currentThread = Thread.currentThread().getName();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentThread.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"成功加锁"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!currentThread.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"加锁失败"</span>);</span><br><span class="line">                    wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        notify();</span><br><span class="line">        currentThread = <span class="keyword">null</span> ;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"成功解锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runindark.crlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.awt.windows.ThemeReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMainB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CrLock crLock = <span class="keyword">new</span> CrLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            crLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法A加锁"</span> + crLock.currentThread);</span><br><span class="line">            methodB();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法a解锁"</span> );</span><br><span class="line">            crLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            crLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"方法B加锁"</span>+ crLock.currentThread );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法b解锁"</span> );</span><br><span class="line">            crLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">new</span> TestMainB().methodA();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">new</span> TestMainB().methodA();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized说说看"><a href="#synchronized说说看" class="headerlink" title="synchronized说说看"></a>synchronized说说看</h2><blockquote><p>非公平锁，原子性，可重入可以修饰代码块和方法<br>每个对象有⼀个锁和⼀个等待队列，锁只能被⼀个线程持有，其他需要锁的线程需要阻塞等待。锁被释放<br>后，对象会从队列中取出⼀个并唤醒，唤醒哪个线程是不确定的，不保证公平性<br>jdk6优化-&gt; 偏向锁-&gt;轻量级锁-&gt;重量级锁</p></blockquote><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h3><blockquote><p>CAS是一种乐观锁，CompareAndSwap，也就是比较再交换<br>执行过程大概如下： 首先是 内存地址V，预期原值A，新值B ， 如果线程A过来，V = A ,则满足条件把目标值更换成B，如果线程B过来，V ！= A，那么无法<br>将目标值更换成B，而且线程B将进行自旋，直到 A=V ，结束自旋，获取锁<br>缺点也将显而易见： 自旋锁的存在直接导致了cpu的消耗问题</p></blockquote><h3 id="ABA-问题由于CAS不保证原子性问题"><a href="#ABA-问题由于CAS不保证原子性问题" class="headerlink" title="ABA 问题由于CAS不保证原子性问题"></a>ABA 问题由于CAS不保证原子性问题</h3><blockquote><p>简单来说就是线程在操作过程中，有其它线程将该变量更改后，又有另一个线程把他改回来，到最开始线程操作的时候，发现该值没有变化，则该线程操作成<br>功。加一个版本号可以解决问题，每次修改时都要查看版本号</p></blockquote><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><blockquote><p>就是 java.util.concurrent (juc) 的一个工具包 全称是 AbstractQueuedSynchronizer  （抽象同步队列）<br>其中核心就是 一个int变量（用于表示同步状态），一个state（计数器），一个线程标记（谁加锁），一个阻塞队列（用于存储未拿到锁阻塞中的线程）</p></blockquote><h3 id="部分核心方法"><a href="#部分核心方法" class="headerlink" title="部分核心方法"></a>部分核心方法</h3><h3 id="acquire-int-arg-源码讲解，好⽐加锁lock操作"><a href="#acquire-int-arg-源码讲解，好⽐加锁lock操作" class="headerlink" title="acquire(int arg) 源码讲解，好⽐加锁lock操作"></a>acquire(int arg) 源码讲解，好⽐加锁lock操作</h3><ol><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回,AQS⾥⾯未实现但没有定义成<br>abstract，因为独占模式下只⽤实现tryAcquire-tryRelease，⽽共享模式下只⽤实现<br>tryAcquireShared-tryReleaseShared，类似设计模式⾥⾯的适配器模式</li><li>addWaiter() 根据不同模式将线程加⼊等待队列的尾部，有Node.EXCLUSIVE互斥模式、<br>Node.SHARED共享模式；如果队列不为空，则以通过compareAndSetTail⽅法以CAS将当前线程<br>节点加⼊到等待队列的末尾。否则通过enq(node)⽅法初始化⼀个等待队列</li><li>acquireQueued()使线程在等待队列中获取资源，⼀直获取到资源后才返回,如果在等待过程<br>中被中断，则返回true，否则返回false<h3 id="release-int-arg-源码讲解-好⽐解锁unlock"><a href="#release-int-arg-源码讲解-好⽐解锁unlock" class="headerlink" title="release(int arg)源码讲解 好⽐解锁unlock"></a>release(int arg)源码讲解 好⽐解锁unlock</h3>独占模式下线程释放指定量的资源，⾥⾯是根据tryRelease()的返回值来判断该线程是<br>否已经完成释放掉资源了；在⾃义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回<br>true，否则返回false<br>unparkSuccessor⽅法⽤于唤醒等待队列中下⼀个线程</li></ol><h2 id="ReentrantLock实现原理"><a href="#ReentrantLock实现原理" class="headerlink" title="ReentrantLock实现原理"></a>ReentrantLock实现原理</h2><blockquote><p>实现大致的思路是和AQS是一致的，ReentrantLock的实现是分为公平锁和非公平锁的，其中上层Lock（Accquire），Unlock（Release）上层一致，唯独在释放的时候有一点区别，公平锁的实现是直接去队列中去找，看看队列中是否有等待，如果有等待的话则排队，无等待的话就直接给锁，对应的方法也就是TryAccquire（） ，而非公平锁则直接判断是不是符合获取锁的条件CompareAndState，如果符合直接给锁，如果不符合，则是按照公平锁的方法处理</p></blockquote><h2 id="ReentrantLock和synchronized区别是什么？"><a href="#ReentrantLock和synchronized区别是什么？" class="headerlink" title="ReentrantLock和synchronized区别是什么？"></a>ReentrantLock和synchronized区别是什么？</h2><ol><li>ReentrantLock和synchronized都是独占锁</li><li>synchronized：<blockquote><p>· 是悲观锁会引起其他线程阻塞，java内置关键字，<br>· ⽆法判断是否获取锁的状态，锁可重⼊、不可中断、只能是⾮公平<br>· 加锁解锁的过程是隐式的,⽤户不⽤⼿动操作,优点是操作简单但显得不够灵活<br>· ⼀般并发场景使⽤⾜够、可以放在被递归执⾏的⽅法上,且不⽤担⼼线程最后能否正确<br>释放锁<br>· synchronized操作的应该是对象头中mark word，参考原先原理图⽚</p></blockquote></li><li>ReentrantLock：<blockquote><p>· 是个Lock接⼝的实现类，是悲观锁，<br>· 可以判断是否获取到锁，可重⼊、可判断、可公平可不公平<br>· 需要⼿动加锁和解锁,且解锁的操作尽量要放在finally代码块中,保证线程正确释放锁<br>· 在复杂的并发场景中使⽤在重⼊时要却确保重复获取锁的次数必须和重复释放锁的次数⼀样，否则可能导致 其他线程⽆法获得该锁。<br>· 创建的时候通过传进参数true创建公平锁,如果传⼊的是false或没传参数则创建的是⾮公平锁<br>· 底层不同是AQS的state和FIFO队列来控制加锁</p></blockquote></li></ol><h2 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock 读写锁"></a>ReentrantReadWriteLock 读写锁</h2><blockquote><p>读写锁其实就是一个分离的ReentrantLock,由于ReentrantLock无论读或者写都是加锁的，但是读其实是安全的，盲目加锁只能过多的消耗资源，所以应该<br>只有写是独占锁，写则是排他锁，这样子才可以优化资源，流程一般是获取写锁，获取读锁，释放写锁，释放读锁。<br>虽然也是重入锁，但是写可以重入读或者写，但是读就只能重入读</p></blockquote><h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h2><blockquote><p>j.u.c包下的提供了线程安全的队列访问的接⼝，并发包下很多⾼级同步类的实现都是基于阻塞队列实现的<br>1、当阻塞队列进⾏插⼊数据时，如果队列已满，线程将会阻塞等待直到队列⾮满<br>2、从阻塞队列读数据时，如果队列为空，线程将会阻塞等待直到队列⾥⾯是⾮空的时候</p></blockquote><h3 id="ArrayBlockingQueue："><a href="#ArrayBlockingQueue：" class="headerlink" title="ArrayBlockingQueue："></a>ArrayBlockingQueue：</h3><blockquote><p>基于数组实现的⼀个阻塞队列，需要指定容量⼤⼩，FIFO先进先出顺序</p></blockquote><h3 id="LinkedBlockingQueue："><a href="#LinkedBlockingQueue：" class="headerlink" title="LinkedBlockingQueue："></a>LinkedBlockingQueue：</h3><blockquote><p>基于链表实现的⼀个阻塞队列，如果不指定容量⼤⼩，默认Integer.MAX_VALUE, FIFO先进先出顺序</p></blockquote><h3 id="PriorityBlockingQueue："><a href="#PriorityBlockingQueue：" class="headerlink" title="PriorityBlockingQueue："></a>PriorityBlockingQueue：</h3><blockquote><p>⼀个⽀持优先级的⽆界阻塞队列，默认情况下元素采⽤⾃然顺序升序排序，也可以⾃定义排序实现 java.lang.Comparable接⼝</p></blockquote><h3 id="DelayQueue："><a href="#DelayQueue：" class="headerlink" title="DelayQueue："></a>DelayQueue：</h3><blockquote><p>延迟队列，在指定时间才能获取队列元素的功能，队列头元素是最接近过期的元素，⾥⾯的对象必须实现 java.util.concurrent.Delayed 接⼝并实现<br>CompareTo和getDelay⽅法</p></blockquote><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><blockquote><p>并发队列ConcurrentLinkedQueue是基于链表实现的⽆界线程安全队列，采⽤FIFO进⾏排序<br>保证线程安全的三要素：原⼦、有序、可⻅性<br>1、底层结构是Node，链表头部和尾部节点是head和tail，使⽤节点变量和内部类属性使⽤<br>volatile声明保证了有序和可⻅性<br>2、插⼊、移除、更新操作使⽤CAS⽆锁操作，保证了原⼦性</p></blockquote><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote><p>提⾼系统资源的使⽤率，同时避免过多资源竞争，避免堵塞，且可以定时定期执⾏、单线程、并发数控制，配置任务过多任务后的拒绝策略等功能</p></blockquote><h3 id="线程池分类"><a href="#线程池分类" class="headerlink" title="线程池分类"></a>线程池分类</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><blockquote><p>⼀个定⻓线程池，可控制线程最⼤并发数</p></blockquote><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><blockquote><p>⼀个可缓存线程池</p></blockquote><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><blockquote><p>⼀个单线程化的线程池，⽤唯⼀的⼯作线程来执⾏任务</p></blockquote><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><blockquote><p>⼀个定⻓线程池，⽀持定时/周期性任务执⾏</p></blockquote><h3 id="线程池踩坑"><a href="#线程池踩坑" class="headerlink" title="线程池踩坑"></a>线程池踩坑</h3><h4 id="推荐ThreadPoolExecutor的⽅式原因"><a href="#推荐ThreadPoolExecutor的⽅式原因" class="headerlink" title="推荐ThreadPoolExecutor的⽅式原因"></a>推荐ThreadPoolExecutor的⽅式原因</h4><ol><li>newFixedThreadPool和newSingleThreadExecutor:<blockquote><p>队列使⽤LinkedBlockingQueue，队列⻓度为 Integer.MAX_VALUE，可能造成堆积，导致OOM</p></blockquote></li><li>newScheduledThreadPool和newCachedThreadPool:         <blockquote><p>线程池⾥⾯允许最⼤的线程数是Integer.MAX_VALUE，可能会创建过多线程，导致OOM</p></blockquote><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><h4 id="corePoolSize："><a href="#corePoolSize：" class="headerlink" title="corePoolSize："></a>corePoolSize：</h4><blockquote><p>核⼼线程数，线程池也会维护线程的最少数量，默认情况下核⼼线程会⼀直存活，即使没有任务也不会受存keepAliveTime控制<br>坑：在刚创建线程池时线程不会⽴即启动，到有任务提交时才开始创建线程并逐步线程数⽬达到corePoolSize</p></blockquote><h4 id="maximumPoolSize："><a href="#maximumPoolSize：" class="headerlink" title="maximumPoolSize："></a>maximumPoolSize：</h4><blockquote><p>线程池维护线程的最⼤数量，超过将被阻塞<br>坑：当核⼼线程满，且阻塞队列也满时，才会判断当前线程数是否⼩于最⼤线程数，才决定是否创建新线程</p></blockquote><h4 id="keepAliveTime："><a href="#keepAliveTime：" class="headerlink" title="keepAliveTime："></a>keepAliveTime：</h4><blockquote><p>⾮核⼼线程的闲置超时时间，超过这个时间就会被回收，直到线程数量等于corePoolSize</p></blockquote><h4 id="unit："><a href="#unit：" class="headerlink" title="unit："></a>unit：</h4><blockquote><p>指定keepAliveTime的单位，如TimeUnit.SECONDS、TimeUnit.MILLISECONDS</p></blockquote><h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue:"></a>workQueue:</h4><blockquote><p>线程池中的任务队列,常⽤的是 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue</p></blockquote><h4 id="threadFactory："><a href="#threadFactory：" class="headerlink" title="threadFactory："></a>threadFactory：</h4><blockquote><p>创建新线程时使⽤的⼯⼚</p></blockquote><h4 id="handler"><a href="#handler" class="headerlink" title="handler:"></a>handler:</h4><blockquote><p>RejectedExecutionHandler是⼀个接⼝且只有⼀个⽅法,线程池中的数量⼤于maximumPoolSize，对拒绝任务的处理策略，默认有4种策略AbortPolicy、<br>CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy</p></blockquote></li></ol><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><a href="https://www.cnblogs.com/aspirant/p/8991010.html" target="_blank" rel="noopener">博文地址</a></p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·Java集合》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/05/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-Java%E9%9B%86%E5%90%88/"/>
    <id>http://runindark.com/2020/03/05/2020春招/我为阿里-Java集合/</id>
    <published>2020-03-05T15:05:46.737Z</published>
    <updated>2020-06-28T01:43:26.138Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br>[文章都是搬运艿艿的]<br>[<a href="http://svip.iocoder.cn/Java/Core/Interview/]" target="_blank" rel="noopener">http://svip.iocoder.cn/Java/Core/Interview/]</a></excerpt></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="Java集合概述图"><a href="#Java集合概述图" class="headerlink" title="Java集合概述图"></a>Java集合概述图</h3><p><a href="https://upload-images.jianshu.io/upload_images/1637925-3ef7a86d5856e763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/747/format/jpeg" target="_blank" rel="noopener">概述图</a></p><h3 id="说出一些集合框架的优点？"><a href="#说出一些集合框架的优点？" class="headerlink" title="说出一些集合框架的优点？"></a>说出一些集合框架的优点？</h3><ol><li>使用核心集合类降低开发成本，而非实现我们自己的集合类。</li><li>随着使用经过严格测试的集合框架类，代码质量会得到提高。</li><li>通过使用 JDK 附带的集合类，可以降低代码维护成本。</li><li>复用性和可操作性。<h3 id="集合框架中的泛型有什么优点？"><a href="#集合框架中的泛型有什么优点？" class="headerlink" title="集合框架中的泛型有什么优点？"></a>集合框架中的泛型有什么优点？</h3><blockquote><p>Java5 引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型。因此，如果你添加其它类型的任何元素，它会在<br>编译时报错。这避免了在运行时出现 ClassCastException，因为你将会在编译时得到报错信息。</p></blockquote></li></ol><blockquote><p>泛型也使得代码整洁，我们不需要使用显式转换和 instanceOf 操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令</p></blockquote><h3 id="Java-集合框架的基础接口有哪些？"><a href="#Java-集合框架的基础接口有哪些？" class="headerlink" title="Java 集合框架的基础接口有哪些？"></a>Java 集合框架的基础接口有哪些？</h3><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><blockquote><p>为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java 平台不提供这个接口任何直接的实现。</p></blockquote><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><blockquote><p>是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List 更像长度动态变换的数组。</p></blockquote><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><blockquote><p>是一个将 key 映射到 value 的对象。一个 Map 不能包含重复的 key，每个 key 最多只能映射一个 value 。</p></blockquote><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>一些其它的接口有 Queue、Dequeue、SortedSet、SortedMap 和 ListIterator 。</p><h3 id="为何-Collection-不从-Cloneable-和-Serializable-接口继承？"><a href="#为何-Collection-不从-Cloneable-和-Serializable-接口继承？" class="headerlink" title="为何 Collection 不从 Cloneable 和 Serializable 接口继承？"></a>为何 Collection 不从 Cloneable 和 Serializable 接口继承？</h3><blockquote><p>Collection 接口指定一组对象，对象即为它的元素<br>如何维护这些元素由 Collection 的具体实现决定。例如，一些如 List 的 Collection 实现允许重复的元素，而其它的如 Set 就不允许。<br>很多 Collection 实现有一个公有的 clone 方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为 Collection 是一个抽象表现，重要的是实现。</p></blockquote><h3 id="为何-Map-接口不继承-Collection-接口？"><a href="#为何-Map-接口不继承-Collection-接口？" class="headerlink" title="为何 Map 接口不继承 Collection 接口？"></a>为何 Map 接口不继承 Collection 接口？</h3><blockquote><p>尽管 Map 接口和它的实现也是集合框架的一部分，但 Map 不是集合，集合也不是 Map。因此，Map 继承 Collection 毫无意义，反之亦然。<br>如果 Map 继承 Collection 接口，那么元素去哪儿？Map 包含 key-value 对，它提供抽取 key 或 value 列表集合( Collection )的方法，但是它不适合<br>“一组对象”规范。</p></blockquote><h3 id="Collection-和-Collections-的区别？"><a href="#Collection-和-Collections-的区别？" class="headerlink" title="Collection 和 Collections 的区别？"></a>Collection 和 Collections 的区别？</h3><blockquote><p>Collection ，是集合类的上级接口，继承与他的接口主要有 Set 和List 。<br>Collections ，是针对集合类的一个工具类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p></blockquote><h3 id="集合框架里实现的通用算法有哪些？"><a href="#集合框架里实现的通用算法有哪些？" class="headerlink" title="集合框架里实现的通用算法有哪些？"></a>集合框架里实现的通用算法有哪些？</h3><blockquote><p>Java 集合框架提供常用的算法实现，比如排序和搜索。<br>Collections类包含这些方法实现。大部分算法是操作 List 的，但一部分对所有类型的集合都是可用的。部分算法有排序、搜索、混编、最大最小值。</p></blockquote><h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><h3 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h3><blockquote><ol><li>ArrayList ：Object 数组。</li><li>Vector ：Object 数组。</li><li>LinkedList ：双向链表(JDK6 之前为循环链表，JDK7 取消了循环)。</li></ol></blockquote><h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><blockquote><ol><li>HashMap ：<br>JDK8 之前，HashMap 由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。<br>JDK8 以后，在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）时，将链表转化为红黑树，以减少搜索时间。</li><li>LinkedHashMap ：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上<br>面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查<br>看：《LinkedHashMap 源码详细分析（JDK1.8）》 。</li><li>Hashtable ：数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li>TreeMap ：红黑树（自平衡的排序二叉树）。</li></ol></blockquote><h3 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h3><p>HashSet ：无序，唯一，基于 HashMap 实现的，底层采用 HashMap 来保存元素。<br>LinkedHashSet ：LinkedHashSet 继承自 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。<br>TreeSet ：有序，唯一，红黑树(自平衡的排序二叉树)。</p><h3 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h3><blockquote><p>Iterator 接口，提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元<br>素，但是不可以直接调用集合的 #remove(Object Obj) 方法删除，可以通过迭代器的 #remove() 方法删除。</p></blockquote><h4 id="Iterator-和-ListIterator-的区别是什么？"><a href="#Iterator-和-ListIterator-的区别是什么？" class="headerlink" title="Iterator 和 ListIterator 的区别是什么？"></a>Iterator 和 ListIterator 的区别是什么？</h4><blockquote><p>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。<br>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能。比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。</p></blockquote><h4 id="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"><a href="#快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？" class="headerlink" title="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"></a>快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？</h4><blockquote><p>差别在于 ConcurrentModification 异常：<br>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 java.util 包下的都是快速失败。<br>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。在 java.util.concurrent 包下的全是安全失败的。</p></blockquote><h4 id="如何删除-List-中的某个元素？"><a href="#如何删除-List-中的某个元素？" class="headerlink" title="如何删除 List 中的某个元素？"></a>如何删除 List 中的某个元素？</h4><blockquote><p>方式一，使用 Iterator ，顺序向下，如果找到元素，则使用 remove 方法进行移除。<br>方式二，倒序遍历 List ，如果找到元素，则使用 remove 方法进行移除。</p></blockquote><h4 id="Enumeration-和-Iterator-接口有什么不同？"><a href="#Enumeration-和-Iterator-接口有什么不同？" class="headerlink" title="Enumeration 和 Iterator 接口有什么不同？"></a>Enumeration 和 Iterator 接口有什么不同？</h4><blockquote><p>Enumeration 跟 Iterator 相比较快两倍，而且占用更少的内存。<br>但是，Iterator 相对于 Enumeration 更安全，因为其他线程不能修改当前迭代器遍历的集合对象。同时，Iterators 允许调用者从底层集合中移除元素，这些 Enumerations 都没法完成。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationTester</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">      Enumeration&lt;String&gt; days;</span><br><span class="line">      Vector&lt;String&gt; dayNames = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">      dayNames.add(<span class="string">"Sunday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Monday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Tuesday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Wednesday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Thursday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Friday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Saturday"</span>);</span><br><span class="line">      days = dayNames.elements();</span><br><span class="line">      <span class="keyword">while</span> (days.hasMoreElements())&#123;</span><br><span class="line">         System.out.println(days.nextElement()); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为何-Iterator-接口没有具体的实现？"><a href="#为何-Iterator-接口没有具体的实现？" class="headerlink" title="为何 Iterator 接口没有具体的实现？"></a>为何 Iterator 接口没有具体的实现？</h4><blockquote><p>Iterator 接口，定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的 Iterator 的集合类都有它自己的 Iterator 实现内部类。<br>这就允许集合类去选择迭代器是 fail-fast 还是 fail-safe 的。比如，ArrayList 迭代器是 fail-fast 的，而 CopyOnWriteArrayList 迭代器是 fail-safe 的。</p></blockquote><h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别?"></a>Comparable 和 Comparator 的区别?</h3><blockquote><p>Comparable 接口，在 java.lang 包下，用于当前对象和其它对象的比较，所以它有一个 #compareTo(Object obj) 方法用来排序，该方法只有一个参数。<br>Comparator 接口，在 java.util 包下，用于传入的两个对象的比较，所以它有一个 #compare(Object obj1, Object obj2) 方法用来排序，该方法有两个参数。</p></blockquote><h4 id="compareTo-方法的返回值表示的意思？"><a href="#compareTo-方法的返回值表示的意思？" class="headerlink" title="compareTo 方法的返回值表示的意思？"></a>compareTo 方法的返回值表示的意思？</h4><blockquote><p>· 大于 0 ，表示对象大于参数对象。<br>· 小于 0 ，表示对象小于参数对象<br>· 等于 0 ，表示两者相等。</p></blockquote><h4 id="如何对-Object-的-List-排序？"><a href="#如何对-Object-的-List-排序？" class="headerlink" title="如何对 Object 的 List 排序？"></a>如何对 Object 的 List 排序？</h4><blockquote><p>对 Object[] 数组进行排序时，我们可以用 Arrays#sort(…) 方法。<br>对 List<object> 数组进行排序时，我们可以用 Collections#sort(…) 方法。</object></p></blockquote><h3 id="List-VS-Set"><a href="#List-VS-Set" class="headerlink" title="List VS Set"></a>List VS Set</h3><h4 id="List-和-Set-区别？"><a href="#List-和-Set-区别？" class="headerlink" title="List 和 Set 区别？"></a>List 和 Set 区别？</h4><blockquote><p>List，Set 都是继承自 Collection 接口。<br>· List 特点：元素有放入顺序，元素可重复。<br>· Set 特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉。</p></blockquote><blockquote><p>注意：元素虽然无放入顺序，但是元素在 Set 中的位置是有该元素的 hashcode 决定的，其位置其实是固定的。<br>另外 List 支持 for 循环，也就是通过下标来遍历，也可以用迭代器，但是 Set 只能用迭代，因为他无序，无法用下标来取得想要的值。</p></blockquote><h4 id="Set-和-List-对比："><a href="#Set-和-List-对比：" class="headerlink" title="Set 和 List 对比："></a>Set 和 List 对比：</h4><blockquote><p>Set：检索指定的元素效率高，删除和插入效率高，插入和删除可能会引起元素位置改变。<br>List：和数组类似，List 可以动态增长，查找指定的元素效率低，插入删除指定的元素效率低，因为可能会引起其他元素位置改变。</p></blockquote><h3 id="Array系-VS-List系"><a href="#Array系-VS-List系" class="headerlink" title="Array系 VS List系"></a>Array系 VS List系</h3><h4 id="Array-和-ArrayList-有何区别？什么时候更适合用-Array？"><a href="#Array-和-ArrayList-有何区别？什么时候更适合用-Array？" class="headerlink" title="Array 和 ArrayList 有何区别？什么时候更适合用 Array？"></a>Array 和 ArrayList 有何区别？什么时候更适合用 Array？</h4><blockquote><p>Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。<br>Array 是指定大小的，而 ArrayList 大小是固定的，可自动扩容。<br>Array 没有提供 ArrayList 那么多功能，比如 addAll、removeAll 和 iterator 等。<br>尽管 ArrayList 明显是更好的选择，但也有些时候 Array 比较好用，比如下面的三种情况。</p></blockquote><blockquote><p>1、如果列表的大小已经指定，大部分情况下是存储和遍历它们<br>2、对于遍历基本数据类型，尽管 Collections 使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。<br>3、如果你要使用多维数组，使用 [][] 比 List 会方便。</p></blockquote><h4 id="ArrayList-与-LinkedList-区别？"><a href="#ArrayList-与-LinkedList-区别？" class="headerlink" title="ArrayList 与 LinkedList 区别？"></a>ArrayList 与 LinkedList 区别？</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><blockquote><p>优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。<br>缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</p></blockquote><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><blockquote><p>优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作 add 和 remove ，LinedList 比较占优势。LinkedList 适用于要头尾操<br>作或插入指定位置的场景。<br>缺点：因为 LinkedList 要移动指针，所以查询操作性能比较低。</p></blockquote><h5 id="适用场景分析："><a href="#适用场景分析：" class="headerlink" title="适用场景分析："></a>适用场景分析：</h5><blockquote><p>当需要对数据进行对随机访问的情况下，选用 ArrayList 。<br>当需要对数据进行多次增加删除修改时，采用 LinkedList 。</p></blockquote><h4 id="ArrayList-是如何扩容的？"><a href="#ArrayList-是如何扩容的？" class="headerlink" title="ArrayList 是如何扩容的？"></a>ArrayList 是如何扩容的？</h4><blockquote><p>如果通过无参构造的话，初始数组容量为 0 ，当真正对数组进行添加时，才真正分配容量。每次按照 1.5 倍（位运算）的比率通过 copeOf 的方式扩容。<br>在 JKD6 中实现是，如果通过无参构造的话，初始数组容量为10，每次通过 copeOf 的方式扩容后容量为原来的 1.5 倍。</p></blockquote><h4 id="ArrayList-与-Vector-区别？"><a href="#ArrayList-与-Vector-区别？" class="headerlink" title="ArrayList 与 Vector 区别？"></a>ArrayList 与 Vector 区别？</h4><p>rrayList 和 Vector 都是用数组实现的，主要有这么三个区别：</p><blockquote><ol><li>Vector 是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果，而 ArrayList 不是。这个可以从源码中看出，Vector 类中的方法很多有 synchronized 进行修饰，这样就导致<br>了 Vector 在效率上无法与 ArrayList 相比。</li><li>两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。</li><li>Vector 可以设置增长因子，而 ArrayList 不可以</li></ol></blockquote><blockquote><p>Vector 是线程同步的，所以它也是线程安全的，而 ArrayList 是线程无需同步的，是不安全的。如果不考虑到线程的安全因素，一般用 ArrayList 效率比较高。<br>实际场景下，如果需要多线程访问安全的数组，使用 CopyOnWriteArrayList 。<br>如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用 Vector 有一定的优势。</p></blockquote><h3 id="HashMap-和-Hashtable-的区别？"><a href="#HashMap-和-Hashtable-的区别？" class="headerlink" title="HashMap 和 Hashtable 的区别？"></a>HashMap 和 Hashtable 的区别？</h3><blockquote><ol><li>Hashtable 是在 Java 1.0 的时候创建的，而集合的统一规范命名是在后来的 Java2.0 开始约定的，而当时其他一部分集合类的发布构成了新的集合框架。<br>Hashtable 继承 Dictionary ，HashMap 继承的是 Java2 出现的 Map 接口。</li><li>HashMap 去掉了 Hashtable 的 contains 方法，但是加上了 containsValue 和 containsKey 方法。</li><li>HashMap 允许空键值，而 Hashtable 不允许。<br>【重点】4. HashTable 是同步的，而 HashMap 是非同步的，效率上比 HashTable 要高。也因此，HashMap 更适合于单线程环境，而 HashTable 适合于多线程环境。</li><li>HashMap 的迭代器（Iterator）是 fail-fast 迭代器，HashTable的 enumerator 迭代器不是 fail-fast 的。</li><li>HashTable 中数组默认大小是 11 ，扩容方法是 old * 2 + 1 ，HashMap 默认大小是 16 ，扩容每次为 2 的指数大小。<br>即使在多线程环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用 Hashtable </li></ol></blockquote><h3 id="HashSet-和-HashMap-的区别？"><a href="#HashSet-和-HashMap-的区别？" class="headerlink" title="HashSet 和 HashMap 的区别？"></a>HashSet 和 HashMap 的区别？</h3><blockquote><p>Set 是线性结构，值不能重复。HashSet 是 Set 的 hash 实现，HashSet 中值不能重复是用 HashMap 的 key 来实现的。<br>Map 是键值对映射，可以空键空值。HashMap 是 Map 的 hash 实现，key 的唯一性是通过 key 值 hashcode 的唯一来确定，value 值是则是链表结构</p></blockquote><h3 id="HashSet-和-TreeSet-的区别？"><a href="#HashSet-和-TreeSet-的区别？" class="headerlink" title="HashSet 和 TreeSet 的区别？"></a>HashSet 和 TreeSet 的区别？</h3><blockquote><p>HashSet 是用一个 hash 表来实现的，因此，它的元素是无序的。添加，删除和 HashSet 包括的方法的持续时间复杂度是 O(1) 。<br>TreeSet 是用一个树形结构实现的，因此，它是有序的。添加，删除和 TreeSet 包含的方法的持续时间复杂度是 O(logn) 。</p></blockquote><h3 id="如何决定选用-HashMap-还是-TreeMap？"><a href="#如何决定选用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定选用 HashMap 还是 TreeMap？"></a>如何决定选用 HashMap 还是 TreeMap？</h3><blockquote><p>对于在 Map 中插入、删除和定位元素这类操作，HashMap 是最好的选择。<br>然而，假如你需要对一个有序的 key 集合进行遍历， TreeMap 是更好的选择。</p></blockquote><h3 id="HashMap-和-ConcurrentHashMap-的区别？"><a href="#HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别？"></a>HashMap 和 ConcurrentHashMap 的区别？</h3><p>ConcurrentHashMap 是线程安全的 HashMap 的实现。主要区别如下：</p><blockquote><p>1、ConcurrentHashMap 对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用 lock 锁进行保护，相对 于Hashtable 的 syn 关键字锁的粒度更精细了一些，并发性能更好。而 HashMap 没有<br>锁机制，不是线程安全的。<br>JDK8 之后，ConcurrentHashMap 启用了一种全新的方式实现,利用 CAS 算法。<br>2、HashMap 的键值对允许有 null ，但是 ConCurrentHashMap 都不允许。</p></blockquote><h3 id="HashMap-的工作原理是什么？"><a href="#HashMap-的工作原理是什么？" class="headerlink" title="HashMap 的工作原理是什么？"></a>HashMap 的工作原理是什么？</h3><p><a href="http://dl2.iteye.com/upload/attachment/0017/7479/3f05dd61-955e-3eb2-bf8e-31da8a361148.jpg" target="_blank" rel="noopener">HashMap</a></p><blockquote><p>我们知道在 Java 中最常用的两种结构是数组和模拟指针（引用），几乎所有的数据结构都可以利用这两种来组合实现，HashMap 也是如此。实际上 HashMap 是一个“链表散列”。<br>HashMap 是基于 hashing 的原理。</p></blockquote><h4 id="当两个对象的-hashCode-相同会发生什么？"><a href="#当两个对象的-hashCode-相同会发生什么？" class="headerlink" title="当两个对象的 hashCode 相同会发生什么？"></a>当两个对象的 hashCode 相同会发生什么？</h4><blockquote><p>因为 hashcode 相同，所以它们的 bucket 位置相同，“碰撞”会发生。<br>因为 HashMap 使用链表存储对象，这个 Entry（包含有键值对的 Map.Entry 对象）会存储在链表中。</p></blockquote><h4 id="HashMap-默认容量是多少？"><a href="#HashMap-默认容量是多少？" class="headerlink" title="HashMap 默认容量是多少？"></a>HashMap 默认容量是多少？</h4><blockquote><p>默认容量都是 16 ，负载因子是 0.75 。就是当 HashMap 填充了 75% 的 busket 是就会扩容，最小的可能性是（16 * 0.75 = 12），一般为原内存的 2 倍。</p></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;[文章都是搬运艿艿的]&lt;br&gt;[&lt;a href=&quot;http://svip.iocoder.cn/Java/Core/Interview/]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://svip.iocoder.cn/Java/Core/Interview/]&lt;/a&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《天净沙·我·Java基础》  双非菜鸡奇葩，面试项目框架，java java，卑微学子去哪？</title>
    <link href="http://runindark.com/2020/03/04/2020%E6%98%A5%E6%8B%9B/%E6%88%91%E4%B8%BA%E9%98%BF%E9%87%8C-Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://runindark.com/2020/03/04/2020春招/我为阿里-Java基础/</id>
    <published>2020-03-04T15:47:00.777Z</published>
    <updated>2020-06-28T01:43:26.140Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>别问 问就是为了面试豁出了老命<br>[文章都是搬运艿艿的]<br>[<a href="http://svip.iocoder.cn/Java/Core/Interview/]" target="_blank" rel="noopener">http://svip.iocoder.cn/Java/Core/Interview/]</a></excerpt></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h4 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h4><blockquote><p>面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java 是一个支持并发、基于类和面向对象的计算机编程语言。面向对象&gt;软件开发具有以下优点：</p></blockquote><blockquote><p>· 代码开发模块化，更易维护和修改。<br>· 代码复用性强。<br>· 增强代码的可靠性和灵活性。<br>· 增加代码的可读性。</p></blockquote><h4 id="请说说面向对象的特征"><a href="#请说说面向对象的特征" class="headerlink" title="请说说面向对象的特征"></a>请说说面向对象的特征</h4><blockquote><p>封装、继承、多态、抽象</p></blockquote><h4 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h4><blockquote><p>1）重写 override<br>· 方法名、参数、返回值相同。<br>· 子类方法不能缩小父类方法的访问权限。<br>· 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。<br>· 存在于父类和子类之间。<br>· 方法被定义为 final 不能被重写。<br>2）重载 overload<br>· 参数类型、个数、顺序至少有一个不相同。<br>· 不能重载只有返回值不同的方法名。<br>· 存在于父类和子类、同类中。</p></blockquote><h4 id="Java-中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？"><a href="#Java-中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？" class="headerlink" title="Java 中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？"></a>Java 中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？</h4><blockquote><p>1）构造方法<br>当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java 编译器会为这个类创建一个默认的构造方法。<br>2）构造方法重载<br>Java 中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。<br>3）拷贝构造方法<br>Java 不支持像 C++ 中那样的拷贝构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java 不会创建默认的拷贝构造方法。</p></blockquote><h4 id="JDK、JRE、JVM-分别是什么关系？"><a href="#JDK、JRE、JVM-分别是什么关系？" class="headerlink" title="JDK、JRE、JVM 分别是什么关系？"></a>JDK、JRE、JVM 分别是什么关系？</h4><blockquote><p>JDK 即为 Java 开发工具包，包含编写 Java 程序所必须的编译、运行等开发工具以及 JRE。开发工具如：<br>· 用于编译 Java 程序的 javac 命令。<br>· 用于启动 JVM 运行 Java 程序的 Java 命令。<br>· 用于生成文档的 Javadoc 命令。<br>· 用于打包的 jar 命令等等。<br>简单说，就是 JDK 包含 JRE 包含 JVM<br>JRE 即为 Java 运行环境，提供了运行 Java 应用程序所必须的软件环境，包含有 Java 虚拟机（JVM）和丰富的系统类库。系统类库即为 Java 提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。<br>JVM 即为 Java 虚拟机，提供了字节码文件(.class)的运行环境支持</p></blockquote><h4 id="为什么-Java-被称作是“平台无关的编程语言”？"><a href="#为什么-Java-被称作是“平台无关的编程语言”？" class="headerlink" title="为什么 Java 被称作是“平台无关的编程语言”？"></a>为什么 Java 被称作是“平台无关的编程语言”？</h4><blockquote><p>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。<br>Java 源文件( .java )被编译成能被 Java 虚拟机执行的字节码文件( .class )。<br>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p></blockquote><h4 id="JDK8-引入了什么重要的特性"><a href="#JDK8-引入了什么重要的特性" class="headerlink" title="JDK8 引入了什么重要的特性?"></a>JDK8 引入了什么重要的特性?</h4><blockquote><p>Lambda 表达式和集合之流式</p></blockquote><h4 id="什么是字节码？采用字节码的最大好处是什么"><a href="#什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么"></a>什么是字节码？采用字节码的最大好处是什么</h4><blockquote><p>Java 源代码=&gt; 编译器 =&gt; JVM 可执行的 Java 字节码(即虚拟指令)=&gt; JVM =&gt; JVM 中解释器 =&gt; 机器可执行的二进制机器码 =&gt; 程序运行<br>Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。<br>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做字节码（即扩展名为 .class 的文件），它不<br>面向任何特定的处理器，只面向虚拟机。<br>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的<br>机器码，然后在特定的机器上运行。这也就是解释了 Java 的编译与解释并存的特点。<br>字节码的好处<br>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，<br>因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p></blockquote><h4 id="Java-中的几种基本数据类型是什么？"><a href="#Java-中的几种基本数据类型是什么？" class="headerlink" title="Java 中的几种基本数据类型是什么？"></a>Java 中的几种基本数据类型是什么？</h4><blockquote><p>引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中<br>· 引用类型包括类、接口、数组等。<br>· 特别注意，String 是引用类型不是基本类型。</p></blockquote><h4 id="什么是值传递和引用传递？"><a href="#什么是值传递和引用传递？" class="headerlink" title="什么是值传递和引用传递？"></a>什么是值传递和引用传递？</h4><blockquote><p>· 值传递，是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。<br>· 引用传递，一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身<br>一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递</p></blockquote><h4 id="是否可以在-static-环境中访问非-static-变量？"><a href="#是否可以在-static-环境中访问非-static-变量？" class="headerlink" title="是否可以在 static 环境中访问非 static 变量？"></a>是否可以在 static 环境中访问非 static 变量？</h4><blockquote><p>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。<br>如果你的代码尝试不用实例来访问非 static 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p></blockquote><h4 id="char-型变量中能不能存贮一个中文汉字？为什么？"><a href="#char-型变量中能不能存贮一个中文汉字？为什么？" class="headerlink" title="char 型变量中能不能存贮一个中文汉字？为什么？"></a>char 型变量中能不能存贮一个中文汉字？为什么？</h4><blockquote><p>在 Java 语言中，char 类型占 2 个字节，而且 Java 默认采用 Unicode 编码，一个 Unicode 码是 16 位，所以一个 Unicode 码占两个字节，Java 中无论汉字还是英文字母，都是用 Unicode 编码来表<br>示的。所以，在 Java 中，char 类型变量可以存储一个中文汉字。</p></blockquote><h4 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h4><blockquote><ol><li>String ，是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的<br>(每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。)</li><li>StringBuffer/StringBuilder 类，表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的<br>所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。<br>(StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。<br>相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险)</li></ol></blockquote><h4 id="String-s-new-String-“xyz”-会创建几个对象？"><a href="#String-s-new-String-“xyz”-会创建几个对象？" class="headerlink" title="String s = new String(“xyz”) 会创建几个对象？"></a>String s = new String(“xyz”) 会创建几个对象？</h4><blockquote><p>首先，在 String 池内找，找到 “xyz” 字符串，不创建 “xyz” 对应的 String 对象，否则创建一个对象。<br>然后，遇到 new 关键字，在内存上创建 String 对象，并将其返回给 s ，又一个对象。<br>所以，总共是 1 个或者 2 个对象。</p></blockquote><h4 id="什么是自动拆装箱？"><a href="#什么是自动拆装箱？" class="headerlink" title="什么是自动拆装箱？"></a>什么是自动拆装箱？</h4><blockquote><p>自动装箱和拆箱，就是基本类型和引用类型之间的转换。</p></blockquote><h5 id="为什么要转换？"><a href="#为什么要转换？" class="headerlink" title="为什么要转换？"></a>为什么要转换？</h5><blockquote><p>如果你在 Java5 下进行过编程的话，你一定不会陌生这一点，你不能直接地向集合( Collection )中放入原始类型值，因为集合只接收对象。</p><ol><li>通常这种情况下你的做法是，将这些原始类型的值转换成对象，然后将这些转换的对象放入集合中。使用 Integer、Double、Boolean 等这些类，我们可以将原始类型值转换成对应的对象，但是从某些程度可<br>能使得代码不是那么简洁精炼。</li><li>为了让代码简练，Java5 引入了具有在原始类型和对象类型自动转换的装箱和拆箱机制。<br>但是自动装箱和拆箱并非完美，在使用时需要有一些注意事项，如果没有搞明白自动装箱和拆箱，可能会引起难以察觉的 Bug 。</li></ol></blockquote><h4 id="equals-与-的区别？"><a href="#equals-与-的区别？" class="headerlink" title="equals 与 == 的区别？"></a>equals 与 == 的区别？</h4><blockquote><p>值类型（int,char,long,boolean 等）的话<br>都是用 == 判断相等性。<br>对象引用的话<br>= 判断引用所指的对象是否是同一个。<br>equals 方法，是 Object 的成员函数，有些类会覆盖(override) 这个方法，用于判断对象的等价性。<br>例如 String 类，两个引用所指向的 String 都是 “abc” ，但可能出现他们实际对应的对象并不是同一个（和 JVM 实现方式有关），因此用 == 判断他们可能不相等，但用 equals<br>方法判断一定是相等的。</p></blockquote><h4 id="如何在父类中为子类自动完成所有的-hashCode-和-equals-实现？这么做有何优劣"><a href="#如何在父类中为子类自动完成所有的-hashCode-和-equals-实现？这么做有何优劣" class="headerlink" title="如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣"></a>如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣</h4><blockquote><p>父类的 equals ，一般情况下是无法满足子类的 equals 的需求。<br>比如所有的对象都继承 Object ，默认使用的是 Object 的 equals 方法，在比较两个对象的时候，是看他们是否指向同一个地址。但是我们的需求是对象的某个属性相同，就相等了，而默认的 equals 方法<br>满足不了当前的需求，所以我们要重写 equals 方法。<br>如果重写了 equals 方法，就必须重写 hashCode 方法，否则就会降低 Map 等集合的索引速度</p></blockquote><h5 id="equals-方法，用于比较对象的内容是否相等"><a href="#equals-方法，用于比较对象的内容是否相等" class="headerlink" title="equals 方法，用于比较对象的内容是否相等"></a>equals 方法，用于比较对象的内容是否相等</h5><blockquote><p>当覆盖了 equals 方法时，比较对象是否相等将通过覆盖后的 equals 方法进行比较（判断对象的内容是否相等）。</p></blockquote><h5 id="hashCode-方法，大多在集合中用到。"><a href="#hashCode-方法，大多在集合中用到。" class="headerlink" title="hashCode 方法，大多在集合中用到。"></a>hashCode 方法，大多在集合中用到。</h5><blockquote><p>将对象放入到集合中时，首先判断要放入对象的 hashCode 值与集合中的任意一个元素的 hashCode 值是否相等，如果不相等直接将该对象放入集合中。<br>如果 hashCode 值相等，然后再通过 equals 方法判断要放入对象与集合中的任意一个对象是否相等，如果 equals 判断不相等，直接将该元素放入到集合中，否则不放入。</p></blockquote><h5 id="有没有可能-2-个不相等的对象有相同的-hashCode？"><a href="#有没有可能-2-个不相等的对象有相同的-hashCode？" class="headerlink" title="有没有可能 2 个不相等的对象有相同的 hashCode？"></a>有没有可能 2 个不相等的对象有相同的 hashCode？</h5><blockquote><p>可能会发生，这个被称为哈希碰撞。当然，相等的对象，即我们重写了 equals 方法，一定也要重写 hashCode 方法，否则将出现我们在 HashMap 中，相等的对象作为 key ，将找不到对应的 value 。<br>· equals 不相等，hashCode 可能相等。<br>· equals 相等，请重写 hashCode 方法，保证 hashCode 相等。</p></blockquote><h4 id="final、finally、finalize-的区别？"><a href="#final、finally、finalize-的区别？" class="headerlink" title="final、finally、finalize 的区别？"></a>final、finally、finalize 的区别？</h4><h5 id="final是修饰符关键字"><a href="#final是修饰符关键字" class="headerlink" title="final是修饰符关键字"></a>final是修饰符关键字</h5><blockquote><p>一个类被声明为 final ，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract 的，又被声明为 final 的。<br>将变量或方法声明为 final ，可以保证它们在使用中不被改变。被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为 final 的方法也同样只能使用，不能重写。</p></blockquote><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><blockquote><p>异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。<br>在以下 4 种特殊情况下，finally块不会被执行：</p><ol><li>在 finally 语句块中发生了异常。</li><li>在前面的代码中用了 System.exit() 退出程序。</li><li>程序所在的线程死亡。</li><li>关闭 CPU 。</li></ol></blockquote><h5 id="finalize-是方法名"><a href="#finalize-是方法名" class="headerlink" title="finalize 是方法名"></a>finalize 是方法名</h5><blockquote><p>Java 允许使用 #finalize() 方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。<br>它是在 Object 类中定义的，因此所有的类都继承了它。<br>子类覆盖 finalize() 方法，以整理系统资源或者执行其他清理工作。</p><p>#finalize() 方法，是在垃圾收集器删除对象之前对这个对象调用的。</p></blockquote><h5 id="String-类能被继承吗，为什么？"><a href="#String-类能被继承吗，为什么？" class="headerlink" title="String 类能被继承吗，为什么？"></a>String 类能被继承吗，为什么？</h5><blockquote><p>不能，因为 String 是 final 修饰</p></blockquote><h4 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h4><blockquote><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p></blockquote><h4 id="请详细讲述一下-RandomAccess-接口有什么作用？"><a href="#请详细讲述一下-RandomAccess-接口有什么作用？" class="headerlink" title="请详细讲述一下 RandomAccess 接口有什么作用？"></a>请详细讲述一下 RandomAccess 接口有什么作用？</h4><blockquote><p>RandomAccess 用来当标记的，是一种标记接口，接口的非典型用法。意思是，随机访问任意下标元素都比较快。<br>用处，当要实现某些算法时，会判断当前类是否实现了 RandomAccess 接口，会根据结果选择不同的算法</p></blockquote><h4 id="讲讲类的实例化顺序？"><a href="#讲讲类的实例化顺序？" class="headerlink" title="讲讲类的实例化顺序？"></a>讲讲类的实例化顺序？</h4><ol><li>父类静态变量</li><li>父类静态代码块</li><li>子类静态变量、</li><li>子类静态代码块</li><li>父类非静态变量（父类实例成员变量）</li><li>父类构造函数</li><li>子类非静态变量（子类实例成员变量）</li><li>子类构造函数<h4 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h4><blockquote><p>简单的说，就是在一个类、接口或者方法的内部创建另一个类。</p></blockquote><h5 id="内部类的作用是什么？"><a href="#内部类的作用是什么？" class="headerlink" title="内部类的作用是什么？"></a>内部类的作用是什么？</h5><blockquote><p>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</p></blockquote><h5 id="Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口"><a href="#Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口" class="headerlink" title="Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口"></a>Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口</h5><blockquote><p>可以继承其他类或实现其他接口，在 Java 集合的流式操作中，我们常常这么干</p></blockquote><h5 id="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制"><a href="#内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制" class="headerlink" title="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制"></a>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制</h5><blockquote><p>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p></blockquote><h4 id="什么是-Java-IO-？"><a href="#什么是-Java-IO-？" class="headerlink" title="什么是 Java IO ？"></a>什么是 Java IO ？</h4><blockquote><p>Java IO 相关的类，在 java.io 包下，具体操作分成面向字节(Byte)和面向字符(Character)两种方式</p></blockquote><h5 id="什么是-Java-序列化？"><a href="#什么是-Java-序列化？" class="headerlink" title="什么是 Java 序列化？"></a>什么是 Java 序列化？</h5><blockquote><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。<br>· 可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。<br>· 序列化是为了解决在对对象流进行读写操作时所引发的问题。</p></blockquote><h5 id="如何实现-Java-序列化？"><a href="#如何实现-Java-序列化？" class="headerlink" title="如何实现 Java 序列化？"></a>如何实现 Java 序列化？</h5><blockquote><p>将需要被序列化的类，实现 Serializable 接口，该接口没有需要实现的方法，implements Serializable 只是为了标注该对象是可被序列化的。<br>序列化<br>· 然后，使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象<br>· 接着，使用 ObjectOutputStream 对象的 #writeObject(Object obj) 方法，就可以将参数为 obj 的对象写出(即保存其状态)。<br>反序列化<br>要恢复的话则用输入流</p></blockquote><h5 id="Java-序列话中，如果有些字段不想进行序列化怎么办？"><a href="#Java-序列话中，如果有些字段不想进行序列化怎么办？" class="headerlink" title="Java 序列话中，如果有些字段不想进行序列化怎么办？"></a>Java 序列话中，如果有些字段不想进行序列化怎么办？</h5><blockquote><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p></blockquote><h4 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h4><blockquote><ol><li>实现 Cloneable 接口，并重写 Object 类中的 #clone() 方法。可以实现浅克隆，也可以实现深克隆。</li><li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆。可以实现真正的深克隆。</li></ol></blockquote><h5 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h5><blockquote><p>浅度克隆对于要克隆的对象，对于其基本数据类型的属性，复制一份给新产生的对象，对于非基本数据类型的属性，仅仅复制一份引用给新产生的对象，即新产生的对象和原始对象中的非基本数据类型的属性指<br>向的是同一个对象</p></blockquote><h5 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h5><blockquote><p>在浅度克隆的基础上，对于要克隆的对象中的非基本数据类型的属性对应的类，也实现克隆，这样对于非基本数据类型的属性，复制的不是一份引用，即新产生的对象和原始对象中的非基本数据类型的属性指向<br>的不是同一个对象</p></blockquote><h5 id="深克隆，浅克隆最大的区别在于新生成的克隆对象中的非基本数据类型是否是一个对象"><a href="#深克隆，浅克隆最大的区别在于新生成的克隆对象中的非基本数据类型是否是一个对象" class="headerlink" title="深克隆，浅克隆最大的区别在于新生成的克隆对象中的非基本数据类型是否是一个对象"></a>深克隆，浅克隆最大的区别在于新生成的克隆对象中的非基本数据类型是否是一个对象</h5></li></ol><h4 id="error-和-exception-有什么区别？CheckedException-和-RuntimeException-有什么区别？"><a href="#error-和-exception-有什么区别？CheckedException-和-RuntimeException-有什么区别？" class="headerlink" title="error 和 exception 有什么区别？CheckedException 和 RuntimeException 有什么区别？"></a>error 和 exception 有什么区别？CheckedException 和 RuntimeException 有什么区别？</h4><blockquote><p>Java 的异常体系，基于共同的祖先 java.lang.Throwable 类</p></blockquote><h5 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h5><blockquote><p>表示系统级的错误和程序不必处理的异常，是 Java 运行环境中的内部错误或者硬件问题。<br>例如：内存资源不足等。<br>对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由 Java 虚拟机抛出的。</p></blockquote><h5 id="Exception（异常），"><a href="#Exception（异常），" class="headerlink" title="Exception（异常），"></a>Exception（异常），</h5><blockquote><p>表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。Exception 又分为运行时异常，受检查异常。<br>RuntimeException(运行时异常)，表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止逻辑，因此，编译器不检查这些异常。<br>CheckedException(受检查异常)，是表示程序可以处理的异常，也即表示程序可以修复（由程序自己接受异常并且做出处理），所以称之为受检查异常</p></blockquote><h5 id="异常的使用的注意地方？"><a href="#异常的使用的注意地方？" class="headerlink" title="异常的使用的注意地方？"></a>异常的使用的注意地方？</h5><blockquote><ol><li>不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常）。</li><li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常。</li><li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）。</li><li>优先使用标准的异常。</li><li>每个方法抛出的异常都要有文档。</li><li>保持异常的原子性。</li><li>不要在 catch 中忽略掉捕获到的异常。</li></ol></blockquote><h4 id="throw-与-throws-的区别-？"><a href="#throw-与-throws-的区别-？" class="headerlink" title="throw 与 throws 的区别 ？"></a>throw 与 throws 的区别 ？</h4><blockquote><p>throw ，用于在程序中显式地抛出一个异常。<br>throws ，用于指出在该方法中没有处理的异常。每个方法必须显式指明哪些异常没有处理，以便该方法的调用者可以预防可能发生的异常。最后，多个异常用逗号分隔。</p></blockquote><h4 id="异常处理中-finally-语句块的重要性"><a href="#异常处理中-finally-语句块的重要性" class="headerlink" title="异常处理中 finally 语句块的重要性"></a>异常处理中 finally 语句块的重要性</h4><blockquote><p>不管程序是否发生了异常, finally 语句块都会被执行，甚至当没有catch 声明但抛出了一个异常时, finally 语句块也会被执行。<br>finally 语句块通常用于释放资源, 如 I/O 缓冲区, 数据库连接等等</p></blockquote><h4 id="说说反射的用途及实现？"><a href="#说说反射的用途及实现？" class="headerlink" title="说说反射的用途及实现？"></a>说说反射的用途及实现？</h4><blockquote><p><a href="https://www.cnblogs.com/zhaopei/p/reflection.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaopei/p/reflection.html</a></p></blockquote><h5 id="java-反射机制主要提供了以下功能："><a href="#java-反射机制主要提供了以下功能：" class="headerlink" title="java 反射机制主要提供了以下功能："></a>java 反射机制主要提供了以下功能：</h5><blockquote><ol><li>在运行时构造一个类的对象。</li><li>判断一个类所具有的成员变量和方法。</li><li>调用一个对象的方法。</li><li>生成动态代理。</li></ol></blockquote><h5 id="反射的应用很多，很多框架都有用到："><a href="#反射的应用很多，很多框架都有用到：" class="headerlink" title="反射的应用很多，很多框架都有用到："></a>反射的应用很多，很多框架都有用到：</h5><blockquote><p>Spring 框架的 IoC 基于反射创建对象和设置依赖属性。<br>Spring MVC 的请求调用对应方法，也是通过反射。<br>JDBC 的 Class#forName(String className) 方法，也是使用反射。</p></blockquote><h5 id="反射中，Class-forName-和-ClassLoader-区别？"><a href="#反射中，Class-forName-和-ClassLoader-区别？" class="headerlink" title="反射中，Class.forName 和 ClassLoader 区别？"></a>反射中，Class.forName 和 ClassLoader 区别？</h5><p>这两者，都可用来对类进行加载。差别在于：</p><blockquote><ol><li>Class#forName(…) 方法，除了将类的 .class 文件加载到JVM 中之外，还会对类进行解释，执行类中的 static 块。</li><li>ClassLoader 只干一件事情，就是将 .class 文件加载到 JVM 中，不会执行 static 中的内容，只有在 newInstance 才会去执行 static 块。</li><li>Class#forName(name, initialize, loader) 方法，带参函数也可控制是否加载 static 块，并且只有调用了newInstance 方法采用调用构造函数，创建类的对象。</li></ol></blockquote><h5 id="UnsupportedOperationException-是什么？"><a href="#UnsupportedOperationException-是什么？" class="headerlink" title="UnsupportedOperationException 是什么？"></a>UnsupportedOperationException 是什么？</h5><blockquote><p>UnsupportedOperationException ，是用于表明操作不支持的异常。<br>在 JDK 类中已被大量运用，在集合框架java.util.Collections.UnmodifiableCollection 将会在所有 add 和 remove 操作中抛出这个异常</p></blockquote><h4 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h4><blockquote><p>Java注解又称为标注，是Java从1.5开始支持加入源码的特殊语法元数据；Java中的类、方法、变量、参数、包都可以被注解。</p></blockquote><h4 id="什么时候用断言（assert）？"><a href="#什么时候用断言（assert）？" class="headerlink" title="什么时候用断言（assert）？"></a>什么时候用断言（assert）？</h4><blockquote><p>断言，在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。</p></blockquote><blockquote><p>一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。<br>断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为 false ，那么系统会报告一个AssertionError 错误。断言的使用如下面的代码所示：</p></blockquote><blockquote><p>assert(a &gt; 0); // throws an AssertionError if a &lt;= 0<br>断言可以有两种形式：<br>assert Expression1; 。<br>assert Expression1 : Expression2; 。<br>Expression1 应该总是产生一个布尔值。<br>Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。<br>要在运行时启用断言，可以在启动 JVM 时使用 -enableassertions 或者 -ea 标记。要在运行时选择禁用断言，可以在启动 JVM 时使用 -da 或者 -disableassertions 标记。要在系统类中<br>启用或禁用断言，可使用 -esa 或 -dsa 标记。还可以在包的基础上启用或者禁用断言。<br>当然，实际场景下，我们会在 Spring 的源码中看到，它自己封装了 Assert 类，实现更方便的断言功能，并且，在生产环境下也启用。<br>另外，在单元测试中，也会使用自己封装的断言类，判断执行结果的正确与错误。</p></blockquote><h4 id="Java-对象创建的方式？"><a href="#Java-对象创建的方式？" class="headerlink" title="Java 对象创建的方式？"></a>Java 对象创建的方式？</h4><ol><li>使用 new 关键字创建对象。</li><li>使用 Class 类的 newInstance 方法(反射机制)。</li><li>使用 Constructor 类的 newInstance 方法(反射机制)。</li><li>使用 clone 方法创建对象。</li><li>使用(反)序列化机制创建对象<h3 id="Java基础面试网址集合"><a href="#Java基础面试网址集合" class="headerlink" title="Java基础面试网址集合"></a>Java基础面试网址集合</h3><a href="https://wiki.jikexueyuan.com/project/java-interview-bible/basic-concept.html" target="_blank" rel="noopener">极客学院</a><br><a href="https://www.ituring.com.cn/article/507089" target="_blank" rel="noopener">32道常见的Java基础面试题</a><br><a href="https://github.com/Snailclimb/JavaGuide/blob/3dc5234d3a77d134e4768b17cc864c4cc1030e41/Java%E7%9B%B8%E5%85%B3/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md" target="_blank" rel="noopener">Java基础知识</a></li></ol></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;别问 问就是为了面试豁出了老命&lt;br&gt;[文章都是搬运艿艿的]&lt;br&gt;[&lt;a href=&quot;http://svip.iocoder.cn/Java/Core/Interview/]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://svip.iocoder.cn/Java/Core/Interview/]&lt;/a&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
